<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen RuiWen&#39;s Space</title>
  
  <subtitle>Life is real, life is earnest</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenruiwen.cn/"/>
  <updated>2018-07-21T10:56:13.000Z</updated>
  <id>http://www.chenruiwen.cn/</id>
  
  <author>
    <name>陈瑞文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring-boot集成ActiveMQ</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbe70016uifnq3cs2lnv/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbe70016uifnq3cs2lnv/</id>
    <published>2018-07-20T11:45:10.000Z</published>
    <updated>2018-07-21T10:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgrjn36onj20hj07vglv.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章<a href="https://www.chenruiwen.cn/2018/cjjvafgg80014opfnybr6ftoz/">spring-boot集成RabbitMQ</a>介绍了spring-boot如何集成RabbitMQ。本篇文章是spring-boot集成MQ的姊妹篇，看看spring-boot如何集成常用的ActiveMQ.<br><a id="more"></a></p><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><h3 id="JMS是什么"><a href="#JMS是什么" class="headerlink" title="JMS是什么"></a>JMS是什么</h3><p>百度百科：</p><blockquote><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p></blockquote><p>简单的说，JMS是j2ee技术中的提供了访问消息中间件的规范。它的常见实现如ActiveMQ。</p><h3 id="JMS-API简介"><a href="#JMS-API简介" class="headerlink" title="JMS API简介"></a>JMS API简介</h3><p><code>JMS 规范</code>和 <code>javax.jms</code> 包定义一组可供 Java 应用程序用于执行消息传递操作的接口。以下列表概括了主要的 JMS 接口：</p><ul><li>Destination：</li></ul><p>Destination 对象是应用程序将消息发往的位置和/或应用程序从其接收消息的源。</p><ul><li>ConnectionFactory：</li></ul><p>ConnectionFactory 对象包括连接的一组配置属性。应用程序使用连接工厂来创建连接。</p><ul><li>Connection：</li></ul><p>Connection 对象包括应用程序与消息传递服务器的活动连接。应用程序使用连接来创建会话。</p><ul><li>Session：</li></ul><p>Session 对象是用于发送和接收消息的单个线程上下文。应用程序使用会话来创建消息、消息生产者和消息使用者。会话是事务性或非事务性会话。</p><ul><li>Message：</li></ul><p>Message 对象包括应用程序发送或接收的消息。</p><ul><li>MessageProducer：</li></ul><p>应用程序使用消息生产者将消息发送到目标。</p><ul><li>MessageConsumer：</li></ul><p>应用程序使用消息使用者来接收已发送到目标的消息。</p><p>JMS对象及其关系:<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgomuzm3pj20qo0gf3yu.jpg" alt=""></p><h2 id="ActiveMQ介绍"><a href="#ActiveMQ介绍" class="headerlink" title="ActiveMQ介绍"></a>ActiveMQ介绍</h2><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p><p>特性：</p><ul><li>支持多种语言和协议。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP。</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li><li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去</li><li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>设计上保证了高性能的集群，客户端-服务器，点对点</li></ul><h2 id="ActiveMQ安装"><a href="#ActiveMQ安装" class="headerlink" title="ActiveMQ安装"></a>ActiveMQ安装</h2><p>通过国外地址下载通常比较慢，所以我们一般通过国内的镜像地址下载。</p><p>一些常用的apache其下的国内镜像地址：</p><ul><li><a href="https://mirrors.hust.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.hust.edu.cn/apache/</a> </li><li><a href="https://mirrors.shu.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.shu.edu.cn/apache/</a> </li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/</a> </li></ul><p>通过<a href="https://mirror.bit.edu.cn/apache/" target="_blank" rel="noopener">国内镜像地址</a>下载</p><pre><code>wget http://mirror.bit.edu.cn/apache/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gz</code></pre><p>解压：</p><pre><code>tar xf apache-activemq-5.14.5-bin.tar.gz</code></pre><p>启动：</p><pre><code>cd apache-activemq-5.14.5\bin\</code></pre><p>注意：如果一台机器启动RabbitMQ以及ActiveMQ,要注意端口冲突问题。<br>修改ActiveMQ端口,找到<code>..\apache-activemq-5.x.x\conf\</code>目录下的<code>activemq.xml</code>,修改<code>&lt;transportConnectors&gt;</code>标签下的<code>uri</code>属性，比如：</p><pre><code>&lt;transportConnectors&gt;    &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5673?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;&lt;/transportConnectors&gt;</code></pre><p>如何查看RabbitMQ的端口号？打开web控制台查看即可。</p><h2 id="集成置ActiveMQ"><a href="#集成置ActiveMQ" class="headerlink" title="集成置ActiveMQ"></a>集成置ActiveMQ</h2><p>使用过程与<code>RabbitMQ</code>类似，三步完成：</p><ul><li>maven依赖</li><li>配置ActiveMQ</li><li>编写代码及单元自测</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><pre><code>&lt;!-- activemq --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置ActiveMQ"><a href="#配置ActiveMQ" class="headerlink" title="配置ActiveMQ"></a>配置ActiveMQ</h3><p>在<code>application.yml</code>里添加几行即可:</p><pre><code>spring:  activemq:    broker-url: tcp://127.0.0.1:61616   #activeMQ地址    user: admin                         #用户名    password: admin                     #密码    in-memory: true                     #是否启用内存模式（也就是不安装MQ，项目启动时同时也启动一个MQ实例    pool:      enabled: false                    #是否替换默认的connectionFactory    packages:      trust-all: true                   #信任所有的包</code></pre><h3 id="编写代码及单元自测"><a href="#编写代码及单元自测" class="headerlink" title="编写代码及单元自测"></a>编写代码及单元自测</h3><p>一. 配置一个<code>hello</code>队列：</p><pre><code class="java">@Configurationpublic class MessageQueueConfig {    @Bean    public javax.jms.Queue helloQueueByActiveMQ() {        return new ActiveMQQueue(&quot;hello&quot;);    }}</code></pre><p>二. 消息推送端，向<code>hello</code>队列发送一条消息:</p><pre><code class="java">@Component@Slf4jpublic class HelloActiveMQSender {    @Autowired    private JmsMessagingTemplate jmsMessagingTemplate;    public void send(String content) {        log.info(&quot;ActiveMQ send : {}&quot;, content);        this.jmsMessagingTemplate.convertAndSend(&quot;hello&quot;, content);    }}</code></pre><p>三. 消息消费端，消费一条<code>hello</code>队列里的消息:</p><pre><code class="java">@Slf4j@Component@EnableJmspublic class HelloActiveMQConsumer {    @JmsListener(destination = &quot;hello&quot;)    public void process(String hello) {        log.info(&quot;ActiveMQ receiver : {}&quot;, hello);    }}</code></pre><p>四. 单元测试发送一条消息:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class HelloActiveMQSenderTest {    @Autowired    private HelloActiveMQSender sender;    @Test    public void sendHello() {        sender.send(&quot;Hello &quot; + new Date());    }}</code></pre><p>输出结果，可以确认消息发送并且被消费了：</p><pre><code>2018-07-17 16:56:16.320 [main] INFO  com.crw.mq.HelloActiveMQSender - ActiveMQ send : Hello Tue Jul 17 16:56:16 CST 20182018-07-17 16:56:16.355 [DefaultMessageListenerContainer-1] INFO  com.crw.mq.HelloActiveMQConsumer - ActiveMQ receiver : Hello Tue Jul 17 16:56:16 CST 2018</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgrjn36onj20hj07vglv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章&lt;a href=&quot;https://www.chenruiwen.cn/2018/cjjvafgg80014opfnybr6ftoz/&quot;&gt;spring-boot集成RabbitMQ&lt;/a&gt;介绍了spring-boot如何集成RabbitMQ。本篇文章是spring-boot集成MQ的姊妹篇，看看spring-boot如何集成常用的ActiveMQ.&lt;br&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="ActiveMQ" scheme="http://www.chenruiwen.cn/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成RabbitMQ</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbe80017uifn60vvtzhd/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbe80017uifn60vvtzhd/</id>
    <published>2018-07-19T09:22:10.000Z</published>
    <updated>2018-07-21T10:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgrlo2wfzj20ji0atmx4.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>消息队列是日常开发中非常常用的工具，当调用方不需要关心执行结果时，你可以使用它来解耦。<br>本文简单介绍下spring-boot中快速使用RabbitMQ完成队列的发送与消费。<br><a id="more"></a></p><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。</p><h3 id="消息代理"><a href="#消息代理" class="headerlink" title="消息代理"></a>消息代理</h3><p>消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。</p><p>由于AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。</p><h3 id="AMQP协议模型"><a href="#AMQP协议模型" class="headerlink" title="AMQP协议模型"></a>AMQP协议模型</h3><p>这里推荐直接查看 <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">AMQP 0-9-1 模型解析</a>。</p><h3 id="RabbitMQ与AMQP的关系"><a href="#RabbitMQ与AMQP的关系" class="headerlink" title="RabbitMQ与AMQP的关系"></a>RabbitMQ与AMQP的关系</h3><p><code>RabbitMQ</code>采用<code>Erlang</code>语言开发。是<code>AMQP</code>协议的一个实现。</p><h2 id="安装rabbitMQ"><a href="#安装rabbitMQ" class="headerlink" title="安装rabbitMQ"></a>安装rabbitMQ</h2><p>根据<a href="https://www.rabbitmq.com/install-debian.html" target="_blank" rel="noopener">RabbitMQ文档 Installing on Debian and Ubuntu</a>进行安装。</p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>一. 下载并安装Erlang。官网下载页：<code>http://www.erlang.org/downloads</code>。</p><p>二. 下载并安装RabbitMQ。官网下载页：<code>https://www.rabbitmq.com/download.html</code>。安装完成后会自动注册到服务中启动。</p><h3 id="Mac-OS-X安装"><a href="#Mac-OS-X安装" class="headerlink" title="Mac OS X安装"></a>Mac OS X安装</h3><p>一. 安装Erlang，执行命令：<code>brew install erlang</code>。</p><p>二. 安装RabbitMQ，执行命令：<code>brew install rabbitmq</code>。</p><h3 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h3><p>一. 安装Erlang，执行命令：<code>apt-get install erlang erlang-nox</code>。</p><p>二. 在系统中加入RabbitMQ apt 仓库:</p><pre><code>echo &#39;deb http://www.rabbitmq.com/debian/ testing main&#39; | sudo tee /etc/apt/sources.list.d/rabbitmq.list</code></pre><p>三. 添加signing key，执行命令:</p><pre><code>wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -。</code></pre><p>四. 更新APT仓库的package list，执行命令:<code>apt-get update</code></p><p>五. 安装Rabbit Server，执行命令：<code>apt-get install rabbitmq-server</code>。</p><h3 id="web控制台"><a href="#web控制台" class="headerlink" title="web控制台"></a>web控制台</h3><p>RabbitMQ内置提供了Web管理插件。</p><ul><li>开启RabbitMQ web管理  <ul><li>Windows系统：进入插件目录:<code>D:\rabbitmq\rabbitmq_server-3.7.7\sbin</code>，运行命令：<pre><code>rabbitmq-plugins.bat enable rabbitmq_management</code></pre></li><li>Linux和Mac系统: 运行命令：<pre><code>rabbitmq-plugins enable rabbitmq_management。</code></pre></li></ul></li><li>通过浏览器访问web管理界面：<code>http://localhost:15672/</code>，默认登录用户:<code>guest</code>,密码:<code>guest</code>。</li></ul><h2 id="spring-boot中使用RabbitMQ"><a href="#spring-boot中使用RabbitMQ" class="headerlink" title="spring-boot中使用RabbitMQ"></a>spring-boot中使用RabbitMQ</h2><p>三步完成集成:</p><ul><li>maven依赖</li><li>配置RabbitMQ</li><li>代码使用及测试</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>仅需添加</p><pre><code>&lt;!-- amqp,用于支持RabbitMQ --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置rabbitMQ"><a href="#配置rabbitMQ" class="headerlink" title="配置rabbitMQ"></a>配置rabbitMQ</h3><p>配置非常简单，在<code>application.yml</code>添加rabbitMQ相关:</p><pre><code class="java"># rabbitMQspring:  rabbitmq:    host: 127.0.0.1    port: 5672    username: guest    password: guest</code></pre><h3 id="代码中使用及测试"><a href="#代码中使用及测试" class="headerlink" title="代码中使用及测试"></a>代码中使用及测试</h3><p>一. 在配置类中创建一个<code>hello</code>队列：</p><pre><code class="java">@Configurationpublic class MessageQueueConfig {    @Bean    public org.springframework.amqp.core.Queue helloQueueByRabbitMQ() {        return new org.springframework.amqp.core.Queue(&quot;hello&quot;);    }}</code></pre><p>二. 消息推送端，向<code>hello</code>队列发送一条消息:</p><pre><code class="java">@Component@Slf4jpublic class HelloRabbitMQSender {    @Autowired    private AmqpTemplate rabbitTemplate;    public void send(String content) {        log.info(&quot;RabbitMQ send : {}&quot;, content);        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, content);    }}</code></pre><p>三. 消息消费端，消费一条<code>hello</code>队列里的消息:</p><pre><code class="java">@Component@RabbitListener(queues = &quot;hello&quot;)@Slf4jpublic class HelloRabbitMQConsumer {    @RabbitHandler    public void process(String hello) {        log.info(&quot;RabbitMQ receiver : {}&quot;, hello);    }}</code></pre><p>四. 单元测试发送一条消息:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class HelloRabbitMQSenderTest {    @Autowired    private HelloRabbitMQSender sender;    @Test    public void sendHello() {        sender.send(&quot;Hello &quot; + new Date());    }}</code></pre><p>输出结果，可以确认消息发送并且被消费了：</p><pre><code>2018-07-16 14:23:09.844 [main] INFO  com.crw.mq.HelloRabbitMQSender - RabbitMQ send : Hello Mon Jul 16 14:23:09 CST 20182018-07-16 14:23:09.872 [SimpleAsyncTaskExecutor-1] INFO  com.crw.mq.HelloRabbitMQConsumer - RabbitMQ receiver : Hello Mon Jul 16 14:23:09 CST 2018</code></pre><p> 这里仅仅简单介绍了使用RabbitMQ基于队列完成简单的点对点的使用，这也是在web开发中最常用的方式(易于系统解耦、消峰)。更多的使用还是参考官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgrlo2wfzj20ji0atmx4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;消息队列是日常开发中非常常用的工具，当调用方不需要关心执行结果时，你可以使用它来解耦。&lt;br&gt;本文简单介绍下spring-boot中快速使用RabbitMQ完成队列的发送与消费。&lt;br&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="RabbitMQ" scheme="http://www.chenruiwen.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>mybatis集成分页插件pageHelper</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbe4000zuifnki9k0j1j/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbe4000zuifnki9k0j1j/</id>
    <published>2018-07-14T11:32:24.000Z</published>
    <updated>2018-07-21T10:52:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>web开发少不了分页，本文将简单介绍使用基于<code>spring-boot</code> + <code>mybatis</code> + <code>pageHelper</code>技术实现数据库分页。</p><p>本文算是对上一篇<a href="https://www.chenruiwen.cn/2018/cjjvafgg90019opfn82n9enuk">spring-boot集成mybatis</a>的一个补充。</p><a id="more"></a><h2 id="pageHelper简介"><a href="#pageHelper简介" class="headerlink" title="pageHelper简介"></a>pageHelper简介</h2><p>使用<code>MyBatis</code>作为数据访问层进行对sql语句分页的最好用的插件。</p><p>建议去<a href="https://pagehelper.github.io/" target="_blank" rel="noopener">pageHelper官网</a>看一看。</p><p>特点：</p><ul><li>物理分页：支持常见的12种数据库。Oracle,MySql,MariaDB,SQLite,DB2,PostgreSQL,SqlServer等。</li><li>支持多种分页方式：支持常见的RowBounds(PageRowBounds)，PageHelper.startPage 方法调用，Mapper 接口参数调用。</li><li>QueryInterceptor 规范：使用 QueryInterceptor 规范，开发插件更轻松。</li></ul><h2 id="集成pageHelper"><a href="#集成pageHelper" class="headerlink" title="集成pageHelper"></a>集成pageHelper</h2><p>三步完成集成：</p><ul><li>maven依赖</li><li>配置pageHelper</li><li>代码使用及测试</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>此处依赖在集成了mybatis的基础上增加:</p><pre><code>&lt;!-- pagehelper --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="配置pageHelper"><a href="#配置pageHelper" class="headerlink" title="配置pageHelper"></a>配置pageHelper</h3><p>在<code>application.yml</code>里增加:</p><pre><code># 分页配置pagehelper:  helper-dialect: mysql  reasonable: &quot;true&quot;  support-methods-arguments: &quot;true&quot;  params: count=countSql</code></pre><h3 id="代码使用及测试"><a href="#代码使用及测试" class="headerlink" title="代码使用及测试"></a>代码使用及测试</h3><p>根据<a href="https://pagehelper.github.io/docs/howtouse/#3-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">官网之如何在代码中使用</a>中的推荐，我们使用静态方法<code>PageHelper.startPage</code>来实现分页。</p><p>首先是SbpUserMapper接口增加方法：</p><pre><code class="java">public interface SbpUserMapper {    List&lt;SbpUser&gt; getAll();}</code></pre><p>对应的SbpUserMapper.xml增加sql:</p><pre><code>&lt;select id=&quot;getAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;    SELECT * FROM sbp_user&lt;/select&gt;</code></pre><p>代码使用，传参当前页为1，每页条数显示5条:</p><pre><code>@Test@Rollbackpublic void pageByPageHelper() throws Exception {    PageHelper.startPage(1, 5);    List&lt;SbpUser&gt; users = sbpUserMapper.getAll();    Page&lt;SbpUser&gt; page = (Page&lt;SbpUser&gt;) users;    System.out.println(&quot;total count :&quot; + page.getTotal());    System.out.println(&quot;pages :&quot; + page.getPages());    System.out.println(&quot;data :&quot; + page.getResult());}</code></pre><p>输出:</p><pre><code>total count :21pages :5data :Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=21, pages=5, reasonable=true, pageSizeZero=false}</code></pre><p>还有更多的用法请参考官方文档。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>pageHelper还是非常好用的，简单，集成方便，是和mybatis搭配的分页插件首选。除此之外，大家一定要会自行写分页接口，除此之外还要 知其然，知其所以然。看其源码实现与设计理念，得到的不仅仅是分页。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;web开发少不了分页，本文将简单介绍使用基于&lt;code&gt;spring-boot&lt;/code&gt; + &lt;code&gt;mybatis&lt;/code&gt; + &lt;code&gt;pageHelper&lt;/code&gt;技术实现数据库分页。&lt;/p&gt;
&lt;p&gt;本文算是对上一篇&lt;a href=&quot;https://www.chenruiwen.cn/2018/cjjvafgg90019opfn82n9enuk&quot;&gt;spring-boot集成mybatis&lt;/a&gt;的一个补充。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="mybatis" scheme="http://www.chenruiwen.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成Log4j2</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbe50011uifnri95nowd/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbe50011uifnri95nowd/</id>
    <published>2018-07-13T02:10:10.000Z</published>
    <updated>2018-07-14T01:29:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在企业级项目里，日志框架种类杂乱不一，尤其是接手一些有些年头的老项目时，各种各样的日志框架依赖和使用让人看的头大。</p><p>如何解决各种各样日志框架的大一统呢？神器<code>Slf4j</code>。</p><p>spring-boot如何利用<code>Slf4j</code>集成其他日志框架？本文将以<code>Log4j2</code>为例。</p><a id="more"></a><h2 id="Slf4j简单介绍"><a href="#Slf4j简单介绍" class="headerlink" title="Slf4j简单介绍"></a>Slf4j简单介绍</h2><p>去<a href="https://www.slf4j.org/" target="_blank" rel="noopener">Slf4j官网</a>瞧一瞧:</p><blockquote><p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p></blockquote><p>Slf4j:Simple Logging Facade for Java.<br>它并不是一个类似java.util.logging, logback, log4j等的日志框架实现，而是作为一个门面服务于这些各种日志框架。如同字面含义，类似外观设计模式，提供了一组简单统一的API接口，隐藏了各种日志不一致的复杂性。</p><h2 id="日志框架选型"><a href="#日志框架选型" class="headerlink" title="日志框架选型"></a>日志框架选型</h2><p>几种日志框架简单对比:</p><ul><li><code>log4j</code>:元老级日志框架。它定义的Logger、Appender、Level等概念如今已经被广泛使用，里程碑式的日志框架</li><li><code>java.util.logging</code>:简称<code>j.u.l</code>。java1.4版本引入，功能不如<code>log4j</code>，性能和可用性有限。</li><li><code>logback</code>：<code>log4j</code>升级版。它比<code>log4j</code>增加了不少功能，比如：原生实现了<code>Slf4J</code>,支持XML、Groovy方式配置等，主要是性能比<code>log4j</code>提升不少。</li><li><code>log4j2</code>:同样是<code>log4j</code>升级版。也比<code>log4j</code>添加不少功能，比如多线程下的异步日志等。性能也提升不少。</li></ul><p>至于<code>logback</code>和<code>log4j2</code>性能比对，可以参考网上博文：</p><ul><li><a href="https://blog.csdn.net/yjh1271845364/article/details/70888262" target="_blank" rel="noopener">logback log4j log4j2 性能实测</a></li><li><a href="https://www.jianshu.com/p/570b406bddcd" target="_blank" rel="noopener">看log4j2如何秒杀一切日志组件</a></li></ul><p>根据官方推荐是<code>Slf4j</code>+<code>logback</code>，此处我使用<code>Slf4j2</code>+<code>log4j2</code>来集成日志框架。</p><h2 id="集成Log4j2"><a href="#集成Log4j2" class="headerlink" title="集成Log4j2"></a>集成Log4j2</h2><p>三步完成Log4j2的集成:</p><ol><li>maven依赖</li><li>配置日志文件</li><li>测试日志</li></ol><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>pom.xml：</p><pre><code>&lt;!-- 需要排除logback --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- log4j2 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置日志文件"><a href="#配置日志文件" class="headerlink" title="配置日志文件"></a>配置日志文件</h3><p>classpath下添加<code>log4j2.xml</code>:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;OFF&quot;&gt;    &lt;properties&gt;        &lt;property name=&quot;LOG_HOME&quot;&gt;../logs/&lt;/property&gt;        &lt;property name=&quot;STDOUT_FILE_NAME&quot;&gt;stdout&lt;/property&gt;    &lt;/properties&gt;    &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;RollingRandomAccessFile name=&quot;stdout-log&quot;                                 fileName=&quot;${LOG_HOME}/${STDOUT_FILE_NAME}.log&quot;                                 filePattern=&quot;${LOG_HOME}/$${date:yyyy-MM}/${STDOUT_FILE_NAME}-%d{yyyy-MM-dd}-%i.log.gz&quot;&gt;            &lt;PatternLayout                    pattern=&quot;%date{yyyy-MM-dd HH:mm:ss.SSS} %level [%thread][%file:%line] - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;error&quot;&gt;            &lt;AppenderRef ref=&quot;stdout-log&quot;/&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/root&gt;        &lt;logger name=&quot;com.crw&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;stdout-log&quot;/&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/logger&gt;    &lt;/loggers&gt;&lt;/configuration&gt;</code></pre><p>修改应用日志文件路径，<code>application.yml</code>:</p><pre><code>logging.config: classpath:log4j2.xml</code></pre><h3 id="测试日志"><a href="#测试日志" class="headerlink" title="测试日志"></a>测试日志</h3><p>增加一个EchoController:</p><pre><code class="java">@RestController@Slf4jpublic class EchoController {    @GetMapping(&quot;/echo/hello&quot;)    public String echo(String msg) {        log.debug(&quot;DEBUG ----&gt; echo:{}&quot;, msg);        log.info(&quot;INFO  ----&gt; echo:{}&quot;, msg);        log.warn(&quot;WARN  ----&gt; echo:{}&quot;, msg);        log.error(&quot;ERROR  ----&gt; echo:{}&quot;, msg);        return &quot;hello, &quot; + msg;    }}</code></pre><p>调用接口地址：</p><pre><code>curl http://127.0.0.1:8080/echo/hello?msg=world  </code></pre><p>页面输出：</p><pre><code>hello, world</code></pre><p>stdout.log文件输出：</p><pre><code>2018-07-12 22:56:04.023 INFO [http-nio-8080-exec-3][EchoController.java:17] - INFO  ----&gt; echo:world2018-07-12 22:56:04.024 WARN [http-nio-8080-exec-3][EchoController.java:18] - WARN  ----&gt; echo:world2018-07-12 22:56:04.024 ERROR [http-nio-8080-exec-3][EchoController.java:19] - ERROR  ----&gt; echo:world</code></pre><p>debug级别的日志并未输出和打印在控制台，info级别以上日志打印并输出控制台。可见日志测试成功。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文简单介绍了日志框架的种类已经统一日志API框架<code>Slf4j</code>,除此之外，apache下也有与<code>Slf4j</code>同一职能的框架<code>commons-logging</code>。之后可自行研究一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在企业级项目里，日志框架种类杂乱不一，尤其是接手一些有些年头的老项目时，各种各样的日志框架依赖和使用让人看的头大。&lt;/p&gt;
&lt;p&gt;如何解决各种各样日志框架的大一统呢？神器&lt;code&gt;Slf4j&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;spring-boot如何利用&lt;code&gt;Slf4j&lt;/code&gt;集成其他日志框架？本文将以&lt;code&gt;Log4j2&lt;/code&gt;为例。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="log4j" scheme="http://www.chenruiwen.cn/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成mybatis</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbeb001duifne1okewm3/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbeb001duifne1okewm3/</id>
    <published>2018-07-12T14:05:24.000Z</published>
    <updated>2018-07-21T10:56:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你是一个j2ee开发工程师，你一定不能不会spring，你一定不能不了解spring-boot，你一定不能不知道最火的orm框架Mybatis。</p><p>本文使用spring-boot集成mybatis，体会下spring-boot + mybatis实现效率开发数据层代码。<br><a id="more"></a></p><h2 id="一分钟创建工程"><a href="#一分钟创建工程" class="headerlink" title="一分钟创建工程"></a>一分钟创建工程</h2><p>通过idea创建spring-boot项目，<code>File</code>-&gt;<code>New</code>-&gt;<code>Project...</code>:<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1ft6c5enpelj218w0p6whs.jpg" alt=""><br>点击<code>Next</code>配置你的项目的基础信息，再点击<code>Next</code>，勾选需要的依赖:<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1ft6c8dos77j21bq0si79c.jpg" alt=""><br>创建完毕。耗时不到半分钟。</p><p>对于非idea使用的用户，可以直接登录<a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a>,用同样的方式打包你的程序即可。</p><h2 id="mybatis自动生成代码"><a href="#mybatis自动生成代码" class="headerlink" title="mybatis自动生成代码"></a>mybatis自动生成代码</h2><p>通过mybatis-generator技术来自动生成数据库层相关代码。</p><p>大致分为三步：</p><ol><li>创建表结构。</li><li>配置 generatorConfig.xml</li><li>依赖 mybatis-generator-maven-plugin 并运行创建</li></ol><h3 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h3><p>创建一个简单的用户表：</p><pre><code>CREATE TABLE `sbp_user` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `nick_name` varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;昵称&#39;,  `password` varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;密码&#39;,  `mobile` varchar(15) DEFAULT NULL COMMENT &#39;手机号码&#39;,  `create_at` bigint(20) NOT NULL,  `update_at` bigint(20) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8;</code></pre><h3 id="配置-generatorConfig-xml"><a href="#配置-generatorConfig-xml" class="headerlink" title="配置 generatorConfig.xml"></a>配置 generatorConfig.xml</h3><p>以下配置文件都放置在classpath下：</p><p>generator.properties文件：</p><pre><code>## jdbcjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://10.0.0.20:3306/spring-boot-practice?useUnicode=true&amp;amp;characterEncoding=utf-8jdbc.username=rootjdbc.password=root## modelmodel.targetPackage=com.crw.model## DAOdao.targetPackage=com.crw.mapperdao.type=XMLMAPPER## table.name=product_honortable.name=sbp_user</code></pre><p>generatorConfig.xml文件:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;properties resource=&quot;generator.properties&quot;&gt;&lt;/properties&gt;    &lt;context id=&quot;mysql&quot; defaultModelType=&quot;flat&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;${jdbc.driverClassName}&quot;                        connectionURL=&quot;${jdbc.url}&quot;                        userId=&quot;${jdbc.username}&quot;                        password=&quot;${jdbc.password}&quot;/&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;javaModelGenerator targetPackage=&quot;${model.targetPackage}&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator targetPackage=&quot;${dao.targetPackage}&quot; targetProject=&quot;src/main/java&quot; type=&quot;${dao.type}&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;&quot;/&gt;            &lt;property name=&quot;exampleMethodVisibility&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;methodNameCalculator&quot; value=&quot;&quot;/&gt;            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;table tableName=&quot;${table.name}&quot; schema=&quot;wealth&quot;               enableUpdateByExample=&quot;true&quot;&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>附录：mybatis generator 配置详解，参考资料：<a href="http://www.jianshu.com/p/e09d2370b796" target="_blank" rel="noopener">http://www.jianshu.com/p/e09d2370b796</a></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties            url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.    注意，两个属性只能选址一个;    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包     location属性指明加载jar/zip包的全路径&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;  --&gt;&lt;!--     context:生成一组对象的环境     id:必选，上下文id，用于在生成错误时提示    defaultModelType:指定生成对象的样式        1，conditional：类似hierarchical；        2，flat：所有内容（主键，blob）等全部生成在一个对象中；        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)    targetRuntime:        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；    introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;    &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖     --&gt;    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;    &lt;!-- 生成的Java文件的编码 --&gt;    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;    &lt;!-- 格式化java代码 --&gt;    &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;    &lt;!-- 格式化XML代码 --&gt;    &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;    &lt;!-- 必须要有的，使用这个配置链接数据库        @TODO:是否可以扩展     --&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;    &lt;/jdbcConnection&gt;    &lt;!-- java类型处理器         用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；     --&gt;    &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;        &lt;!--             true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型            false：默认,                scale&gt;0;length&gt;18：使用BigDecimal;                scale=0;length[10,18]：使用Long；                scale=0;length[5,9]：使用Integer；                scale=0;length&lt;5：使用Short；         --&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!-- java模型创建器，是必须要的元素        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录     --&gt;    &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;!--  for MyBatis3/MyBatis3Simple            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；         --&gt;        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;!-- for MyBatis3 / MyBatis3Simple            是否创建一个不可变的类，如果为true，            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类         --&gt;        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;        &lt;!-- 设置一个根对象，            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：                1，属性名相同，类型相同，有相同的getter/setter方法；         --&gt;        &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!-- 生成SQL map的XML文件生成器，        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置        targetPackage/targetProject:同javaModelGenerator     --&gt;    &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口         targetPackage/targetProject:同javaModelGenerator        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER    --&gt;    &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;         --&gt;    &lt;/javaClientGenerator&gt;    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素        选择的table会生成一下文件：        1，SQL map文件        2，生成一个主键类；        3，除了BLOB和主键的其他字段的类；        4，包含BLOB的类；        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；        6，Mapper接口（可选）        tableName（必要）：要生成对象的表名；        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；            4，否则，使用指定的大小写格式查询；        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；        可选：        1，schema：数据库的schema；        2，catalog：数据库的catalog；        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；        5，enableInsert（默认true）：指定是否生成insert语句；        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；        13，modelType：参考context元素的defaultModelType，相当于覆盖；        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；     --&gt;    &lt;table tableName=&quot;userinfo&quot; &gt;        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;        &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;        &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;        &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;        &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性         &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;         --&gt;        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog         &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema         &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename         &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；         --&gt;        &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;        &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;        &lt;!-- generatedKey用于生成生成主键的方法，            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选            column:主键的列名；            sqlStatement：要生成的selectKey语句，有以下可选项：                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()                Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;         --&gt;        &lt;!--             该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，            如果使用了columnOverride元素，该属性无效；        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;         --&gt;         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；             column:要重新设置的列名；             注意，一个table元素中可以有多个columnOverride元素哈~          --&gt;         &lt;columnOverride column=&quot;username&quot;&gt;             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;             &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;              --&gt;             &lt;!-- jdbcType用于指定该列的JDBC类型              &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;              --&gt;             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;             --&gt;             &lt;!-- 参考table元素的delimitAllColumns配置，默认为false             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;              --&gt;         &lt;/columnOverride&gt;         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现              column:指定要忽略的列的名字；             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false             注意，一个table元素中可以有多个ignoreColumn元素         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;         --&gt;    &lt;/table&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="通过mybatis-generator-maven-plugin插件生产代码"><a href="#通过mybatis-generator-maven-plugin插件生产代码" class="headerlink" title="通过mybatis-generator-maven-plugin插件生产代码"></a>通过mybatis-generator-maven-plugin插件生产代码</h3><p>配置maven依赖：</p><pre><code>&lt;build&gt;    &lt;plugins&gt;        ...        &lt;!-- mybatis generator--&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.4&lt;/version&gt;            &lt;configuration&gt;                &lt;verbose&gt;true&lt;/verbose&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;5.1.41&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>运行命令：</p><pre><code>mvn mybatis-generator:generate</code></pre><p>即可生成相应的代码至相应的配置目录。</p><h2 id="集成mybatis"><a href="#集成mybatis" class="headerlink" title="集成mybatis"></a>集成mybatis</h2><p>三步完成集成：</p><ol><li>添加maven依赖</li><li>配置数据源和Mybatis</li><li>单元测试</li></ol><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><p>依赖spring-boot相关以及jdbc相关：</p><pre><code>&lt;dependencies&gt;    &lt;!-- spring-boot相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- mybatis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.41&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.18&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h3 id="配置数据源和Mybatis"><a href="#配置数据源和Mybatis" class="headerlink" title="配置数据源和Mybatis"></a>配置数据源和Mybatis</h3><p>配置spring-boot的<code>application.yml</code>(如果喜欢用<code>application.properties</code>)的改成相应的格式即可。</p><p>如下创建连接池和mybatis配置：</p><pre><code># jdbc-DruidDataSource连接池配置sbp.datasource:  type: com.alibaba.druid.pool.DruidDataSource  driver-class-name: com.mysql.jdbc.Driver  url: jdbc:mysql://127.0.0.1:3306/spring-boot-practice?useUnicode=true&amp;amp;characterEncoding=utf8mb4&amp;amp;useSSL=false&amp;amp;autoReconnect=true  username: root  password: root# mybatismybatis:  mapperLocations: classpath:mapper/*.xml  configuration.mapUnderscoreToCamelCase: true</code></pre><p>创建DataSource,映射配置文件内容，扫描mapper接口：</p><pre><code class="java">@Configuration@MapperScan(basePackages = &quot;com.crw.mapper&quot;)public class DataSourceConfig {    @Bean    @ConfigurationProperties(prefix = &quot;sbp.datasource&quot;)    public DataSource datasource() {        return new DruidDataSource();    }}</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试mybatis是否正常:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class SbpUserMapperTest {    @Autowired    private SbpUserMapper sbpUserMapper;    @Test    @Rollback    public void insert() throws Exception {        long now = System.currentTimeMillis();        int id = sbpUserMapper.insert(new SbpUser(1L, &quot;张三&quot;, &quot;111111&quot;, &quot;11100001001&quot;, now, now));        Assert.assertEquals(id, 1L);    }    @Test    @Rollback    public void selectByPrimaryKey() throws Exception {        SbpUser user = sbpUserMapper.selectByPrimaryKey(1L);        Assert.assertEquals(&quot;张三&quot;, user.getNickName());    }    @Test    @Rollback    public void update() throws Exception {        long now = System.currentTimeMillis();        sbpUserMapper.updateByPrimaryKey(new SbpUser(1L, &quot;张三改&quot;, &quot;111111&quot;, &quot;11100001001&quot;, now, now));        SbpUser user = sbpUserMapper.selectByPrimaryKey(1L);        Assert.assertEquals(&quot;张三改&quot;, user.getNickName());    }    @Test    @Rollback    public void selectByExample() throws Exception {        SbpUserExample example = new SbpUserExample();        SbpUserExample.Criteria criteria = example.createCriteria();        criteria.andMobileEqualTo(&quot;11100001001&quot;);        List&lt;SbpUser&gt; users = sbpUserMapper.selectByExample(example);        Assert.assertEquals(users.size(), 1);    }}</code></pre><p>运行之后正常CRUD，完成spring-boot与Mybatis的集成。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇文章从创建spring-boot项目开始介绍了集成mybatis的过程。<br>可以见到spring-boot是多么的高效：</p><ul><li>一分钟(半分钟)创建spring-boot项目</li><li>三步完成myybatis代码自动生成</li><li>三步配置集成mybatis</li></ul><p>前后大概10分钟时间绰绰有余了。效率是不是不差于世界上最好的PHP呢？(:D)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果你是一个j2ee开发工程师，你一定不能不会spring，你一定不能不了解spring-boot，你一定不能不知道最火的orm框架Mybatis。&lt;/p&gt;
&lt;p&gt;本文使用spring-boot集成mybatis，体会下spring-boot + mybatis实现效率开发数据层代码。&lt;br&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="http://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="mybatis" scheme="http://www.chenruiwen.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java并发修行之基础篇：线程安全</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbe2000uuifndd05143i/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbe2000uuifndd05143i/</id>
    <published>2018-07-09T14:16:24.000Z</published>
    <updated>2018-07-21T10:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在互联网应用广泛的今天，软件并发已经成为目前软件开发的必备基础。java作为一门成熟的语言，其拥有着极其高效的并发机制，是目前大中型企业的常用开发语言。想要开发大规模应用，java并发已成为java程序猿们的必备基础技能。</p><p>从今天开始，开启java并发修行之路。</p><a id="more"></a><h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2><p>线程的安全性总是难以定义的。<br>在阅读<a href="https://item.jd.com/10922250.html" target="_blank" rel="noopener">《java并发编程实战》</a>的过程中觉得说的很好：</p><blockquote><p>在线程安全性的定义中，最核心的概念就是正确性。</p></blockquote><p>何为正确性？</p><blockquote><p>某个类的行为与其规范完全一致。</p></blockquote><p>通常我们并不规定类的规范，于是我们通俗对正确性的理解是，单线程的类的行为是按照我们“所见”来运行的，我们确保其可信，“所见即所知”。</p><p>于是给出线程安全性的定义：</p><blockquote><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为。</p></blockquote><p>某个对象保证多线程环境下共享、可修改的状态的正确性，那么即是线程安全。</p><p>换个角度分析：</p><ul><li>当某个类单线程条件都不是正确的，那么其肯定不是线程安全的。</li><li>无状态对象一定线程安全</li><li>状态不共享或不可修改，即不存在线程安全问题。</li></ul><h2 id="如何做到线程安全"><a href="#如何做到线程安全" class="headerlink" title="如何做到线程安全"></a>如何做到线程安全</h2><p>线程安全要保证：</p><ol><li>原子性。保证一组相关操作在竞态条件下保证结果可靠。</li><li>可见性。当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li>有序性。避免指令重排序。</li></ol><p>解释一下上面三个安全特性：</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>关键词：<code>一组相关操作</code>、<code>竞态条件</code>。</p><p>先解释<code>竞态条件</code>：</p><blockquote><p>当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。</p></blockquote><p>简单的说，其本质就是基于了一个错误的状态去判断或执行计算。</p><p>上代码举例。比如一个多线程累加并打印偶数的程序。</p><h4 id="程序A："><a href="#程序A：" class="headerlink" title="程序A："></a>程序A：</h4><p>典型的竞态条件无处理:</p><pre><code class="java">public class EchoEvenNumService implements Runnable {    private int num;    @Override    public void run() {        if (num % 2 == 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.print(num + &quot;\t&quot;);        }        num++;    }}</code></pre><p>运行main程序:</p><pre><code class="java">public static void main(String[] args) {    EchoEvenNumService service = new EchoEvenNumService();    for (int i = 0; i &lt; 100; i++) {        new Thread(service).start();    }}</code></pre><p>结果是可想而知的，奇数偶数都有：</p><pre><code>0    1    1    2    4    3    2    1    1    9    9    10    9    9    9    9    10    9    18    18    18    20    21    22    20    20    19 ...</code></pre><h4 id="程序B"><a href="#程序B" class="headerlink" title="程序B"></a>程序B</h4><p>有些同学会觉得，num改成线程安全的类型(<code>AtomicInteger</code>)就可以了，可是事实是这样吗？修改程序A:</p><pre><code class="java">public class EchoEvenNumService implements Runnable {    private AtomicInteger num = new AtomicInteger(0);    @Override    public void run() {        if (num.get() % 2 == 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.print(num.get() + &quot;\t&quot;);        }        num.incrementAndGet();    }}</code></pre><p>运行main方法后，你会发现还是奇数偶数都有：</p><pre><code>0    0    2    3    4    5    5    5    5    7    9    6    6    13    14    14    14    15    18    14    17    20    20    17    21    25    25    26    28    28    29    30 ...</code></pre><p>这么写是因为没有理解<code>一组相关操作</code>。在上面的程序中，实际上需要做到三个操作：1.num.get() % 2 == 0判断。2.打印偶数。3.num递增。</p><p>即时上面三个操作各做各的做到了原子性，但是整体并不是原子性，程序依旧会错误。</p><h4 id="程序C"><a href="#程序C" class="headerlink" title="程序C"></a>程序C</h4><p>做到整体的原子性，加锁同步。修改程序A：</p><pre><code class="java">public class EchoEvenNumService implements Runnable {    private int num;    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() {        try {            lock.lock();            if (num % 2 == 0) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.print(num + &quot;\t&quot;);            }            num++;        } finally {            lock.unlock();        }    }}</code></pre><p>运行main方法后，程序终于保证了正确性:</p><pre><code>0    2    4    6    8    10    12    14    16    18    20    22    24    26    28    30    32    34    36    38    40    42    44    46    48    50    52    54    56    58    60    62    64    66    68    70    72    74    76    78    80    82    84    86    88    90    92    94    96    98    </code></pre><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>保证共享变量有效。<br>这里需要简单提一下Java的内存模型:<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1ft3q0csqw0j20jn0fudgv.jpg" alt=""></p><p>看图说话:  </p><ul><li>主内存(Main Memory),存储所有变量。</li><li>工作内存(Working Memory),保存了该线程使用到的变量的主存副本拷贝。</li><li>线程、工作内存、主存三者关系：线程对变量的所有操作(读写等)都必须在工作内存中进行，而不能之间读写主内存中的变量。</li></ul><p>如此可见，如果程序没有保证可见性，会使一部分线程读取到的是工作内存中的值(并不一定准确)，导致程序不正确执行。</p><p>如何保证可见性？手段：加锁，volatile修饰。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>解释下“重排序”现象：</p><blockquote><p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。</p></blockquote><p>比如赋值两个变量:</p><pre><code class="java">private int a;private int b;</code></pre><p>线程A对a,b进行赋值,代码中的逻辑是这样的:</p><pre><code class="java">a = 1;b = 2;</code></pre><p>线程A在运行时，对a变量赋值发现a变量在主存中被其他线程加锁不能访问，线程A并不会等待锁释放，它会去尝试获取b变量，当b变量没有被占用时，线程A的执行过程就会变成这样:</p><pre><code class="java">b = 2;a = 1;</code></pre><p>这就是JVM内部优化导致的“指令重排序”。</p><p>重排序可能导致一些重要的状态值的读取顺序改变导致程序异常甚至会死循环发生OOM。</p><p>比如如下程序：</p><pre><code class="java">public class NoVisibility {    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread {        public void run() {            while (!ready)                Thread.yield();            System.out.println(number);        }    }    public static void main(String[] args) {        new ReaderThread().start();        number = 42;        ready = true;    }}</code></pre><p>这个程序的诡异之处在于，ReaderThread可能永远看不到ready值，更诡异的是ReaderThread的输出可能是0，ReaderThread只读到了ready的值但没有读到number值。这一切“归功于”神奇的“重排序”。</p><p>解决方式:同步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文java并发修行的第一篇，重在基础。本文简单讲解了线程安全的“定义”，以及线程安全的一些基础概念。核心在于线程并发处理共享变量时的三点保证：<code>原子性</code>，<code>可见性</code>，<code>有序性</code>。细细体会之，后续准备从源码层面详细对这三点进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在互联网应用广泛的今天，软件并发已经成为目前软件开发的必备基础。java作为一门成熟的语言，其拥有着极其高效的并发机制，是目前大中型企业的常用开发语言。想要开发大规模应用，java并发已成为java程序猿们的必备基础技能。&lt;/p&gt;
&lt;p&gt;从今天开始，开启java并发修行之路。&lt;/p&gt;
    
    </summary>
    
      <category term="java并发修行" scheme="http://www.chenruiwen.cn/categories/java%E5%B9%B6%E5%8F%91%E4%BF%AE%E8%A1%8C/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
      <category term="java concurrency" scheme="http://www.chenruiwen.cn/tags/java-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>从一份配置清单详解Nginx服务器配置</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbed001juifnzpywwr2t/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbed001juifnzpywwr2t/</id>
    <published>2018-07-03T23:46:12.000Z</published>
    <updated>2018-07-03T23:48:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是现在企业上用的比较多的高性能的HTTP和反向代理服务器。入门Nginx一定少不了学习它的配置文件。本文将比较详细的介绍一下Nginx的各个配置项。</p><p>本文转载自<a href="https://my.oschina.net/hansonwang99" target="_blank" rel="noopener">CodeSheep</a>的技术博文。</p><p>原文地址:<a href="https://my.oschina.net/hansonwang99/blog/1835408" target="_blank" rel="noopener">https://my.oschina.net/hansonwang99/blog/1835408</a></p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在前面<a href="https://www.jianshu.com/p/dc61f1789f47" target="_blank" rel="noopener">《Nginx服务器开箱体验》</a> 一文中我们从开箱到体验，感受了一下Nginx服务器的魅力。Nginx是轻量级的高性能Web服务器，提供了诸如HTTP代理和反向代理、负载均衡、缓存等一系列重要特性，因而在实践之中使用广泛，笔者也在学习和实践之中。</p><p>在本文中，我们继续延续前文，从前文给出的一份示例配置清单开始，详解一下Nginx服务器的各种配置指令的作用和用法。</p><p>看到了下文中的包含了 <strong>“小猪佩琪色”</strong> 的配图了吗，嘿嘿，我们开始吧！</p><h2 id="Nginx配置文件的整体结构"><a href="#Nginx配置文件的整体结构" class="headerlink" title="Nginx配置文件的整体结构"></a>Nginx配置文件的整体结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/9824247-6f7a9706b9f3982b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图中可以看出主要包含以下几大部分内容：</p><h4 id="1-全局块"><a href="#1-全局块" class="headerlink" title="1. 全局块"></a>1. 全局块</h4><p>该部分配置主要影响Nginx全局，通常包括下面几个部分：</p><ul><li>配置运行Nginx服务器用户（组）</li><li>worker process数</li><li>Nginx进程PID存放路径</li><li>错误日志的存放路径</li><li>配置文件的引入</li></ul><h4 id="2-events块"><a href="#2-events块" class="headerlink" title="2. events块"></a>2. events块</h4><p>该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：</p><ul><li>设置网络连接的序列化</li><li>是否允许同时接收多个网络连接</li><li>事件驱动模型的选择</li><li>最大连接数的配置</li></ul><h4 id="3-http块"><a href="#3-http块" class="headerlink" title="3. http块"></a>3. http块</h4><ul><li>定义MIMI-Type</li><li>自定义服务日志</li><li>允许sendfile方式传输文件</li><li>连接超时时间</li><li>单连接请求数上限</li></ul><h4 id="4-server块"><a href="#4-server块" class="headerlink" title="4. server块"></a>4. server块</h4><ul><li>配置网络监听</li><li>于名称的虚拟主机配置</li><li>基于IP的虚拟主机配置</li></ul><h4 id="5-location块"><a href="#5-location块" class="headerlink" title="5. location块"></a>5. location块</h4><ul><li>location配置</li><li>请求根目录配置</li><li>更改location的URI</li><li>网站默认首页配置</li></ul><h2 id="一份配置清单例析"><a href="#一份配置清单例析" class="headerlink" title="一份配置清单例析"></a>一份配置清单例析</h2><p>笔者按照文章：<a href="https://www.jianshu.com/p/dc61f1789f47" target="_blank" rel="noopener">《Nginx服务器开箱体验》</a> 中的实验，给出了一份简要的清单配置举例：<br><img src="https://upload-images.jianshu.io/upload_images/9824247-2d04bfc0dfe6fa6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>配置代码如下：</p><pre><code class="java">user  nobody  nobody;worker_processes  3;error_log  logs/error.log;pid  logs/nginx.pid;events {    use epoll;    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  logs/access.log  main;    sendfile  on;    keepalive_timeout  65;    server {        listen       8088;        server_name  codesheep;        access_log  /codesheep/webserver/server1/log/access.log;        error_page  404  /404.html;        location /server1/location1 {            root   /codesheep/webserver;            index  index.server2-location1.htm;        }        location /server1/location2 {        root   /codesheep/webserver;            index  index.server2-location2.htm;        }    }    server {        listen       8089;        server_name  192.168.31.177;        access_log  /codesheep/webserver/server2/log/access.log;        error_page  404  /404.html;        location /server2/location1 {            root   /codesheep/webserver;            index  index.server2-location1.htm;        }        location /srv2/loc2 {            alias   /codesheep/webserver/server2/location2/;            index  index.server2-location2.htm;        }        location = /404.html {            root /codesheep/webserver/;            index 404.html;        }    }}</code></pre><p>接下来就来详细剖析以下配置文件中各个指令的含义⬇️</p><h2 id="配置文件指令"><a href="#配置文件指令" class="headerlink" title="配置文件指令"></a>配置文件指令</h2><h4 id="配置运行Nginx服务器用户（组）"><a href="#配置运行Nginx服务器用户（组）" class="headerlink" title="配置运行Nginx服务器用户（组）"></a>配置运行Nginx服务器用户（组）</h4><p>指令格式:<code>user user [group];</code></p><ul><li>user：指定可以运行Nginx服务器的用户</li><li>group：可选项，可以运行Nginx服务器的用户组</li></ul><p>如果user指令不配置或者配置为 user nobody nobody ，则默认所有用户都可以启动Nginx进程</p><h4 id="worker-process数配置"><a href="#worker-process数配置" class="headerlink" title="worker process数配置"></a>worker process数配置</h4><p>Nginx服务器实现并发处理服务的关键，指令格式：<code>worker_processes number | auto;</code></p><ul><li>number：Nginx进程最多可以产生的worker process数</li><li>auto：Nginx进程将自动检测</li></ul><p>按照上文中的配置清单的实验，我们给worker_processes配置的数目是：3，启动Nginx服务器后，我们可以后台看一下主机上的Nginx进程情况：</p><pre><code>ps -aux | grep nginx</code></pre><p>很明显，理解 worker_processes 这个指令的含义就很容易了<br><img src="https://upload-images.jianshu.io/upload_images/9824247-b39d1a874d9bb50a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="Nginx进程PID存放路径"><a href="#Nginx进程PID存放路径" class="headerlink" title="Nginx进程PID存放路径"></a>Nginx进程PID存放路径</h4><p>Nginx进程是作为系统守护进程在运行，需要在某文件中保存当前运行程序的主进程号，Nginx支持该保存文件路径的自定义</p><p>指令格式：<code>pid file;</code></p><ul><li>file：指定存放路径和文件名称</li><li>如果不指定默认置于路径 logs/nginx.pid</li></ul><h4 id="错误日志的存放路径"><a href="#错误日志的存放路径" class="headerlink" title="错误日志的存放路径"></a>错误日志的存放路径</h4><p>指定格式：<code>error_log file | stderr;</code></p><ul><li>file：日志输出到某个文件file</li><li>stderr：日志输出到标准错误输出</li></ul><h4 id="配置文件的引入"><a href="#配置文件的引入" class="headerlink" title="配置文件的引入"></a>配置文件的引入</h4><p>指令格式：<code>include file;</code></p><ul><li>该指令主要用于将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中</li></ul><h4 id="设置网络连接的序列化"><a href="#设置网络连接的序列化" class="headerlink" title="设置网络连接的序列化"></a>设置网络连接的序列化</h4><p>指令格式：<code>accept_mutex on | off;</code></p><ul><li>该指令默认为on状态，表示会对多个Nginx进程接收连接进行序列化，防止多个进程对连接的争抢。</li></ul><p>说到该指令，首先得阐述一下什么是所谓的 “惊群问题”，可以参考 WIKI百科的解释。就Nginx的场景来解释的话大致的意思就是：当一个新网络连接来到时，多个worker进程会被同时唤醒，但仅仅只有一个进程可以真正获得连接并处理之。如果每次唤醒的进程数目过多的话，其实是会影响一部分性能的。</p><p>所以在这里，如果accept_mutex on，那么多个worker将是以串行方式来处理，其中有一个worker会被唤醒；反之若accept_mutex off，那么所有的worker都会被唤醒，不过只有一个worker能获取新连接，其它的worker会重新进入休眠状态</p><p>这个值的开关与否其实是要和具体场景挂钩的。</p><h4 id="是否允许同时接收多个网络连接"><a href="#是否允许同时接收多个网络连接" class="headerlink" title="是否允许同时接收多个网络连接"></a>是否允许同时接收多个网络连接</h4><p>指令格式：<code>multi_accept on | off;</code></p><ul><li>该指令默认为off状态，意指每个worker process 一次只能接收一个新到达的网络连接。若想让每个Nginx的worker process都有能力同时接收多个网络连接，则需要开启此配置</li></ul><h4 id="事件驱动模型的选择"><a href="#事件驱动模型的选择" class="headerlink" title="事件驱动模型的选择"></a>事件驱动模型的选择</h4><p>指令格式：<code>use model;</code></p><p>model模型可选择项包括：select、poll、kqueue、epoll、rtsig等……</p><h4 id="最大连接数的配置"><a href="#最大连接数的配置" class="headerlink" title="最大连接数的配置"></a>最大连接数的配置</h4><p>指令格式：<code>worker_connections number;</code></p><ul><li>number默认值为512，表示允许每一个worker process可以同时开启的最大连接数</li></ul><h4 id="定义MIME-Type"><a href="#定义MIME-Type" class="headerlink" title="定义MIME-Type"></a>定义MIME-Type</h4><p>指令格式：</p><pre><code>include mime.types;default_type mime-type;</code></pre><ul><li><p>MIME-Type指的是网络资源的媒体类型，也即前端请求的资源类型</p></li><li><p>include指令将mime.types文件包含进来</p></li></ul><p><code>cat mime.types</code> 来查看mime.types文件内容，我们发现其就是一个types结构，里面包含了各种浏览器能够识别的MIME类型以及对应类型的文件后缀名字，如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/9824247-641526cfc902854c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a>自定义服务日志</h4><p>指令格式：<code>access_log path [format];</code></p><ul><li><p>path：自定义服务日志的路径 + 名称</p></li><li><p>format：可选项，自定义服务日志的字符串格式。其也可以使用 log_format 定义的格式</p></li></ul><h4 id="允许sendfile方式传输文件"><a href="#允许sendfile方式传输文件" class="headerlink" title="允许sendfile方式传输文件"></a>允许sendfile方式传输文件</h4><p>指令格式：</p><pre><code>sendfile on | off;sendfile_max_chunk size;</code></pre><ul><li>前者用于开启或关闭使用sendfile()传输文件，默认off</li><li>后者指令若size&gt;0，则Nginx进程的每个worker process每次调用sendfile()传输的数据了最大不能超出此值；若size=0则表示不限制。默认值为0</li></ul><h4 id="连接超时时间配置"><a href="#连接超时时间配置" class="headerlink" title="连接超时时间配置"></a>连接超时时间配置</h4><p>指令格式：<code>keepalive_timeout timeout [header_timeout];</code></p><ul><li><p>timeout 表示server端对连接的保持时间，默认75秒</p></li><li><p>header_timeout 为可选项，表示在应答报文头部的 Keep-Alive 域设置超时时间：“Keep-Alive : timeout = header_timeout”</p></li></ul><h4 id="单连接请求数上限"><a href="#单连接请求数上限" class="headerlink" title="单连接请求数上限"></a>单连接请求数上限</h4><p>指令格式：<code>keepalive_requests number;</code></p><ul><li>该指令用于限制用户通过某一个连接向Nginx服务器发起请求的次数</li></ul><h4 id="配置网络监听"><a href="#配置网络监听" class="headerlink" title="配置网络监听"></a>配置网络监听</h4><p>指令格式：</p><ul><li><p>第一种：配置监听的IP地址：<code>listen IP[:PORT];</code></p></li><li><p>第二种：配置监听的端口：<code>listen PORT;</code></p></li></ul><h4 id="基于名称和IP的虚拟主机配置"><a href="#基于名称和IP的虚拟主机配置" class="headerlink" title="基于名称和IP的虚拟主机配置"></a>基于名称和IP的虚拟主机配置</h4><p>指令格式：<code>server_name name1 name2 ...</code></p><p>name可以有多个并列名称，而且此处的name支持正则表达式书写<br>实际举例：</p><pre><code>server_name ~^www\d+\.myserver\.com$</code></pre><p>此时表示该虚拟主机可以接收类似域名 www1.myserver.com 等的请求而拒绝 <a href="http://www.myserver.com" target="_blank" rel="noopener">www.myserver.com</a> 的域名请求，所以说用正则表达式可以实现更精准的控制。</p><p>至于基于IP的虚拟主机配置比较简单，不再太赘述：</p><p>指令格式：<code>server_name IP地址</code></p><h4 id="location配置"><a href="#location配置" class="headerlink" title="location配置"></a>location配置</h4><p>指令格式为：<code>location [ = | ~ | ~* | ^~ ] uri {...}</code></p><p>这里的uri分为标准uri和正则uri，两者的唯一区别是uri中是否包含正则表达式<br>uri前面的方括号中的内容是可选项，解释如下：</p><ul><li><p>“=”：用于标准uri前，要求请求字符串与uri严格匹配，一旦匹配成功则停止</p></li><li><p>“~”：用于正则uri前，并且区分大小写</p></li><li><p>“~*”：用于正则uri前，但不区分大小写</p></li><li><p>“^~”：用于标准uri前，要求Nginx找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配</p></li></ul><h4 id="请求根目录配置"><a href="#请求根目录配置" class="headerlink" title="请求根目录配置"></a>请求根目录配置</h4><p>指令格式：<code>root path;</code></p><ul><li>path：Nginx接收到请求以后查找资源的根目录路径<br>当然，还可以通过alias指令来更改location接收到的URI请求路径，指令为：</li></ul><h4 id="设置网站的默认首页"><a href="#设置网站的默认首页" class="headerlink" title="设置网站的默认首页"></a>设置网站的默认首页</h4><p>指令格式：<code>index file ......</code></p><ul><li>file可以包含多个用空格隔开的文件名，首先找到哪个页面，就使用哪个页面响应请求</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>非常感谢<a href="https://my.oschina.net/hansonwang99" target="_blank" rel="noopener">CodeSheep</a>的的分享！</p><p>通过本文并结合官方文档，并加以加以使用，多多去体验Nginx的神奇吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx是现在企业上用的比较多的高性能的HTTP和反向代理服务器。入门Nginx一定少不了学习它的配置文件。本文将比较详细的介绍一下Nginx的各个配置项。&lt;/p&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://my.oschina.net/hansonwang99&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeSheep&lt;/a&gt;的技术博文。&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://my.oschina.net/hansonwang99/blog/1835408&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/hansonwang99/blog/1835408&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.chenruiwen.cn/categories/nginx/"/>
    
    
      <category term="转载摘抄" scheme="http://www.chenruiwen.cn/tags/%E8%BD%AC%E8%BD%BD%E6%91%98%E6%8A%84/"/>
    
      <category term="nginx" scheme="http://www.chenruiwen.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展机制实现(三)之扩展点特性</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdh0002uifnjkuxb445/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdh0002uifnjkuxb445/</id>
    <published>2018-06-25T14:22:22.000Z</published>
    <updated>2018-07-21T10:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgrfhmr62j20jk0bfjrz.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇简单分析了Dubbo的扩展点机制的实现，以及其与java spi的区别与改进。</p><p>本篇文章准备从扩展点特性的角度分析一下源码。</p><a id="more"></a><h2 id="扩展点自动装配"><a href="#扩展点自动装配" class="headerlink" title="扩展点自动装配"></a>扩展点自动装配</h2><blockquote><p>加载扩展点时，自动注入依赖的扩展点。加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，ExtensionLoader 在会自动注入依赖的扩展点。ExtensionLoader 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 ExtensionLoader 会执行扩展点的拼装操作。</p></blockquote><p>上一篇提到了Dubbo的ExtensionLoader提供了三种获取扩展点实现类的方式，其中的一种是根据名字获取扩展点实现:</p><pre><code class="java">public T getExtension(String name) {    if (name == null || name.length() == 0)        throw new IllegalArgumentException(&quot;Extension name == null&quot;);    if (&quot;true&quot;.equals(name)) { // 判断是否是获取默认实现        return getDefaultExtension();    }    Holder&lt;Object&gt; holder = cachedInstances.get(name); // 从缓存中取    if (holder == null) {        cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;());        holder = cachedInstances.get(name);    }    Object instance = holder.get();    if (instance == null) {        synchronized (holder) {            instance = holder.get();            if (instance == null) {                instance = createExtension(name); // 创建缓存实例                holder.set(instance);            }        }    }    return (T) instance;}</code></pre><p>还是用到了缓存，先是判断是否取默认实例，再是从缓存取和设置缓存。接下来看一下创建扩展点的方法<code>createExtension(name)</code>:</p><pre><code class="java">private T createExtension(String name) {    Class&lt;?&gt; clazz = getExtensionClasses().get(name); // 加载当前Extension的所有实现, 并从中获取指定name的Extension    if (clazz == null) {        throw findException(name);    }    try {        T instance = (T) EXTENSION_INSTANCES.get(clazz); // 从Extension实例缓存中获取实例        if (instance == null) {            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());            instance = (T) EXTENSION_INSTANCES.get(clazz);        }        injectExtension(instance); // 注入扩展点信息        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;        if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {            for (Class&lt;?&gt; wrapperClass : wrapperClasses) {                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));            }        }        return instance;    } catch (Throwable t) {        throw new IllegalStateException(&quot;Extension instance(name: &quot; + name + &quot;, class: &quot; +                type + &quot;)  could not be instantiated: &quot; + t.getMessage(), t);    }}</code></pre><p>如上代码所示，<code>createExtension(name)</code>创建一个扩展点实例大致做了两件事：</p><ul><li>调用<code>getExtensionClasses()</code>加载了扩展点类，并通过名字获取到扩展点的Class类对象</li><li>创建扩展点的Class类对象的实例，并调用<code>injectExtension(instance)</code> 注入扩展点信息</li></ul><ol><li><code>getExtensionClasses()</code>暂且不说，比较重要的一个方法，在获取自适应扩展点的时候也会用到此方法。</li><li><code>injectExtension(instance)</code> 注入扩展点信息，这里便展示了扩展点自动装配的特性。<pre><code class="java">private T injectExtension(T instance) { try {     if (objectFactory != null) {         for (Method method : instance.getClass().getMethods()) {             // 处理所有set方法             if (method.getName().startsWith(&quot;set&quot;)                     &amp;&amp; method.getParameterTypes().length == 1                     &amp;&amp; Modifier.isPublic(method.getModifiers())) {                 Class&lt;?&gt; pt = method.getParameterTypes()[0];                 try {                     // 获取setter对应的property名称                     String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;                     // 根据参数类型和属性名称，从 ExtensionFactory 里获取扩展点                     Object object = objectFactory.getExtension(pt, property);                     if (object != null) { // 如果不为空，则 setter 方法的参数是扩展点类型，那么进行注入                         method.invoke(instance, object);                     }                 } catch (Exception e) {                     logger.error(&quot;fail to inject via method &quot; + method.getName()                             + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);                 }             }         }     } } catch (Exception e) {     logger.error(e.getMessage(), e); } return instance;}</code></pre>这里可以看到，扩展点自动注入就是根据<code>setter</code>方法对应的参数类型和property名称从<code>ExtensionFactory</code>中查询，如果有返回扩展点实例，那么就进行注入操作。</li></ol><h2 id="扩展点自适应"><a href="#扩展点自适应" class="headerlink" title="扩展点自适应"></a>扩展点自适应</h2><p>Dubbo扩展点有一个非常重要的概念：<code>Adaptive</code>.</p><blockquote><p><code>ExtensionLoader</code> 注入的依赖扩展点是一个 <code>Adaptive</code> 实例，直到扩展点方法执行时才决定调用是一个扩展点实现。</p><p>Dubbo 使用 URL 对象（包含了Key-Value）传递配置信息。</p><p>扩展点方法调用会有URL参数（或是参数有URL成员）</p><p>这样依赖的扩展点也可以从URL拿到配置信息，所有的扩展点自己定好配置的Key后，配置信息从URL上从最外层传入。URL在配置传递上即是一条总线。</p></blockquote><p>来看看Dubbo获取自适应扩展点的方法:<code>getAdaptiveExtension()</code>:</p><pre><code class="java">public T getAdaptiveExtension() {    Object instance = cachedAdaptiveInstance.get(); // 从缓存中获取自适应实例    if (instance == null) {        if (createAdaptiveInstanceError == null) {            synchronized (cachedAdaptiveInstance) {                instance = cachedAdaptiveInstance.get();                if (instance == null) {                    try {                        instance = createAdaptiveExtension(); // 创建自适应实例并缓存                        cachedAdaptiveInstance.set(instance);                    } catch (Throwable t) {                        createAdaptiveInstanceError = t;                        throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + t.toString(), t);                    }                }            }        } else {            throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);        }    }    return (T) instance;}</code></pre><p>又是缓存，看看如何创建一个自适应扩展点:<code>createAdaptiveExtension()</code></p><pre><code class="java">private T createAdaptiveExtension() {    try {        return injectExtension((T) getAdaptiveExtensionClass().newInstance());    } catch (Exception e) {        throw new IllegalStateException(&quot;Can not create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);    }}</code></pre><p><code>injectExtension(instance)</code>方法上面说明过了，是对扩展点自动装配。主要看<code>getAdaptiveExtensionClass()</code>方法：</p><pre><code>private Class&lt;?&gt; getAdaptiveExtensionClass() {    getExtensionClasses(); // 加载当前Extension的所有实现    if (cachedAdaptiveClass != null) {        return cachedAdaptiveClass;    }    return cachedAdaptiveClass = createAdaptiveExtensionClass(); // 动态创建自适应扩展类 Class 对象}</code></pre><p><code>getExtensionClasses()</code>是个很重要的方法，三种获取扩展点实现的方法都会用到这个方法，这个稍后说明一下。这里主要看<code>createAdaptiveExtensionClass()</code>:</p><pre><code class="java">private Class&lt;?&gt; createAdaptiveExtensionClass() {    String code = createAdaptiveExtensionClassCode(); // 自适应扩展类拼装代码    ClassLoader classLoader = findClassLoader();    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();    return compiler.compile(code, classLoader); // 动态编译}</code></pre><p>这里也是获取了<code>Compiler</code>接口的自适应扩展点<code>AdaptiveCompiler</code>的实现，由于实现里又<code>compiler = loader.getDefaultExtension()</code>获取了默认的扩展点，即<code>JavassistCompiler</code>的实例，来实现了动态编译。通过断点看一下通过 javassist 生成的实现类长啥样，以<code>Protocol</code>的自适应扩展点来看(debug打印后格式化并做了注释方便看):</p><pre><code class="java">package com.alibaba.dubbo.rpc;import com.alibaba.dubbo.common.extension.ExtensionLoader;public class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {    public void destroy() {        throw new UnsupportedOperationException(&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);    }    public int getDefaultPort() {        throw new UnsupportedOperationException(&quot;method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);    }    public com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {        if (arg0 == null)             throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument == null&quot;);        if (arg0.getUrl() == null)             throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&quot;);com.alibaba.dubbo.common.URL url = arg0.getUrl();        // 从url中获取扩展点名称,如果没有就赋值为默认的值        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );        if(extName == null)             throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);        // 通过名字获取扩展点实现        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);        return extension.export(arg0);    }    public com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {        if (arg1 == null)             throw new IllegalArgumentException(&quot;url == null&quot;);        com.alibaba.dubbo.common.URL url = arg1;        // 从url中获取扩展点名称,如果没有就赋值为默认的值        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );        if(extName == null)             throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);        // 通过名字获取扩展点实现        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);        return extension.refer(arg0, arg1);    }}</code></pre><p>从上可以看到，确实正如Dubbo所描述的那样，通过url传递配置信息。</p><h2 id="扩展点自动包装"><a href="#扩展点自动包装" class="headerlink" title="扩展点自动包装"></a>扩展点自动包装</h2><p>在官方文档中有如下说明：</p><blockquote><p>自动包装扩展点的 Wrapper 类。<code>ExtensionLoader</code> 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。</p></blockquote><p>在源码里的体现，在加载扩展点文件 <code>loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</code> 里会根据构造器函数进行判断是否是 Wrapper类：</p><pre><code class="java">try {    clazz.getConstructor(type); // 判断是否 Wrapper 类型    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;    if (wrappers == null) {        cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();        wrappers = cachedWrapperClasses;    }    wrappers.add(clazz);} catch (NoSuchMethodException e) { // 非 Wrapper 类型    ...}</code></pre><p>其次在创建扩展点实例的时候也会根据是否是 Wrapper 类来创建相应的扩展点，这在<code>createExtension(String name)</code>中的体现:</p><pre><code class="java">Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; // 获取缓存的Wrapper类集合// 如果是包装类则创建包装类扩展点实例if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {    for (Class&lt;?&gt; wrapperClass : wrapperClasses) {        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));    }}return instance;</code></pre><p>那么，为什么要使用 Wrapper 类呢？</p><blockquote><p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 <code>ExtensionLoader</code>返回扩展点时，包装在真正的扩展点实现外。即从 <code>ExtensionLoader</code> 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。</p><p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。</p><p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。</p></blockquote><p>从这里看 Dubbo 的<code>aop</code>实际上是装饰者设计模式 + 自适应特性的动态代理。</p><p>举个例子，在之前写Dubbo暴露过程的源码中对<code>Protocol</code>接口的调用过程进行了分析，在<code>ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>获取Protocol自适应扩展点的时序是<code>ProtocolListenerWrapper</code>-&gt;<code>ProtocolFilterWrapper</code>-&gt;<code>DubboProtocol</code>。<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fsl2mpd7q6j21cs0gm79z.jpg" alt=""></p><p>在真正暴露服务之前，对此进行了一些额外的扩展操作，通过这些层层包装使得各个类逻辑分明，代码维护性高。</p><h2 id="扩展点自动激活"><a href="#扩展点自动激活" class="headerlink" title="扩展点自动激活"></a>扩展点自动激活</h2><p>先看官方文档：</p><blockquote><p>对于集合类扩展点，比如：Filter, InvokerListener, ExportListener, TelnetHandler, StatusChecker 等，可以同时加载多个实现，此时，可以用自动激活来简化配置。</p></blockquote><p>Dubbo实现自动激活的核心关键词:<code>Activate</code>。</p><pre><code class="java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD})public @interface Activate {    /**     * 根据group匹配当前扩展点     *     * @return 匹配的group名称     */    String[] group() default {};    /**     * 当URL上的参数包含指定的keys时，激活当前的扩展点     * &lt;p&gt;     * 举个栗子, 当使用 &lt;code&gt;@Activate(&quot;cache, validation&quot;)&lt;/code&gt;, 当URL参数上包含&lt;code&gt;cache&lt;/code&gt; 或 &lt;code&gt;validation&lt;/code&gt; 时，当前扩展点才会被激活     * &lt;/p&gt;     *     * @return URL 参数上的key值     */    String[] value() default {};    /**     * 相对排序信息, 可选     *     * @return 应当放在当前扩展点之前的扩展点列表     */    String[] before() default {};    /**     * 相对排序信息, 可选     *     * @return 应当放在当前扩展点之前的扩展点列表     */    String[] after() default {};    /**     * 绝对排序信息, 可选     *     * @return 绝对排序信息     */    int order() default 0;}</code></pre><p>总之就是根据注解的 <code>value</code> 和 <code>group</code> 两个属性来决定是否激活。<br>比如<code>CacheFilter</code>：</p><pre><code class="java">@Activate(group = {Constants.CONSUMER, Constants.PROVIDER}, value = Constants.CACHE_KEY)public class CacheFilter implements Filter {}</code></pre><p>当满足条件:</p><ul><li>服务提供者 和 服务消费者 </li><li>url上的参数包含<code>cache</code> </li></ul><p>则激活 <code>CacheFilter</code></p><p><strong>那么，Dubbo如何使用 <code>Activate</code> 呢？</strong><br>没错，一定还记得那个方法:<code>getActivateExtension</code>。<br><code>getActivateExtension</code>有多个重写的方法，但实际最终会调用到如下：</p><pre><code class="java">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) {    List&lt;T&gt; exts = new ArrayList&lt;T&gt;();    List&lt;String&gt; names = values == null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);    if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {        getExtensionClasses(); // 此处缓存了 cachedActivates        for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) {            String name = entry.getKey(); // 获取 可激活的扩展点的spi扩展名            Activate activate = entry.getValue();            if (isMatchGroup(group, activate.group())) { // 如果group匹配                T ext = getExtension(name); // 根据扩展点名称获取扩展点实例                // name不在 values 指定的列，且没排除name，且url上有activate的value，则激活                if (!names.contains(name)                        &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)                        &amp;&amp; isActive(activate, url)) {                    exts.add(ext);                }            }        }        Collections.sort(exts, ActivateComparator.COMPARATOR); // 排序    }    List&lt;T&gt; usrs = new ArrayList&lt;T&gt;();    for (int i = 0; i &lt; names.size(); i++) { // 指定使用values的时候        String name = names.get(i);        // 所有未被排除的扩展名        if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)                &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {            if (Constants.DEFAULT_KEY.equals(name)) {                if (!usrs.isEmpty()) {                    exts.addAll(0, usrs);                    usrs.clear();                }            } else {                T ext = getExtension(name);                usrs.add(ext);            }        }    }    if (!usrs.isEmpty()) {        exts.addAll(usrs);    }    return exts;}</code></pre><p>关于<code>Activate</code>的使用场景：当需要提供一组需要指定条件的扩展点并使用的时候。比如在<code>ProtocolFilterWrapper</code>的<code>buildInvokerChain</code>里构建一组<code>Filter</code>时，Dubbo是这么处理的:</p><pre><code class="java">List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</code></pre><h2 id="扩展点的一些核心方法"><a href="#扩展点的一些核心方法" class="headerlink" title="扩展点的一些核心方法"></a>扩展点的一些核心方法</h2><p>在整个扩展点源码里，有一些核心的方法贯穿整个ExtensionLoader。</p><p>首先是之前常见得<code>getExtensionClasses()</code><br>这个方法里进行了：</p><ul><li>缓存扩展点Class</li><li>从指定文件路径加载扩展点文件</li><li>创建扩展点</li></ul><p><code>getExtensionClasses()</code>里的核心方法是<code>loadExtensionClasses</code>.</p><pre><code class="java">private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {    final SPI defaultAnnotation = type.getAnnotation(SPI.class); // 先获取 @SPI 注解中的默认值    if (defaultAnnotation != null) {        // 如果 @SPI 注解存在 value 默认值, 赋值给 cachedDefaultName 属性        String value = defaultAnnotation.value();        if (value != null &amp;&amp; (value = value.trim()).length() &gt; 0) {            String[] names = NAME_SEPARATOR.split(value);            if (names.length &gt; 1) { // 每个扩展点实现只能配置一个名字                throw new IllegalStateException(&quot;more than 1 default extension name on extension &quot; + type.getName()                        + &quot;: &quot; + Arrays.toString(names));            }            if (names.length == 1) cachedDefaultName = names[0];        }    }    // 从配置路径中加载扩展实现类    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;();    loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);    loadFile(extensionClasses, DUBBO_DIRECTORY);    loadFile(extensionClasses, SERVICES_DIRECTORY);    return extensionClasses;}</code></pre><p>真正开始加载扩展点文件的方法:<code>loadFile</code>.下面，简单粗暴的贴源码：</p><pre><code class="java">private void loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) {    String fileName = dir + type.getName(); // 获取文件路径名    try {        Enumeration&lt;java.net.URL&gt; urls;        ClassLoader classLoader = findClassLoader(); // 获取了类加载器        if (classLoader != null) {            urls = classLoader.getResources(fileName);        } else {            urls = ClassLoader.getSystemResources(fileName);        }        if (urls != null) {            while (urls.hasMoreElements()) {                java.net.URL url = urls.nextElement();                try {                    BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), &quot;utf-8&quot;)); // 也是以utf-8方式读取配置文件                    try {                        String line = null;                        while ((line = reader.readLine()) != null) { // 解析每行数据                            final int ci = line.indexOf(&#39;#&#39;);                            if (ci &gt;= 0) line = line.substring(0, ci);                            line = line.trim();                            if (line.length() &gt; 0) { // 非注释内容                                try {                                    String name = null;                                    int i = line.indexOf(&#39;=&#39;);                                    if (i &gt; 0) {                                        name = line.substring(0, i).trim(); // 配置中的 key                                        line = line.substring(i + 1).trim(); // 配置中的 value                                    }                                    if (line.length() &gt; 0) {                                        Class&lt;?&gt; clazz = Class.forName(line, true, classLoader); // 获取class对象                                        if (!type.isAssignableFrom(clazz)) {                                            throw new IllegalStateException(&quot;Error when load extension class(interface: &quot; +                                                    type + &quot;, class line: &quot; + clazz.getName() + &quot;), class &quot;                                                    + clazz.getName() + &quot;is not subtype of interface.&quot;);                                        }                                        if (clazz.isAnnotationPresent(Adaptive.class)) { // 如果注解了@Adaptive                                            if (cachedAdaptiveClass == null) {                                                cachedAdaptiveClass = clazz; // 缓存 cachedAdaptiveClass                                            } else if (!cachedAdaptiveClass.equals(clazz)) { // 只允许一个 Adaptive 实现                                                throw new IllegalStateException(&quot;More than 1 adaptive class found: &quot;                                                        + cachedAdaptiveClass.getClass().getName()                                                        + &quot;, &quot; + clazz.getClass().getName());                                            }                                        } else {                                            try {                                                clazz.getConstructor(type); // 判断是否 Wrapper 类型                                                Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;                                                if (wrappers == null) {                                                    cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();                                                    wrappers = cachedWrapperClasses;                                                }                                                wrappers.add(clazz);                                            } catch (NoSuchMethodException e) { // 非 Wrapper 类型                                                clazz.getConstructor(); // 获取class对象的无参构造器                                                if (name == null || name.length() == 0) {                                                    name = findAnnotationName(clazz);                                                    if (name == null || name.length() == 0) {                                                        if (clazz.getSimpleName().length() &gt; type.getSimpleName().length()                                                                &amp;&amp; clazz.getSimpleName().endsWith(type.getSimpleName())) {                                                            name = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();                                                        } else {                                                            throw new IllegalStateException(&quot;No such extension name for the class &quot; + clazz.getName() + &quot; in the config &quot; + url);                                                        }                                                    }                                                }                                                String[] names = NAME_SEPARATOR.split(name);                                                if (names != null &amp;&amp; names.length &gt; 0) {                                                    Activate activate = clazz.getAnnotation(Activate.class);                                                    if (activate != null) {                                                        cachedActivates.put(names[0], activate); // 缓存 cachedActivates                                                    }                                                    for (String n : names) {                                                        if (!cachedNames.containsKey(clazz)) {                                                            cachedNames.put(clazz, n); // 缓存 cachedNames ,每个class只对应一个名称                                                        }                                                        Class&lt;?&gt; c = extensionClasses.get(n);                                                        if (c == null) {                                                            extensionClasses.put(n, clazz); // 放入到extensionClasses中,多个 name 可能对应一个Class                                                        } else if (c != clazz) { // 重复抛异常                                                            throw new IllegalStateException(&quot;Duplicate extension &quot; + type.getName() + &quot; name &quot; + n + &quot; on &quot; + c.getName() + &quot; and &quot; + clazz.getName());                                                        }                                                    }                                                }                                            }                                        }                                    }                                } catch (Throwable t) {                                    IllegalStateException e = new IllegalStateException(&quot;Failed to load extension class(interface: &quot; + type + &quot;, class line: &quot; + line + &quot;) in &quot; + url + &quot;, cause: &quot; + t.getMessage(), t);                                    exceptions.put(line, e);                                }                            }                        } // end of while read lines                    } finally {                        reader.close();                    }                } catch (Throwable t) {                    logger.error(&quot;Exception when load extension class(interface: &quot; +                            type + &quot;, class file: &quot; + url + &quot;) in &quot; + url, t);                }            } // end of while urls        }    } catch (Throwable t) {        logger.error(&quot;Exception when load extension class(interface: &quot; +                type + &quot;, description file: &quot; + fileName + &quot;).&quot;, t);    }}</code></pre><p>文件加载完成后，几个实例被缓存了:</p><ul><li>cachedAdaptiveClass(自适应扩展点)</li><li>cachedWrapperClasses(扩展点包装类)</li><li>cachedActivates(扩展点激活类)</li><li>cachedNames(Class-&gt;name映射)</li></ul><p>在获取扩展点的三个方法中会常使用缓存了的数据，由此可见Dubbo在这里的缓存优化。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，扩展点机制大致介绍完毕，自己从源码中也体会了在扩展设计上原来还可以这么玩，收益匪浅了。</p><p>最后做个总结：</p><ul><li>从代码层面上对扩展点的四个特性进行了分析</li><li>三种获取扩展点的方式相互结合，分别体现了不同的扩展点特点</li><li>代码层面合理的设计模式(装饰器模式，动态代理)对代码分层解耦</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgrfhmr62j20jk0bfjrz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇简单分析了Dubbo的扩展点机制的实现，以及其与java spi的区别与改进。&lt;/p&gt;
&lt;p&gt;本篇文章准备从扩展点特性的角度分析一下源码。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA神器那些让人爱不释手的小技巧</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdp000auifn3y7likjn/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdp000auifn3y7likjn/</id>
    <published>2018-06-15T14:51:24.000Z</published>
    <updated>2018-07-21T10:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgqaxwnn9j20sf0jrdlq.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Intellij IDEA，一个开发者甚爱的IDE，用了这么多年，其中有些小Tips你真的了解吗？Intellij IDEA神器小技巧第二弹来了！</p><p>本文转载自<a href="https://blog.csdn.net/linsongbin1" target="_blank" rel="noopener">Sam哥哥聊技术</a>的技术博文。</p><p>原文地址:<a href="https://blog.csdn.net/linsongbin1/article/details/80560332" target="_blank" rel="noopener">https://blog.csdn.net/linsongbin1/article/details/80560332</a><br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在2018年5月6日写了一篇介绍IntellIJ IDEA的文章,<a href="https://blog.csdn.net/linsongbin1/article/details/80211919" target="_blank" rel="noopener">Intellij IDEA神器居然还有这些小技巧</a>,主要是列出一些平时大家可能没用过或者没怎么用，但是又非常好用的IntellIJ IDEA小技巧。由于篇幅原因，只是列出了一小部分，那么接下来的这篇文章，会继续补充一些IntellIJ IDEA的小技巧。</p><h2 id="别轻易自定义快捷键"><a href="#别轻易自定义快捷键" class="headerlink" title="别轻易自定义快捷键"></a>别轻易自定义快捷键</h2><p>有蛮多操作，IntellIJ IDEA并没有给我们设置默认快捷键，需要使用者自己去定义快捷键。比如说：</p><ul><li>Rebuild Project</li><li>Compare With Branch</li></ul><p>为了能在IntellIJ IDEA里进行<code>无鼠标编程</code>，很多程序员都会自定义快捷键，但是有三个地方你可能需要注意一下。</p><ul><li>经常会出现快捷键与其他应用的快捷键冲突的情况；</li><li>自定义太多快捷键了，你也不太好记住；</li><li>使用其他同事的IDEA时(比如说帮忙定位问题)，你自定义的快捷键没法用。</li></ul><p>其实在IntellIJ IDEA里的每个操作，都可以看出一个<code>action</code>。我们可以使用<code>ctrl+shift+a</code>来输入我们要使用的操作。比如说，上面提到的<code>Rebuild Project</code>。你可以先使用<code>ctrl+shift+a</code>快捷键，然后输入<code>Rebuild Project</code>并回车,即可执行你要的操作。 </p><p><img src="https://img-blog.csdn.net/20180603210637881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>对我自己来说，除了基础的快捷键，<code>ctrl+shift+a</code>是我用最频繁的快捷键了。</p><h2 id="使用ctrl-alt-h要小心"><a href="#使用ctrl-alt-h要小心" class="headerlink" title="使用ctrl+alt+h要小心"></a>使用ctrl+alt+h要小心</h2><p><code>ctrl+alt+h</code>非常好用,但是有个坑,当同一个方法里,调用某个方法多次的时候,比如说下面的代码：</p><pre><code class="java">public class TestService {    public void test1() {        System.out.println(&quot;aa&quot;);    }    public void test2() {        test1();    }    public void test3() {        test1();        //无数业务操作后,再次电影test1()方法        test1();    }}</code></pre><p>如果我们想知道有哪些地方调用<code>了test1()</code>方法，使用<code>ctrl+alt+h</code>无法正确列出来的。因为<code>ctrl+alt+h</code>只能告诉你调用的层次。<br><img src="https://img-blog.csdn.net/20180603213636309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><code>ctrl+alt+h</code>只是会在某个隐蔽的地方，告诉你，<code>test3()</code> 方法调用了 <code>test1()</code> 方法两次。这样就很容易坑到开发者，因为大部分人可能不太注意后面的调用次数，导致改bug的时候，以为全部都改了呢？</p><p>如果你想精确的列出到底哪些地方调用了<code>test1()</code> 方法，你需要使用<code>alt+f7</code>这个快捷键。<br><img src="https://img-blog.csdn.net/20180603214049285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>尤其是我们在阅读极其复杂的业务代码时，使用<code>alt+f7</code>就非常合适。</p><p>当然<code>alt+f7</code>也可以作用在变量上，列出某个类里，哪些地方使用了该变量。</p><h2 id="ctrl-alt-h被问的最多的两个问题"><a href="#ctrl-alt-h被问的最多的两个问题" class="headerlink" title="ctrl+alt+h被问的最多的两个问题"></a>ctrl+alt+h被问的最多的两个问题</h2><p>经常有同事和网友问我。</p><blockquote><p>Sam哥，使用ctrl+alt+h怎么跳转到源代码，又如何重新回到ctrl+alt+h对应的视图里面。</p></blockquote><h4 id="调转到源代码"><a href="#调转到源代码" class="headerlink" title="调转到源代码"></a>调转到源代码</h4><p><img src="https://img-blog.csdn.net/20180603214902253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>其实很简单，当你使用<code>ctrl+alt+h</code>后，使用向下或者向上箭头，选择某个调用，然后按下<code>f4</code>即可跳转到源代码。</p><h4 id="如何回到ctrl-alt-h视图"><a href="#如何回到ctrl-alt-h视图" class="headerlink" title="如何回到ctrl+alt+h视图"></a>如何回到ctrl+alt+h视图</h4><p>这个真心被问了好几百遍，其实很简单，当你使用<code>f4</code>跳转到源代码后，直接使用 <code>alt+8</code> 就可以跳回去了。就又可以继续看下一个调用的地方了。</p><h2 id="快速找到Controller方法"><a href="#快速找到Controller方法" class="headerlink" title="快速找到Controller方法"></a>快速找到Controller方法</h2><p>如果你的项目里有非常多的 controller，里面有非常多的 http 或者 resful 方法。如何快速找到这些方法呢？这个时候，<code>ctrl+alt+shift+n</code> 就可以派上用场了。</p><p>比如说，你依稀记得入账单相关的接口，都有个bill的url路径，那么使用 <code>ctrl+alt+shift+n</code> 后，直接输入/bill即可。</p><p><img src="https://img-blog.csdn.net/20180603215950916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>当你在成千上万的Controller里寻找方法时，这一招就可以大大提高效率。</p><h2 id="了解项目关键业务流程方法的利器-bookmark"><a href="#了解项目关键业务流程方法的利器-bookmark" class="headerlink" title="了解项目关键业务流程方法的利器-bookmark"></a>了解项目关键业务流程方法的利器-bookmark</h2><p>在一些创业公司里，很多核心的模块都是放置在同一个项目里的。比如说，订单相关的接口，支付相关的接口，商品相关的接口。这个时候，你可以将这些关键业务方法，使用 <code>bookmark</code> 统一放置到某个地方，方便你阅读。</p><p>那么如何使用快捷键来达到上面的效果呢？</p><pre><code class="java">public class TestService {    public void test1() {        System.out.println(&quot;aa&quot;);    }    public void test2() {        test1();    }    public void test3() {        test1();        test1();    }}</code></pre><p>比如像上面的方法，我想将test1()方法放置到bookmark里，可以通过如下操作来完成：  </p><ol><li>使用 <code>ctrl+f12</code> ,列出该类的所有方法，然后输入 <code>test1</code>，将光标定位在 <code>test1</code> 上； </li><li>按下 <code>f11</code> ,将 <code>test1()</code> 加入到 <code>bookmark</code>； </li><li>按下 <code>shift+f11</code>，将 <code>bookmark</code> 列表弹出来; </li><li>按下 <code>ctrl+enter</code> 修改 <code>bookmark</code> 名字。</li></ol><h2 id="只留下一个tab"><a href="#只留下一个tab" class="headerlink" title="只留下一个tab"></a>只留下一个tab</h2><p>这个是我目前正在用的，就是整个工程里面，只有一个代码 tab。也即是说，无论你打开多少个文件，都是在同一个tab里面显示。如果这样设置了，有些网友可能会问,我想看看我最近操作哪些类了，怎么看？ 可以直接使用 <code>ctrl+e</code> 来显示最近操作的文件。</p><p>我是比较推荐只是保留一个代码tab的，非常简洁。如果每打开一个文件，就是一个新的tab，很快你就会乱掉，而且还得关闭部分tab。</p><p>可以通过下面的方式来设置成用一个tab显示代码。按下 <code>ctrl+shif+a</code> ,然后输入<code>Editor Tabs</code>，然后回车进入编辑页面。</p><p><img src="https://img-blog.csdn.net/2018060409555189?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>然后在 <code>Placement</code> 那里,选择 <code>None</code></p><p><img src="https://img-blog.csdn.net/20180604095643156?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="如何阅读又长又臭的代码"><a href="#如何阅读又长又臭的代码" class="headerlink" title="如何阅读又长又臭的代码"></a>如何阅读又长又臭的代码</h2><p>由于历史原因，项目里总会存在那种无法理解的，又长又臭的业务代码。阅读这种代码，简直就是一种煎熬。但是 在IntellIJ IDEA 里，只要使用 5 个小技巧，便可大大提高阅读质量和速度。</p><h4 id="创建任意代码折叠块"><a href="#创建任意代码折叠块" class="headerlink" title="创建任意代码折叠块"></a>创建任意代码折叠块</h4><p><img src="https://img-blog.csdn.net/20180603222021678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>像上面的for循环，我想直接将其折叠起来，因为代码太长的时候，使用折叠块，可以帮助你快速理清代码的主脉络。</p><p>可以将光标定位在for循环的左大括号里，然后使用 <code>ctrl+shift+.</code> 即可。 </p><p><img src="https://img-blog.csdn.net/20180603222256258?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果你想让这个折叠快消失，直接使用ctrl 加上一个+即可。</p><h4 id="大括号匹配"><a href="#大括号匹配" class="headerlink" title="大括号匹配"></a>大括号匹配</h4><p>这个也非常有用，因为代码太长，某个for循环，可能已经撑满整个屏幕了。这个时候，找到某个大括号对应的另外一边就很费劲。你可以将光标定位在某个大括号一边，然后使用 <code>ctrl+]</code> 或者 <code>ctrl+[</code> 来回定位即可。</p><h4 id="ctrl-shift-f7结合f3"><a href="#ctrl-shift-f7结合f3" class="headerlink" title="ctrl+shift+f7结合f3"></a>ctrl+shift+f7结合f3</h4><p><code>ctrl+shift+f7</code> 可以高亮某个变量，而且随着鼠标的移动，这个高亮是不会消失的(这个很重要)。然后使用f3找到下一个使用该变量的地方。</p><p><img src="https://img-blog.csdn.net/20180603223703369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>在这个代码块里，你想看看 TestTemp 类的定义，那么将光标定位在 TestTemp 上，然后直接使用 <code>ctrl+shift+i</code>，就会弹出如下的窗口。 </p><p><img src="https://img-blog.csdn.net/20180603223758137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>按下 <code>esc</code>，可以关闭这个窗口。</p><h4 id="使用alt-f7"><a href="#使用alt-f7" class="headerlink" title="使用alt+f7"></a>使用alt+f7</h4><p>这个我在上面已经介绍过了。可以列出变量在哪些地方被使用了。</p><p>结合这5个技巧，相信可以大大提高长段代码的阅读效率。</p><h2 id="跳到父类接口"><a href="#跳到父类接口" class="headerlink" title="跳到父类接口"></a>跳到父类接口</h2><p>我们经常会定义一 个service 接口，比如说 UserService,然后使用一个 UserServiceImpl 类去实现 UserService 里面的接口。</p><pre><code>public interface UserService {    void test1();}public class UserServiceImpl implements UserService {    @Override    public void test1() {    }}</code></pre><p>那么在UserServiceImpl里的 test1() 方法上，如何跳转到 UserService 的 test1() ,直接使用 <code>ctrl+u</code> 即可。</p><h2 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h2><p>如果修改了部分代码，突然觉得不合适，使用 <code>ctrl+z</code> 回滚掉后。突然又觉得刚才的修改是可以的。那你可以使用 <code>ctr+shift+z</code> 再次恢复你刚才修改的内容。</p><h2 id="切换皮肤最快的方式"><a href="#切换皮肤最快的方式" class="headerlink" title="切换皮肤最快的方式"></a>切换皮肤最快的方式</h2><p>可以直接使用 <code>ctrl</code>,然后加上一个 <code>`</code> ,就可以立刻弹出如下界面：<br><img src="https://img-blog.csdn.net/2018060409462114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>选择 <code>Color Scheme</code>，然后回车，就可以弹出修改皮肤的窗口。<br><img src="https://img-blog.csdn.net/20180604094730359?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>同样来自于 <a href="https://blog.csdn.net/linsongbin1" target="_blank" rel="noopener">Sam哥哥聊技术</a> 的分享，这里非常感谢！</p><p>此篇文章同样是收藏级别的文章，多学多用，才能使coding效率大大的提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgqaxwnn9j20sf0jrdlq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Intellij IDEA，一个开发者甚爱的IDE，用了这么多年，其中有些小Tips你真的了解吗？Intellij IDEA神器小技巧第二弹来了！&lt;/p&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://blog.csdn.net/linsongbin1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sam哥哥聊技术&lt;/a&gt;的技术博文。&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://blog.csdn.net/linsongbin1/article/details/80560332&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/linsongbin1/article/details/80560332&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Intellij IDEA" scheme="http://www.chenruiwen.cn/categories/Intellij-IDEA/"/>
    
    
      <category term="转载摘抄" scheme="http://www.chenruiwen.cn/tags/%E8%BD%AC%E8%BD%BD%E6%91%98%E6%8A%84/"/>
    
      <category term="Intellij IDEA" scheme="http://www.chenruiwen.cn/tags/Intellij-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展机制实现(二)之浅析ExtensionLoader</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdm0006uifnjvwmmhl2/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdm0006uifnjvwmmhl2/</id>
    <published>2018-06-11T14:47:08.000Z</published>
    <updated>2018-07-21T10:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgr9divhvj20go09cwf7.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章有介绍jdk SPI一些基本的使用和源码分析，既然dubbo也想使用SPI机制，为什么不直接使用jdk的SPI呢？</p><p>上篇文章开头也提到了：</p><blockquote><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p></blockquote><p>看看官方文档上Dubbo加强了哪些地方：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1frb9d0bvqmj216q0dcdk3.jpg" alt="">  </p><p>本文简单分析下Dubbo实现扩展点机制的ExtensionLoader类,分析其对比java的spi是怎么改进的。<br><a id="more"></a></p><h2 id="Dubbo扩展点约定"><a href="#Dubbo扩展点约定" class="headerlink" title="Dubbo扩展点约定"></a>Dubbo扩展点约定</h2><blockquote><p>在扩展类的 jar 包内 ，放置扩展点配置文件 META-INF/dubbo/接口全限定名，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。</p></blockquote><blockquote><p>注意：这里的配置文件是放在你自己的 jar 包内，不是 dubbo 本身的 jar 包内，Dubbo 会全 ClassPath 扫描所有 jar 包内同名的这个文件，然后进行合并 ↩</p></blockquote><h2 id="一个自定义扩展点小例子"><a href="#一个自定义扩展点小例子" class="headerlink" title="一个自定义扩展点小例子"></a>一个自定义扩展点小例子</h2><p>第一步：新建一个jar包，我这里是在原先的dubbo源码包里的dubbo-rpc模块新增了一个实现 [dubbo-rpc-myrpc]：</p><pre><code>&lt;parent&gt;    &lt;artifactId&gt;dubbo-rpc&lt;/artifactId&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/parent&gt;&lt;artifactId&gt;dubbo-rpc-myrpc&lt;/artifactId&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;${project.artifactId}&lt;/name&gt;&lt;description&gt;The my rpc module of dubbo project&lt;/description&gt;&lt;properties&gt;    &lt;skip_maven_deploy&gt;false&lt;/skip_maven_deploy&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-rpc-api&lt;/artifactId&gt;        &lt;version&gt;${project.parent.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>第二步：以实现Protocol扩展为例，新建自定义实现:</p><pre><code>/** * MyRpcProtocol */public class MyRpcProtocol extends AbstractProtocol implements Protocol {    public static final int DEFAULT_PORT = 0;    @Override    public int getDefaultPort() {        return DEFAULT_PORT;    }    @Override    public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException {        System.out.println(&quot;my rpc export...&quot;);        return null;    }    @Override    public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException {        System.out.println(&quot;my rpc refer...&quot;);        return null;    }}</code></pre><p>第三步：在jar包里定义扩展点：META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol </p><pre><code>myrpc=com.alibaba.dubbo.rpc.protocol.myrpc.MyRpcProtocol</code></pre><p>大工完成，是不是so easy…</p><p>第四步：测试。接下来测试一下，写一个提供者使用我们的自定义协议。<br>pom.xml里引用我们的自定义包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-rpc-myrpc&lt;/artifactId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>提供者xml里注册我们的协议:</p><pre><code>&lt;dubbo:protocol name=&quot;myrpc&quot; port=&quot;66666&quot;/&gt;</code></pre><p>然后启动服务:</p><pre><code class="java">public class Provider {    public static void main(String[] args) throws Exception {        //Prevent to get IPV6 address,this way only work in debug mode        //But you can pass use -Djava.net.preferIPv4Stack=true,then it work well whether in debug mode or not        System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;META-INF/spring/dubbo-demo-provider.xml&quot;});        context.start();        System.in.read(); // press any key to exit    }}</code></pre><p>可以看到控制台打印了:</p><pre><code>...[11/06/18 11:12:16:016 CST] main  INFO config.AbstractConfig:  [DUBBO] Export dubbo service com.alibaba.dubbo.demo.DemoService to local registry, dubbo version: 2.0.0, current host: 172.16.192.43[11/06/18 11:12:16:016 CST] main  INFO config.AbstractConfig:  [DUBBO] Export dubbo service com.alibaba.dubbo.demo.DemoService to url myrpc://172.16.192.43:66666/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider2&amp;bind.ip=172.16.192.43&amp;bind.port=66666&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=25280&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528686736167, dubbo version: 2.0.0, current host: 172.16.192.43[11/06/18 11:12:16:016 CST] main  INFO config.AbstractConfig:  [DUBBO] Register dubbo service com.alibaba.dubbo.demo.DemoService url myrpc://172.16.192.43:66666/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider2&amp;bind.ip=172.16.192.43&amp;bind.port=66666&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=25280&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528686736167 to registry registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider2&amp;dubbo=2.0.0&amp;pid=25280&amp;qos.port=22222&amp;registry=zookeeper&amp;timestamp=1528686735588, dubbo version: 2.0.0, current host: 172.16.192.43my rpc export...Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: exporter == null    at com.alibaba.dubbo.rpc.listener.ListenerExporterWrapper.&lt;init&gt;(ListenerExporterWrapper.java:40)    at com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:59)...</code></pre><p>至此说明了我们的自定义扩展点可以使用。这样以后如果需要实现自定义的一些其他扩展点，使用起来也是非常easy.这里可以体现出Dubbo的设计理念:</p><ul><li><em>API 与 SPI 分离</em></li><li><em>微核插件式，平等对待第三方</em></li></ul><h2 id="ExtensionLoader中的缓存"><a href="#ExtensionLoader中的缓存" class="headerlink" title="ExtensionLoader中的缓存"></a>ExtensionLoader中的缓存</h2><p>Dubbo官方文档也说了，扩展点的实例化并非一次性全部加载的。所以它可能是懒加载的，用到哪个实例化哪个扩展点，其次官方文档也说了Dubbo的扩展点性能提升不少，说到性能提升下意识就是想到万能的缓存。来看看 Dubbo的扩展点加载器 ExtensionLoader是怎么实现的提高性能的。</p><p>ExtensionLoader各式各样的缓存：</p><pre><code>public class ExtensionLoader&lt;T&gt; {    private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();    private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();    private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();    private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();    private final Map&lt;String, Activate&gt; cachedActivates = new ConcurrentHashMap&lt;String, Activate&gt;();    private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();    private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;Object&gt;();    private volatile Class&lt;?&gt; cachedAdaptiveClass = null;    private String cachedDefaultName;    private volatile Throwable createAdaptiveInstanceError;    private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;    private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;String, IllegalStateException&gt;();    ...}</code></pre><p>ExtensionLoader并没有提供public的构造器，获取一个ExtensionLoader实例是通过私有静态方法 <em>getExtensionLoader(Class<t> type)</t></em> 法获取。</p><pre><code class="java">private ExtensionLoader(Class&lt;?&gt; type) {    this.type = type;    /**      * 这里会存在递归调用,ExtensionFactory的objectFactory为null,其他则为AdaptiveExtensionFactory     * AdaptiveExtensionFactory的factories中有SpiExtensionFactory,SpringExtensionFactory     * getAdaptiveExtension()来获取一个拓展装饰类对象     * objectFactory是一个 ExtensionFactory 对象，扩展点工厂类，暂且不分析     */    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());}@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {    if (type == null) //拓展点类型非空判断        throw new IllegalArgumentException(&quot;Extension type == null&quot;);    if (!type.isInterface()) { // 拓展点类型只能是接口        throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;);    }    if (!withExtensionAnnotation(type)) { // 必须使用@spi注解,否则抛异常        throw new IllegalArgumentException(&quot;Extension type(&quot; + type +                &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;);    }    // 使用了缓存，从缓存EXTENSION_LOADERS中获取,如果不存在则创建后加入缓存，每个扩展点有且仅有一个ExtensionLoader实例与之对应。    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);    if (loader == null) {        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);    }    return loader;}</code></pre><p>Dubbo处理缓存的一些值得学习的小细节：对线程安全方面的细节做得很好。</p><ol><li>比如缓存都使用 ConcurrentMap 而不使用 HashMap.</li><li><p>volatile关键字的使用。</p><pre><code class="java">private volatile Class&lt;?&gt; cachedAdaptiveClass = null;</code></pre><pre><code class="java">public class Holder&lt;T&gt; { private volatile T value; public void set(T value) {     this.value = value; public T get() {     return value; }}</code></pre></li></ol><h2 id="Dubbo如何改进获取spi的问题"><a href="#Dubbo如何改进获取spi的问题" class="headerlink" title="Dubbo如何改进获取spi的问题"></a>Dubbo如何改进获取spi的问题</h2><p>问题一：<em>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源</em>。</p><p>答：Dubbo的ExtensionLoader提供了三种获取扩展点实现类的方式：  </p><ul><li>public T getExtension(String name)<br>根据名称获取当前扩展的指定实现</li><li>public T getAdaptiveExtension()<br>获取当前扩展点的自适应实现</li><li>public List<t> getActivateExtension(URL url, String[] values, String group)<br>获取可激活的扩展点集合</t></li></ul><p>这三个地方准备在下一篇扩展点自适应自动激活的分析时一并讲解一下。<br>这里可以看到Dubbo可以直接根据key就能获取到spi对象，而java的spi只能通过遍历然后根据if判断才能获取制定的spi对象。时间复杂度O(1) 比 O(n)快不少。而且用到了就加到缓存里，不用就不需要实例化，节约资源。</p><p>问题二：<em>如果扩展点加载失败，连扩展点的名称都拿不到了。会把真正失败的原因吃掉</em></p><p>答: Dubbo并不会这样，当拿不到扩展点的名字时，Dubbo会直接抛出异常：</p><pre><code>public T getExtension(String name) {    if (name == null || name.length() == 0)        throw new IllegalArgumentException(&quot;Extension name == null&quot;);    ...}</code></pre><p>其次，Dubbo非常好的一点，增加了默认值的设置。<br>比如：</p><pre><code>@SPI(&quot;dubbo&quot;)public interface Protocol {}</code></pre><p>这样就默认提供了dubbo=xxx.xxx.XxxProtocol的s实现。如果使用默认的扩展点，可以这么做：</p><pre><code>Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();</code></pre><p>这里的protocol对象即是com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</p><p>问题三：<em>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点</em></p><p>答：这个之后分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>实现一个Dubbo自定义扩展点只需要三步。</li><li>Dubbo中的缓存设计在线程安全方面非常值得学习。</li><li>Dubbo是如何加强java的spi的，java的spi上哪些的不足被Dubbo巧妙实现了。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文只是简单介绍了一下扩展点加载器ExtensionLoader。之后还有更多的源码分析它。我会从Dubbo官方文档上写的四个特性分析它并借鉴其中的一些理念。</p><p>下一篇就说说扩展点的四个特性：   <em>扩展点自动包装，扩展点自动装配，扩展点自适应，扩展点自动激活。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgr9divhvj20go09cwf7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章有介绍jdk SPI一些基本的使用和源码分析，既然dubbo也想使用SPI机制，为什么不直接使用jdk的SPI呢？&lt;/p&gt;
&lt;p&gt;上篇文章开头也提到了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看看官方文档上Dubbo加强了哪些地方：&lt;br&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1frb9d0bvqmj216q0dcdk3.jpg&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;本文简单分析下Dubbo实现扩展点机制的ExtensionLoader类,分析其对比java的spi是怎么改进的。&lt;br&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展机制实现(一)之java SPI</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdd0000uifncl8zje5c/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdd0000uifncl8zje5c/</id>
    <published>2018-06-04T13:31:24.000Z</published>
    <updated>2018-07-21T10:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgqxq94j8j20h109kdfs.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的文章<a href="https://www.chenruiwen.cn/cjjvafgfn0008opfnnl3fiez1">Dubbo暴露服务过程</a>中提出了问题：<em>@SPI</em>这些东西究竟是什么?<br>在<a href="https://dubbo.apache.org/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">Dubbo开发手册之扩展点加载</a>中有这么解释过：</p><blockquote><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p></blockquote><p>所以在分析Dubbo扩展机制前，先看看jdk的SPI。<br><a id="more"></a></p><h2 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ,是JDK内置的一种服务提供发现机制。<br>在面向对象设计里，我们不会针对实现编程，模块间面向接口编程来防止强耦合。java spi机制实现了一种放在程序以外的方式去动态装配模块，这就是java的服务发现。类似于ioc的思想，将模块装配放在程序外，比如xml等方式。</p><p>Dubbo框架就是借鉴了这种机制，在jdk的基础上进行了改进。</p><h2 id="java-SPI机制约定"><a href="#java-SPI机制约定" class="headerlink" title="java SPI机制约定"></a>java SPI机制约定</h2><p>java的spi是通过<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">ServiceLoader</a>来加载，根据官方文档来看一下SPI机制的约定：</p><ul><li>Service实现类必须有一个无参构造器</li><li>在META-INF/services/目录中提供一个文件名称为Service接口全限定名的文件，文件内容为Service接口实现类全限定名，编码格式为UTF-8</li><li>使用java.util.ServiceLoader来动态加载Service接口的实现类。</li></ul><h2 id="SPI示例"><a href="#SPI示例" class="headerlink" title="SPI示例"></a>SPI示例</h2><p><a href="https://github.com/crrrrrw/java-spi-demo" target="_blank" rel="noopener">代码地址传送门</a><br>目录结构如下:<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr6nptfm2aj20ig0cqgml.jpg" alt=""><br>接口定义：</p><pre><code>public interface HelloWorld {    void sayHello();}</code></pre><p>两个实现：</p><pre><code>public class HelloWorldENimpl implements HelloWorld {    @Override    public void sayHello() {        System.out.println(&quot;hello,world!&quot;);    }}public class HelloWorldCNimpl implements HelloWorld {    @Override    public void sayHello() {        System.out.println(&quot;你好，世界！&quot;);    }}</code></pre><p>配置服务发现，在META-INF/service目录下创建文件：<em>com.crw.demo.spi.HelloWorld</em>，内容为接口实现类全名：</p><pre><code>com.crw.demo.spi.impl.HelloWorldENimplcom.crw.demo.spi.impl.HelloWorldCNimpl</code></pre><p>编写调用端：</p><pre><code>public class Run {    public static void main(String[] args) {        ServiceLoader&lt;HelloWorld&gt; loads = ServiceLoader.load(HelloWorld.class);        for (HelloWorld load : loads) {            load.sayHello();        }    }}</code></pre><p>运行结果如下：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr6n9im7d1j20kq060aam.jpg" alt="">  </p><h2 id="ServiceLoader源码分析"><a href="#ServiceLoader源码分析" class="headerlink" title="ServiceLoader源码分析"></a>ServiceLoader源码分析</h2><p>从 <em>ServiceLoader.load(Class\&lt;S> service)</em> 方法点进去看一下</p><pre><code>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); // 获取类加载器    return ServiceLoader.load(service, cl);}private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;    reload(); // 开始加载}public void reload() {    providers.clear(); // 清空提供者缓存    lookupIterator = new LazyIterator(service, loader); // 创建一个懒加载的提供者发现器}</code></pre><p>可以看到，实际上是交给了一个私有静态内部类处理new LazyIterator(service, loader); 通过名字就像是懒加载，所以我们看看什么时候类加载器会加载SPI实现服务。  </p><p>答案是遍历的时候。</p><p>ServiceLoader实现了iterator接口:</p><pre><code>public Iterator&lt;S&gt; iterator() {    return new Iterator&lt;S&gt;() {        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders            = providers.entrySet().iterator();        public boolean hasNext() {            if (knownProviders.hasNext())                return true;            return lookupIterator.hasNext(); // 实际上是调用LazyIterator.hasNext()方法。        }        public S next() {            if (knownProviders.hasNext())                return knownProviders.next().getValue();            return lookupIterator.next(); // 实际上是调用LazyIterator.next()方法。        }        public void remove() {            throw new UnsupportedOperationException();        }    };}</code></pre><p>在客户端遍历的时候，首先调用了hasNext()方法，hasNext调用了LazyIterator.hasNext(),其实际上又调用了内部方法 <em>hasNextService()</em> :</p><pre><code>private boolean hasNextService() {    if (nextName != null) { // 如果有服务提供者名称，直接返回        return true;    }    if (configs == null) {        try {            String fullName = PREFIX + service.getName(); // META-INF/services/xxx.xxx.xxx.XxxImpl            // 获取配置文件加载路径            if (loader == null)                configs = ClassLoader.getSystemResources(fullName);            else                configs = loader.getResources(fullName);        } catch (IOException x) {            fail(service, &quot;Error locating configuration files&quot;, x);        }    }    while ((pending == null) || !pending.hasNext()) {        if (!configs.hasMoreElements()) {            return false;        }        pending = parse(service, configs.nextElement()); //解析配置路径，用utf-8格式读取配置    }    nextName = pending.next(); // 服务提供者名称赋值    return true;}</code></pre><p>看一眼解析完的结构，在遍历的时候会读取配置，把服务提供者名称一次性获取：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr9re67q83j20vk0jugp9.jpg" alt="">  </p><p>接着，在客户端遍历的时候调用了next()方法，<br>LazyIterator.next()方法里做了如下事情</p><pre><code>private S nextService() {    if (!hasNextService()) // 如果配置里没有服务，则会抛异常        throw new NoSuchElementException();    String cn = nextName;    nextName = null;    Class&lt;?&gt; c = null;    try {        c = Class.forName(cn, false, loader); // 反射创建了配置文件里的实现类    } catch (ClassNotFoundException x) {        fail(service,             &quot;Provider &quot; + cn + &quot; not found&quot;);    }    if (!service.isAssignableFrom(c)) {        fail(service,             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);    }    try {        S p = service.cast(c.newInstance()); // 创建了一个实现类的实例        providers.put(cn, p); // 放入提供者缓存中        return p;    } catch (Throwable x) {        fail(service,             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,             x);    }    throw new Error();          // This cannot happen}</code></pre><p>返回了一个服务提供者实例，就这样完成了一次SPI调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要介绍了jdk SPI机制：</p><ul><li>java如何编写一个SPI服务的。</li><li>ServiceLoader源码如何实现SPI服务。  </li></ul><p>本篇主要是为了Dubbo实现spi而做了铺垫。在看ServiceLoader的源码时，主要还是利用了java的类加载器 ClassLoader ，这些之后会单独写一写。鉴于鄙人才疏学浅，以上文章如有不对的地方希望大家予以指出，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgqxq94j8j20h109kdfs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的文章&lt;a href=&quot;https://www.chenruiwen.cn/cjjvafgfn0008opfnnl3fiez1&quot;&gt;Dubbo暴露服务过程&lt;/a&gt;中提出了问题：&lt;em&gt;@SPI&lt;/em&gt;这些东西究竟是什么?&lt;br&gt;在&lt;a href=&quot;https://dubbo.apache.org/books/dubbo-dev-book/SPI.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo开发手册之扩展点加载&lt;/a&gt;中有这么解释过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以在分析Dubbo扩展机制前，先看看jdk的SPI。&lt;br&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询性能优化</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdx000kuifnzqebv537/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdx000kuifnzqebv537/</id>
    <published>2018-05-28T15:16:27.000Z</published>
    <updated>2018-07-21T10:53:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>查询优化的基本原则</li><li>了解MySQL执行过程</li><li>浅析MySQL优化器</li><li>MySQL语句优化小tips</li><li>理解MySQL如何查询，明白高效和低效的原因<a id="more"></a></li></ul><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><p>分两步分析是否是低效的查询：  </p><ol><li><p><strong>是否向数据库请求了不需要的数据？</strong><br>比如查询了过多的行，查询过多的列(select * …)，以及重复的查询。</p></li><li><p><strong>Mysql是否在扫描额外的记录？</strong><br>三个指标衡量查询开销：</p><ul><li>响应时间</li><li>扫描行数</li><li>返回的行数</li></ul></li></ol><h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul><li>一个复杂查询or多个简单查询?</li><li>切分查询(比如在删改操作时，将全量语句改成批量执行)</li><li>分解关联查询(把一条复杂的关联查询分解为多条简单查询，可以让缓存效率更高，减少锁竞争) </li></ul><h2 id="一张图看Mysql执行过程"><a href="#一张图看Mysql执行过程" class="headerlink" title="一张图看Mysql执行过程"></a>一张图看Mysql执行过程</h2><p><img src="https://ww1.sinaimg.cn/large/87faef88ly1fqmpuoqb43j20px0hyacw.jpg" alt=""></p><ol><li>客户端将查询发送到服务器；</li><li>服务器检查查询缓存，如果找到了，就从缓存中返回结果，否则进行下一步。</li><li>服务器解析，预处理和优化查询，生成执行计划。</li><li>执行引擎调用存储引擎API执行查询。</li><li>服务器将结果发送回客户端。</li></ol><h4 id="1-客户端服务端通信协议"><a href="#1-客户端服务端通信协议" class="headerlink" title="1.客户端服务端通信协议"></a>1.客户端服务端通信协议</h4><p>通信协议工作机制：“抛球”游戏。任意时刻，要么是客户端发送数据，要么是服务端发送数据。一旦一端发送数据(抛球),另一端只能完整的接受消息才能响应。</p><p>所以，我们需要限制发送信息的大小。<br>客户端：查询语句尽量少，否则可能会抛错误异常(“MySQL server has gone away”)。 </p><pre><code class="ruby"># 查看你的服务器所允许传送的最大数据SHOW VARIABLES LIKE &#39;max_allowed_packet&#39; </code></pre><p>服务端：当服务端开始响应客户端请求时，客户端必须完整接受整个返回结果。所以要限制查询条数，必要时查询语句用“LIMIT”限制。</p><p>通过  “SHOW [FULL] PROCESSLIST” 命令查询mysql连接时线程状态:<a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html" target="_blank" rel="noopener">MySQL5.7通用线程状态</a></p><h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h4><p>如果开启了缓存，MySql会检查查询缓存，进行大小写敏感的哈希查找。如果命中，判断权限没问题后会跳过所有其他阶段直接返回。</p><pre><code class="ruby"># 查看是否开启查询SHOW VARIABLES LIKE &#39;query_cache_type&#39;; </code></pre><h4 id="3-解析器"><a href="#3-解析器" class="headerlink" title="3.解析器"></a>3.解析器</h4><p>解析器通过关键字解析SQL，然后生成一颗对应的“解析树”，然后它使用MySQL语法规则验证和解析语句，比如关键字是否错误，顺序等。</p><h4 id="4-预处理"><a href="#4-预处理" class="headerlink" title="4.预处理"></a>4.预处理</h4><p>进一步检查解析树的合法性。比如检查数据表列是否存在，名字和别名等。最后，预处理器检查权限。</p><h4 id="5-查询优化器-重点"><a href="#5-查询优化器-重点" class="headerlink" title="5.查询优化器(重点)"></a>5.查询优化器(重点)</h4><p>优化器负责将预处理合格的语法树转化为执行计划。</p><p>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划的成本，并选择成本最小的一个。</p><pre><code class="ruby"># 查询当前会话的当前查询成本SHOW VARIABLES LIKE &#39;Last_query_cost&#39;; </code></pre><p><strong>Q:</strong> 那么，MySQL是如何预测成本的呢？<br><strong>A:</strong> MySQL根据一系列统计信息计算得来:每个表或页面个数，索引基数，索引和数据行的长度，索引分布情况等。评估成本不考虑缓存，假设读取任何数据需要一次磁盘I/O。</p><p><strong>可惜MySQL优化器并不是万能的</strong>，有诸多因素会导致MySQL选择错误的执行计划，比如统计信息可能不准确，成本估算和实际成有差距等。</p><p>更多的了解查询优化器是怎么处理查询语句的，查看<a href="https://www.chenruiwen.cn/2018/cjjvafgft000dopfnzaabqjyd/">MySQL查询优化器</a></p><h4 id="6-查询执行引擎"><a href="#6-查询执行引擎" class="headerlink" title="6.查询执行引擎"></a>6.查询执行引擎</h4><p>MySQL根据解析优化阶段生成的执行计划给出的指令逐步执行。</p><h4 id="7-返回结果给客户端"><a href="#7-返回结果给客户端" class="headerlink" title="7.返回结果给客户端"></a>7.返回结果给客户端</h4><ul><li>查询结果返回给客户端，即时查询不需要返回结果集给客户端，也亏返回一些这个查询信息，比如影响的行数。  </li><li>如果查询可以被缓存，这一阶段也会存放结果入缓存。</li><li>MySQL结果集返回是一个增量、逐步返回的过程。一旦处理开始产生第一条结果时，MySQL就开始逐步返回结果集了。这样的好处是，服务器无须存储太多结果而消耗太多内存，二是客户端可以第一时间获得返回结果。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>当发现MySQL查询效率不高时，考虑两个因素：1.是否请求了不需要的数据？2.是否查询了额外的记录？</li><li>对待效率不高的语句，考虑语句适当拆分成多个简单的语句。</li><li>MySQL执行过程，看图</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查询优化的基本原则&lt;/li&gt;
&lt;li&gt;了解MySQL执行过程&lt;/li&gt;
&lt;li&gt;浅析MySQL优化器&lt;/li&gt;
&lt;li&gt;MySQL语句优化小tips&lt;/li&gt;
&lt;li&gt;理解MySQL如何查询，明白高效和低效的原因
    
    </summary>
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询优化器</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdv000fuifnjpty2nib/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdv000fuifnjpty2nib/</id>
    <published>2018-05-22T15:42:47.000Z</published>
    <updated>2018-07-21T10:52:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>了解查询优化器的优化策略</li><li>了解和查看查询优化器优化后的执行计划</li><li>了解优化器是怎么优化的</li><li>了解优化器在关联语句中的处理</li><li>了解一些查询优化器的提示<a id="more"></a></li></ul><h2 id="MySQL查询优化器的优化策略"><a href="#MySQL查询优化器的优化策略" class="headerlink" title="MySQL查询优化器的优化策略"></a>MySQL查询优化器的优化策略</h2><p>简单分为 <strong>静态优化</strong> 和 <strong>动态优化</strong>。</p><p>一、静态优化(“编译时优化”):</p><ul><li>可以直接对解析树进行分析并完成优化。  </li><li>优化器通过一些简单的代叔变换将WHERE条件转化为另一种等价形式。</li><li>静态优化不依赖特别的数值，比如WHERE条件里带一些常数等。</li><li>静态优化在第一次完成后一直有效，即使使用不同的参数值执行查询也不会发生变化。</li></ul><p>二、动态优化(“运行时优化”):</p><ul><li>动态优化和查询上下文有关或者其他因素有关，比如WHERE条件中的取值，索引中条目对应的数据行数等。</li><li>每次查询都需要重新评估。</li></ul><h2 id="MySQL能够处理的优化类型"><a href="#MySQL能够处理的优化类型" class="headerlink" title="MySQL能够处理的优化类型"></a>MySQL能够处理的优化类型</h2><p>先说一点，MySQL优化器使用了很多复杂的优化技巧把查询转化为执行计划。“不要试着比优化器更聪明”，通常都应让MySQL按照自己优化的方式执行语句，绝大多数情况优化器都是更优的。<br>你也可以通过EXPLAIN EXTENDED SELECT … … ; SHOW WARNINGS; 查看最终优化后的执行sql。<br>如何使用“EXPLAIN EXTENDED”可参考<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">官方文档上的Extended EXPLAIN Output Format</a></p><ol><li><font face="华文新魏" size="3">重新定义关联表顺序。</font><br>数据表的关联并不总是按照查询中指定顺序进行的。</li><li><font face="华文新魏" size="3">将外链接转化为内连接。</font><br>优化器可以根据某些因素(比如WHERE条件，库表结构等)，使得一个外连接等价于一个内连接。</li><li><p><font face="华文新魏" size="3">等价变换规则。</font><br>MySQL通过等价变换来简化并规范表达式。MySQL可以合并和减少比较。比如 (5=5 AND a&gt;5)会被改写为a&gt;5。(a &lt; b AND b=c) AND a=5会被改写为(b&gt;5 AND b=c AND a=5)</p></li><li><p><font face="华文新魏" size="3">优化</font> COUNT()、MIN()、MAX()。<br>查找某列最大/最小值，该列又有索引，查找最大值，则会直接找最后一行；最小值，则直接找第一行。因为索引已经排好序了。可以从EXPLAIN中看到：“Select tables optimized away”。这说明已经从执行计划中移除该表并用常数取代。</p></li><li><font face="华文新魏" size="3">预估并转化为常数表达式</font><br>如果一个表达式可以被简化为一个常量，那么这个表达式就会被转换。 在WHERE 、USING、ON这些连接条件强制值相等的条件中，常量具有传递性<br><code>`</code><br>EXPLAIN SELECT<br> table_a.id,<br> table_b.id<br>FROM<br> table_b<br>INNER JOIN table_a ON table_a.tb_id = table_b.id<br>WHERE<br> table_b.id = 1</li></ol><pre><code>![](https://ww1.sinaimg.cn/large/87faef88ly1fqnue0bqrbj20r102ut8o.jpg)6. &lt;font face=&quot;华文新魏&quot; size=&quot;3&quot;&gt;覆盖索引&lt;/font&gt;  当索引包含查询需要的列时，MySql就可以使用索引来避免读取行数据。7. &lt;font face=&quot;华文新魏&quot; size=&quot;3&quot;&gt;子查询优化&lt;/font&gt;  MySQL可以将某些类型的子查询转换成相等的效率更高的形式。8. &lt;font face=&quot;华文新魏&quot; size=&quot;3&quot;&gt;提前终止查询&lt;/font&gt;  - MySQL在发现已经满足查询需求时，会立刻终止查询。- MySQL检测一个不成立的条件也会立刻返回空结果。</code></pre><p>EXPLAIN SELECT * FROM table_a WHERE id = - 1;</p><pre><code>![](https://ww1.sinaimg.cn/large/87faef88ly1fqongff9j4j20sx01rjra.jpg)9. &lt;font face=&quot;华文新魏&quot; size=&quot;3&quot;&gt;等值传播&lt;/font&gt;  如果两个列的值通过等式关联，那么MySQL能把其中一个列的WHERE条件传递到另一个列。比如：</code></pre><p>SELECT table_a.id, table_b.id FROM table_b INNER JOIN table_a ON table_a.tb_id = table_b.id WHERE table_b.id &lt; 100;</p><pre><code>MySQL会判断把WHERE后面的关联作用于table_a表，等价于</code></pre><p>SELECT table_a.id, table_b.id FROM table_b INNER JOIN table_a ON table_a.tb_id = table_b.id WHERE table_b.id &lt; 100 AND table_a.tb_id &lt; 100;</p><pre><code>10. &lt;font face=&quot;华文新魏&quot; size=&quot;3&quot;&gt;列表IN()的比较&lt;/font&gt;  MySql会对IN()里面的数据进行排序，然后用二分法查找某个值是否在列表中，这个算法的效率是O(Log n)。这其他数据库等价转换为多个OR条件连接的复杂度O(n)来说，IN()里大量取值时会更快。## MySQL如何关联查询MySQL关联查询策略:  其实就是嵌套循环查询。MySQL先从第一个表循环读，然后再嵌套循环到下一个表寻找匹配，如此反复，直到找到所有表的匹配的行为止。 举个栗子：  - 内连接sql</code></pre><p>SELECT tbl_user.name, tbl_bankcard.bankcard<br>FROM tbl_user INNER JOIN tbl_bankcard ON tbl_user.id = tbl_bankcard.user_id<br>WHERE tbl_user.moblie in (‘18611112222’,’18611113333’)</p><pre><code>MySQL在查询这条SQL时，用伪代码表示查询过程如下:```rubyouter_iter = iterator over tbl_user where moblie in (&#39;18611112222&#39;,&#39;18611113333&#39;);outer_row = outer_iter.next;while outer_row:    inner_iter = iterator over tbl_bankcard where user_id = outer_row.id;    inner_row = inner_iter.next;    while inner_row:        output [outer_row.name, inner_row.bankcard]        inner_row = inner_iter.next;    end    outer_row = outer_iter.next;end    </code></pre><ul><li>再看这个SQL左外连接版本：<pre><code>SELECT tbl_user.name, tbl_bankcard.bankcard FROM tbl_user LEFT JOIN tbl_bankcard ON tbl_user.id = tbl_bankcard.user_idWHERE tbl_user.moblie in (&#39;18611112222&#39;,&#39;18611113333&#39;)</code></pre>MySQL在查询这条SQL时，用伪代码表示查询过程如下:<pre><code class="ruby">outer_iter = iterator over tbl_user where moblie in (&#39;18611112222&#39;,&#39;18611113333&#39;);outer_row = outer_iter.next;while outer_row:  inner_iter = iterator over tbl_bankcard where user_id = outer_row.id;  inner_row = inner_iter.next;  if inner_row:      while inner_row:          output [outer_row.name, inner_row.bankcard]          inner_row = inner_iter.next;      end  else       output [outer_row.name, NULL]  end  outer_row = outer_iter.next;end    </code></pre></li></ul><p>基本上MySQL所有类型的查询都是这种方式运行。包括子查询，也是生成一张临时表，被当做普通表进行循环嵌套。以及右外链接也是会改写成等价的左外连接。</p><hr><p>多表关联的一种方式：</p><pre><code>graph TD    B(Join) --&gt; A[Join]    C(Join) --&gt; A    D(tbl1) --&gt; B    E(tbl2) --&gt; B    F(tbl3) --&gt; C    G(tbl4) --&gt; C</code></pre><p>但是MySQL是通过从一个表开始一直嵌套循环的方式：</p><pre><code>graph TD    B(Join) --&gt; A[Join]    C(tbl4) --&gt; A    D[Join] --&gt; B    E[tbl3] --&gt; B    F[tbl1] --&gt; D    G[tbl2] --&gt; D </code></pre><h2 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h2><ul><li>MySQL查询优化器中最重要的一部分。它决定了多表查询的顺序。它评估不同顺序的成本选择成本最小的一个。</li><li>有时优化器给出的并不是最优的关联顺序，可使用STRAIGHT_JOIN关键字替换JOIN关键字重写查询。还是那句，“不要试着比优化器更聪明”。</li><li>不过，如果有超过n个表的关联，那么需要检查n的阶乘种关联顺序。我们称之为所有可能的执行计划的“搜索空间”。实际上，当需要关联的表超过 optimizer_search_depth 的限制的时候，就会选择“贪婪”搜索模式。</li></ul><h2 id="查询优化器的提示-hint"><a href="#查询优化器的提示-hint" class="headerlink" title="查询优化器的提示(hint)"></a>查询优化器的提示(hint)</h2><p>用于控制查询执行计划。列举一些课使用的提示：</p><ol><li><p>HIGH_PRIORITY 和 LOW_PRIORITY <br><br>当多条语句同时访问数据库时，设置语句优先级。HIGH_PRIORITY会使语句放在表的队列的最前面，LOW_PRIORITY则相反。这两个提示只对使用表锁的存储引擎有效。</p></li><li><p>DELAYED <br><br>这个提示用于INSERT和REPLACE。使用该提示会将插入的行数据放入缓冲区，然后在表空闲时批量写入数据。适合于日志插入等场景。但并不是所有存储引擎都支持，还会导致函数 LAST_INSERT_ID()无法正常工作。</p></li><li><p>STRAIGHT_JOIN <br><br>这个提示可用于SELECT语句中SELECT关键字之后，也可放置于两个关联表之间。该提示作用一是让查询中的表按语句出现的顺序关联。作用二是固定前后两个表的关联顺序。</p></li><li><p>SQL_SMALL_RESULT 和 SQL_BIG_RESULT <br><br>这个提示只对SELECT有效。它告诉优化器对GROUP BY或者DISTINCT查询如果使用临时表和排序。SQL_SMALL_RESULT会让优化器认为结果集很小，将结果放在内存中的索引临时表中，避免排序。SQL_BIG_RESULT 则告诉优化器结果集很大，在磁盘临时表进行排序。</p></li><li><p>SQL_BUFFER_RESULT <br><br>这个提示告诉优化器将结果放在临时表中，并且尽快释放掉表锁。</p></li><li><p>SQL_CACHE 和 SQL_NO_CACHE <br><br>这个提示告诉MySQL是否将结果集放在查询缓存中。</p></li><li><p>USING INDEX、IGNORE INDEX 和 FORCE INDEX <br><br>这几个提示分别告诉优化器 使用或者不使用或者强制使用索引。</p></li></ol><h2 id="控制优化器的一些参数"><a href="#控制优化器的一些参数" class="headerlink" title="控制优化器的一些参数"></a>控制优化器的一些参数</h2><pre><code>SHOW VARIABLES LIKE &quot;optimizer_%&quot;;</code></pre><p><img src="https://ww1.sinaimg.cn/large/87faef88ly1fqr12aclarj20tb02q3yf.jpg" alt=""></p><ul><li>optimizer_search_depth<br>控制穷举执行计划的限度。</li><li>optimizer_prune_level<br>默认打开的，让优化器根据需要扫描的行数来决定是否跳过某些执行计划</li><li>optimizer_switch<br>此变量包含了一些开关优化器特性的标志位。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MySQL优化器做了很多工作把SQL语句变成更优的查询方式</li><li>使用 EXPLAIN EXTENDED … SHOW WARNINGS关键字查看优化后的指令</li><li>MySQL的关联查询是“嵌套循环”的</li><li>可使用查询优化提示控制查询执行计划，但是，“不要试着比优化器更聪明”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;了解查询优化器的优化策略&lt;/li&gt;
&lt;li&gt;了解和查看查询优化器优化后的执行计划&lt;/li&gt;
&lt;li&gt;了解优化器是怎么优化的&lt;/li&gt;
&lt;li&gt;了解优化器在关联语句中的处理&lt;/li&gt;
&lt;li&gt;了解一些查询优化器的提示
    
    </summary>
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo暴露服务过程</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdt000euifnvwp89rvq/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdt000euifnvwp89rvq/</id>
    <published>2018-05-20T07:11:24.000Z</published>
    <updated>2018-07-21T10:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgr6acju4j20m80cijt7.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>dubbo框架也用了有一年了，一直没有详细的研究过dubbo源码。所以趁有时间好好学习体会dubbo的博大精深。本人才疏学浅，如有不对，请大神指点。这里使用的dubbo版本是2.6.1。</p><p>如何看源码？跟着<a href="https://dubbo.apache.org/books/dubbo-dev-book/" target="_blank" rel="noopener">Dubbo开发手册(中文)</a>来喽。带着目的看源码，这次看dubbo是怎么暴露服务的。<br><a id="more"></a></p><h2 id="先瞜一眼启动日志"><a href="#先瞜一眼启动日志" class="headerlink" title="先瞜一眼启动日志"></a>先瞜一眼启动日志</h2><p>一般像这种大型的开源框架，都会有健全的启动日志，看看日志输出利于我们理解dubbo启动流程。<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fqz30w0utyj21e70lftdv.jpg" alt=""><br>日志输出从上往下看，dubbo做了哪些事：</p><ol><li>暴露本地服务</li><li>暴露远程服务</li><li>启动Netty，绑定和暴露地址</li><li>连接zookeeper</li><li>zookeeper订阅服务</li><li>监听zookeeper</li></ol><h2 id="先瞜一眼官方手册"><a href="#先瞜一眼官方手册" class="headerlink" title="先瞜一眼官方手册"></a>先瞜一眼官方手册</h2><p>这段内容来自<a href="https://dubbo.apache.org/books/dubbo-dev-book/implementation.html" target="_blank" rel="noopener">dubbo开发手册之实现细节</a></p><p><img src="https://ww1.sinaimg.cn/large/87faef88ly1fqz3wdhv82j20ns0n7q8q.jpg" alt=""></p><p>再来一段暴露服务时序图<br><img src="https://dubbo.apache.org/books/dubbo-dev-book/sources/images/dubbo-export.jpg" alt="image"></p><p>接下来，从官方文档开始，分析dubbo服务暴露过程。</p><h2 id="第一步，-ServiceConfig"><a href="#第一步，-ServiceConfig" class="headerlink" title="第一步， ServiceConfig"></a>第一步， ServiceConfig</h2><p>分析前，先利用IDE生成类图看看ServiceConfig的继承关系。<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fqzgb7myddj20tj0de754.jpg" alt=""></p><p><em>问题一：这么多的配置是啥？</em><br>凭借感觉像是和dubbo.xml里的配置属性有关系。先不管，留个坑。</p><p>根据时序图，我们先定位到 ServiceConfig 的 export()方法<br><strong>ServiceConfig#export</strong></p><pre><code class="java">public synchronized void export() {    ...    // 延迟暴露接口    if (delay != null &amp;&amp; delay &gt; 0) {        delayExportExecutor.schedule(new Runnable() {            public void run() {                doExport();            }        }, delay, TimeUnit.MILLISECONDS);    } else {        doExport(); // 此处调用开始暴露    }}</code></pre><p>暴露服务是调用 <strong>ServiceConfig#doExport</strong>方法</p><pre><code>protected synchronized void doExport() {    if (unexported) {        throw new IllegalStateException(&quot;Already unexported!&quot;);    }    if (exported) {        return;    }    exported = true;    if (interfaceName == null || interfaceName.length() == 0) {        throw new IllegalStateException(&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;);    }    checkDefault();// 创建了 ProviderConfig 对象并赋值 setter is属性，提供者的缺省值设置    /**     * provider已经配置的情况下，application、module、registries、monitor、protocol中未配置的值均可以从provider获取     */    if (provider != null) {        if (application == null) {            application = provider.getApplication();        }        if (module == null) {            module = provider.getModule();        }        if (registries == null) {            registries = provider.getRegistries();        }        if (monitor == null) {            monitor = provider.getMonitor();        }        if (protocols == null) {            protocols = provider.getProtocols();        }    }    if (module != null) {        if (registries == null) {            registries = module.getRegistries();        }        if (monitor == null) {            monitor = module.getMonitor();        }    }    if (application != null) {        if (registries == null) {            registries = application.getRegistries();        }        if (monitor == null) {            monitor = application.getMonitor();        }    }    if (ref instanceof GenericService) {        interfaceClass = GenericService.class;        if (StringUtils.isEmpty(generic)) {            generic = Boolean.TRUE.toString();        }    } else {        try {            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()                    .getContextClassLoader());        } catch (ClassNotFoundException e) {            throw new IllegalStateException(e.getMessage(), e);        }        checkInterfaceAndMethods(interfaceClass, methods); // 检查配置中的 interface 属性 和 methods属性        checkRef();  // 检查 ref 属性        generic = Boolean.FALSE.toString();    }    // 如果配置 local 属性， 是否服务接口客户端本地代理    if (local != null) {        if (&quot;true&quot;.equals(local)) {            local = interfaceName + &quot;Local&quot;;        }        Class&lt;?&gt; localClass;        try {            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);        } catch (ClassNotFoundException e) {            throw new IllegalStateException(e.getMessage(), e);        }        if (!interfaceClass.isAssignableFrom(localClass)) {            throw new IllegalStateException(&quot;The local implementation class &quot; + localClass.getName() + &quot; not implement interface &quot; + interfaceName);        }    }    // 如果配置 stub 属性， 是否本地存根     if (stub != null) {        if (&quot;true&quot;.equals(stub)) {            stub = interfaceName + &quot;Stub&quot;;        }        Class&lt;?&gt; stubClass;        try {            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);        } catch (ClassNotFoundException e) {            throw new IllegalStateException(e.getMessage(), e);        }        if (!interfaceClass.isAssignableFrom(stubClass)) {            throw new IllegalStateException(&quot;The stub implementation class &quot; + stubClass.getName() + &quot; not implement interface &quot; + interfaceName);        }    }    checkApplication(); // 检查 application 属性    checkRegistry(); // 检查 registry 属性    checkProtocol(); // 检查 protocol 属性    appendProperties(this); // 赋值 ServiceConfig setter is 属性    checkStubAndMock(interfaceClass); // 检查是否 使用 local,stub,mock 代理    if (path == null || path.length() == 0) {        path = interfaceName;    }    doExportUrls(); // 开始暴露远程服务了    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);}</code></pre><p><strong>ServiceConfig#doExportUrls</strong>暴露多个远程地址</p><pre><code>private void doExportUrls() {    // dubbo支持多注册中心，所以这一步把 registry 配置信息封装为多个url,比如 registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider...    List&lt;URL&gt; registryURLs = loadRegistries(true);    // dubbo是支持多协议的，将所有注册的url上对应的协议暴露出来    for (ProtocolConfig protocolConfig : protocols) {        doExportUrlsFor1Protocol(protocolConfig, registryURLs);    }}</code></pre><p><strong>ServiceConfig#doExportUrlsFor1Protocol</strong>暴露单个地址</p><pre><code>private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) {    String name = protocolConfig.getName();    if (name == null || name.length() == 0) {        name = &quot;dubbo&quot;;    }    // map存放所有配置参数，下面生成url用    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);    map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));    if (ConfigUtils.getPid() &gt; 0) {        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));    }    appendParameters(map, application);    appendParameters(map, module);    appendParameters(map, provider, Constants.DEFAULT_KEY);    appendParameters(map, protocolConfig);    appendParameters(map, this);    // method子标签配置规则解析，暂时不管    if (methods != null &amp;&amp; !methods.isEmpty()) {        for (MethodConfig method : methods) {            ...        } // end of methods for    }    // 获取所有方法添加到map中，体现在url里    if (ProtocolUtils.isGeneric(generic)) { // 如果是泛化实现，generic属性为true，method=*表示任意方法        map.put(&quot;generic&quot;, generic);        map.put(&quot;methods&quot;, Constants.ANY_VALUE);    } else {        String revision = Version.getVersion(interfaceClass, version);        if (revision != null &amp;&amp; revision.length() &gt; 0) {            map.put(&quot;revision&quot;, revision);        }        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();        if (methods.length == 0) {            logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());            map.put(&quot;methods&quot;, Constants.ANY_VALUE);        } else {            map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));        }    }    // 如果配置了token属性，如果配为default则随机UUID，否则使用配置中的token，作令牌验证用    if (!ConfigUtils.isEmpty(token)) {        if (ConfigUtils.isDefault(token)) {            map.put(&quot;token&quot;, UUID.randomUUID().toString());        } else {            map.put(&quot;token&quot;, token);        }    }    // 如果协议是 injvm，就不注册服务， notify设置为false    if (&quot;injvm&quot;.equals(protocolConfig.getName())) {        protocolConfig.setRegister(false);        map.put(&quot;notify&quot;, &quot;false&quot;);    }    // export service    String contextPath = protocolConfig.getContextpath();    // 如果 protocol配置没有配置contextPath属性，就从provider配置中取    if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) {        contextPath = provider.getContextpath();    }    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);    Integer port = this.findConfigedPorts(protocolConfig, name, map);    // 根据上面的参数创建url对象    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);    // 如果url使用的协议存在扩展，调用对应的扩展来修改原url。    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)            .hasExtension(url.getProtocol())) {        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);        }        String scope = url.getParameter(Constants.SCOPE_KEY);        // 如果scope属性没有配置为 none        if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) {            // 如果scope属性没有配置为 remote， 暴露本地服务            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) {                exportLocal(url);            }            // // 如果scope属性没有配置为 local， 暴露远程服务            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) {                if (logger.isInfoEnabled()) {                    logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);                }                if (registryURLs != null &amp;&amp; !registryURLs.isEmpty()) {                    for (URL registryURL : registryURLs) {                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));                        URL monitorUrl = loadMonitor(registryURL);                        if (monitorUrl != null) { // 如果有monitor信息，则在url上增加monitor配置                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());                        }                        if (logger.isInfoEnabled()) {                            logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);                        }                        // 重要的第二步了，创建 invoker 对象（这里暴露远程协议里，在远程协议里增加了属性 export=url,url默认dubbo协议暴露地址）                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);                        // 第三步，官方文档加重点的一步，invoker转化为 exporter                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);                        exporters.add(exporter);                    }                } else {                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);                    exporters.add(exporter);                }            }        }        this.urls.add(url);    }</code></pre><h2 id="第二步，ProxyFactory-getInvoker"><a href="#第二步，ProxyFactory-getInvoker" class="headerlink" title="第二步，ProxyFactory.getInvoker"></a>第二步，ProxyFactory.getInvoker</h2><p>在<strong>ServiceConfig#doExportUrlsFor1Protocol</strong>暴露单个地址中的调用:</p><pre><code>Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</code></pre><p>接下来看看这一行代码里做了什么。<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr2vg3gsllj20rw02n0t2.jpg" alt=""></p><p><em>问题二：这个 ProxyFactory$Adaptive是什么东东？</em><br>看看 proxyFactory 是怎么来的。</p><pre><code>private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</code></pre><p>看来是和这个 ExtensionLoader 有关。看看接口:</p><pre><code>@SPI(&quot;javassist&quot;)public interface ProxyFactory {    @Adaptive({Constants.PROXY_KEY})    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException;    @Adaptive({Constants.PROXY_KEY})    &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;}</code></pre><p>@SPI 看起来和java SPI机制有关哦。先留个坑，回头再解决。</p><p>但是通过我们debug发现，默认情况下 ProxyFactory的实现是 JavassistProxyFactory。</p><pre><code>public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) {        // TODO Wrapper cannot handle this scenario correctly: the classname contains &#39;$&#39;        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&#39;$&#39;) &lt; 0 ? proxy.getClass() : type);        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) {            @Override            protected Object doInvoke(T proxy, String methodName,                                      Class&lt;?&gt;[] parameterTypes,                                      Object[] arguments) throws Throwable {                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);            }        };    }</code></pre><p>正如官方文档所说:</p><blockquote><p>首先 ServiceConfig 类拿到对外提供服务的实际类 ref(如：HelloWorldImpl),然后通过 ProxyFactory 类的 getInvoker 方法使用 ref 生成一个 AbstractProxyInvoker 实例，到这一步就完成具体服务到 Invoker 的转化。</p></blockquote><p>JavassistProxyFactory的getInvoker实现是先创建一个包装类Wrapper ，包装类来实现远程调用。简单看下这个包装类是什么吧，Wapper.makeWrapper(Class&lt;?&gt; c):<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr3r8635d5j20tq0gojtu.jpg" alt=""><br>结果大致如下</p><pre><code>public class Wrapper1 extends Wrapper {    public static String[] pns;    public static Map pts;    public static String[] mns; // all method name array.    public static String[] dmns;    public static Class[] mts0;    public String[] getPropertyNames() {        return pns;    }    public boolean hasProperty(String n) {        return pts.containsKey($1);    }    public Class getPropertyType(String n) {        return (Class) pts.get($1);    }    public String[] getMethodNames() {        return mns;    }    public String[] getDeclaredMethodNames() {        return dmns;    }    public void setPropertyValue(Object o, String n, Object v) {        dubbo.provider.hello.service.impl.HelloServiceImpl w;        try {            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);        } catch (Throwable e) {            throw new IllegalArgumentException(e);        }        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);    }    public Object getPropertyValue(Object o, String n) {        dubbo.provider.hello.service.impl.HelloServiceImpl w;        try {            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);        } catch (Throwable e) {            throw new IllegalArgumentException(e);        }        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);    }    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException {        dubbo.provider.hello.service.impl.HelloServiceImpl w;        try {            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);        } catch (Throwable e) {            throw new IllegalArgumentException(e);        }        try {            if (&quot;sayHello&quot;.equals($2) &amp;&amp; $3.length == 0) {                w.sayHello();                return null;            }        } catch (Throwable e) {            throw new java.lang.reflect.InvocationTargetException(e);        }        throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot; + $2 + &quot;\&quot; in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);    }}</code></pre><h2 id="第三步，invoker转化为-exporter"><a href="#第三步，invoker转化为-exporter" class="headerlink" title="第三步，invoker转化为 exporter"></a>第三步，invoker转化为 exporter</h2><p>在<strong>ServiceConfig#doExportUrlsFor1Protocol</strong>暴露单个地址中的调用:</p><pre><code>Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</code></pre><p>由代码可知，这里的 protocol 和第二步里的proxyFactory 一样</p><pre><code>private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code></pre><p>我们再看看 Protocol接口，也是SPI机制：</p><pre><code>@SPI(&quot;dubbo&quot;)public interface Protocol {    int getDefaultPort();    @Adaptive    &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;    @Adaptive    &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;    void destroy();}</code></pre><p>凭感觉会使用dubbo协议调用到DubboProtocol。先debug,果不其然。看一眼调用栈：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr56why7woj20ic0awmyn.jpg" alt=""></p><p>从ServiceConfig之后，有两次协议调用，先是调用RegistryProtocol，然后RegistryProtocol里调用了DubboProtocol。<br>两次暴露协议前，都会调用到 ProtocolListenerWrapper 和 ProtocolFilterWrapper，看看这两个地方。<br><strong>ProtocolListenerWrapper#export</strong>方法</p><pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException {    // registry类型的Invoker，直接暴露    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {        return protocol.export(invoker);    }    // 非Registry类型的Invoker，需要被监听器包装    // 这里的protocol是ProtocolFilterWrapper    return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));}</code></pre><p><strong>ProtocolFilterWrapper#export</strong>方法</p><pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException {    // registry类型的Invoker，直接暴露    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) {        return protocol.export(invoker);    }    //非Registry类型的Invoker需要先构建调用链，然后再暴露    return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));}</code></pre><p>这里构建调用链，控制invoker调用执行顺序，默认的filters如下图：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr5791ve67j208j05v74f.jpg" alt=""><br>暂且不谈Filter接口相关。</p><p>按照调用顺序，先调用 <strong>RegistryProtocol#export</strong></p><pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException {    //export invoker    final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker); // 本地暴露    URL registryUrl = getRegistryUrl(originInvoker); // 获取注册地址，默认是dubbo，我这里使用zookeeper    //registry provider    final Registry registry = getRegistry(originInvoker); // 获取注册中心， 我这里的是ZookeeperRegistry对象    final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);// 获取注册的提供者地址    //to judge to delay publish whether or not    boolean register = registedProviderUrl.getParameter(&quot;register&quot;, true);    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);// 注册提供者消费者。    if (register) {        register(registryUrl, registedProviderUrl); // 注册服务        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true); // 标记为已注册    }    // Subscribe the override data    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);    //保证每次暴露服务返回一个新的exporter    return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);}</code></pre><p>然后，上面的本地暴露 <strong>doLocalExport(originInvoker)</strong> 实际上是暴露的dubbo协议，看下DubboProtocol：</p><pre><code>public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException {    URL url = invoker.getUrl();    // export service.    String key = serviceKey(url); // 获取dubbo协议服务key，serviceGroup/serviceName:serviceVersion:port    DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap);    exporterMap.put(key, exporter);    //export an stub service for dispatching event    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);  // 是否是stub事件？ dubbo.stub.event属性    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false); // 是否回调服务？ is_callback_service属性    if (isStubSupportEvent &amp;&amp; !isCallbackservice) { // TODO 这里暂时不分析，此处demo场景为false        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);        if (stubServiceMethods == null || stubServiceMethods.length() == 0) {            if (logger.isWarnEnabled()) {                logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(Constants.INTERFACE_KEY) +                        &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));            }        } else {            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);        }    }    openServer(url); // 开启服务(这里默认使用netty方式)    optimizeSerialization(url);// 优化序列化    return exporter;}</code></pre><p>至此返回 exporter 之后，就完成了 invoker到exporter的转化。返回到ServiceConfig后服务发布过程到此结束。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="先看看之前遗留的两个问题："><a href="#先看看之前遗留的两个问题：" class="headerlink" title="先看看之前遗留的两个问题："></a>先看看之前遗留的两个问题：</h4><p><em>问题一：AbstractConfig 衍生的子类(ServiceConfig,ProviderConfig,RegistryConfig等) ，这么多的配置类是啥？</em> </p><p><em>问题二：这个 ProxyFactory$Adaptive是什么东东？ 看看 proxyFactory 是怎么来的。</em></p><h4 id="回答问题一："><a href="#回答问题一：" class="headerlink" title="回答问题一："></a>回答问题一：</h4><p>在dubbo-config模块中，代码里的解释已经很清楚了。这里简单介绍几个抽象配置:</p><ul><li>AbstractConfig：配置模板，配置解析的工具方法、公共方法，提供几个主要的方法（appendAnnotation，appendProperties，appendParameters，appendAttributes等）。 </li><li>AbstractMethodConfig：封装了一些方法级别的相关属性 </li><li>AbstractInterfaceConfig：封装了接口需要的属性 </li><li>AbstractReferenceConfig：主要是引用实例的配置</li></ul><p>再看一下dubbo-config-spring模块，与spring如何整合的：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr5fm6vuzfj20i40dwwfj.jpg" alt=""><br>spring.handlers文件里如是写道：</p><pre><code>http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</code></pre><p>dubbo的schema标签的定义就在DubboNamespaceHandler类中:</p><pre><code>public class DubboNamespaceHandler extends NamespaceHandlerSupport {    static {        Version.checkDuplicate(DubboNamespaceHandler.class);    }    public void init() {        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));        registerBeanDefinitionParser(&quot;annotation&quot;, new AnnotationBeanDefinitionParser());    }}</code></pre><p>所以，一目了然。</p><h4 id="回答问题二："><a href="#回答问题二：" class="headerlink" title="回答问题二："></a>回答问题二：</h4><p>这确实和dubbo插件机制有关，后面再单独写一篇文章分析。</p><h4 id="提出问题三-dubbo怎么启动的？"><a href="#提出问题三-dubbo怎么启动的？" class="headerlink" title="提出问题三:dubbo怎么启动的？"></a>提出问题三:dubbo怎么启动的？</h4><p>本文的分析是直接从dubbo文档和启动日志起手的，那么dubbo是怎么从加载spring容器到ServiceConfig暴露服务的呢？</p><p>再回顾看下dubbo暴露服务调用栈：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr5gaayhnwj20y20lcq8q.jpg" alt=""><br>还记得上面的 AbstractConfig家族的类图吗。ServiceBean继承自ServiceConfig。<br>ServiceBean实现了pplicationListener<contextrefreshedevent>接口，实现方法:</contextrefreshedevent></p><pre><code>public void onApplicationEvent(ContextRefreshedEvent event) {    if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) {        if (logger.isInfoEnabled()) {            logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());        }        export(); // 调用父类ServiceConfig的export()    }}</code></pre><p>可见，在spring容器实例化bean完成后，发布ContextRefreshedEvent事件时调用ServiceConfig的export()方法。看看日志是不是有“The service ready on spring started. service:xxx”且在服务暴露日志前呢~</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>至此，初步完成了dubbo服务暴露过程的解析（ServiceConfig-&gt; Invoker-&gt;Exporter），但是上面服务暴露过程有些内容并没有详细分析，比如</p><ul><li>本地暴露与远程暴露的细枝末节</li><li>dubbo的扩展机制</li><li>获取注册中心注册服务（zookeeper）的过程</li><li>开启服务过程(Netty服务)<br>… </li></ul><p>这些后面一点点剖析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>dubbo暴露服务过程总体分为三步：ServiceConfig-&gt; Invoker-&gt;Exporter.</li><li>AbstractConfig家族是spring与dubbo整合的核心配置</li><li>ServiceBean中开启spring容器加载完成后的暴露服务过程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgr6acju4j20m80cijt7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;dubbo框架也用了有一年了，一直没有详细的研究过dubbo源码。所以趁有时间好好学习体会dubbo的博大精深。本人才疏学浅，如有不对，请大神指点。这里使用的dubbo版本是2.6.1。&lt;/p&gt;
&lt;p&gt;如何看源码？跟着&lt;a href=&quot;https://dubbo.apache.org/books/dubbo-dev-book/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo开发手册(中文)&lt;/a&gt;来喽。带着目的看源码，这次看dubbo是怎么暴露服务的。&lt;br&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>使用 Bean Validation 解决业务中参数校验</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbef001nuifndofaacer/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbef001nuifndofaacer/</id>
    <published>2018-05-10T12:26:24.000Z</published>
    <updated>2018-06-08T11:51:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>精简业务中的代码校验。<br><a id="more"></a></p><h2 id="痛点及现状"><a href="#痛点及现状" class="headerlink" title="痛点及现状"></a>痛点及现状</h2><p>代码中常常见到如下代码：</p><pre><code>if (Objects.equal(0L ,repertory)){    return ApiResultMap.errorResult(-1 ,&quot;操作数量不可为0&quot;) ;}</code></pre><p>这种参数校验写在模块里有如下缺点：</p><ul><li>代码冗余</li><li>影响代码可读性</li><li>需要通过注释来知道每个入参的约束是什么。</li><li>每个程序员做参数验证的方式不一样，参数验证不通过抛出的异常也不一样。</li></ul><p><strong>抛出问题</strong>：那么有没有一种方式可以简化代码呢？</p><h2 id="JSR-303-Bean-Validation"><a href="#JSR-303-Bean-Validation" class="headerlink" title="JSR 303 - Bean Validation"></a>JSR 303 - Bean Validation</h2><p>Bean Validation是一个通过配置注解来验证参数的框架，它包含两部分Bean Validation API和Hibernate Validator。</p><ul><li>Bean Validation API是Java定义的一个验证参数的规范。</li><li>Hibernate Validator是Bean Validation API的一个实现。</li></ul><h2 id="QUICK-START"><a href="#QUICK-START" class="headerlink" title="QUICK START"></a>QUICK START</h2><ol><li><p>引入pom</p><pre><code>&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.3.1.Final&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>dto入参对象属性加入注解<br><code>`</code><br>@Data<br>public class ValidDemo {<br> @Size(min = 3, max = 12, message = “用户名必须的长度必须是3到12个字母之间”)<br> @Pattern(regexp = “^[a-z]+$”, message = “用户名必须是a-z小字母”)<br> private String name;</p><p> @Size(min = 6, max = 6, message = “密码必须是6位数字”)<br> @Pattern(regexp = “^[0-9]+$”, message = “密码必须是6位数字”)<br> private String password;</p><p> @Range(min = 1, max = 9, message = “范围只能1到9”)<br> private Integer range;</p><p> @NotNull(message = “邮箱不能为Null”)<br> @Email(regexp = “(?:[a-z0-9!#$%&amp;’<em>+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&amp;’</em>+/=?^_`{|}~-]+)<em>|\”(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])</em>\”)@(?:(?:<a href="?:[a-z0-9-]*[a-z0-9]">a-z0-9</a>?\.)+<a href="?:[a-z0-9-]*[a-z0-9]">a-z0-9</a>?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])”,</p><pre><code>     message = &quot;邮箱格式有误&quot;)</code></pre><p> private String email;</p></li></ol><p>}</p><pre><code>3. controller方法入参加入校验(@Valid)</code></pre><p>@GetMapping(“/validdemo”)<br>public Map&lt;String,Object&gt; demo(@Valid ValidDemo validDemo){<br>    return ApiResultMap.successResult(validDemo);<br>}</p><pre><code>4. 精简出参，加入全局异常处理</code></pre><p>@ExceptionHandler(value = { BindException.class })<br>public Map&lt;String, Object&gt; validationException(BindException ex) {<br>    log.error(ex.getBindingResult().getFieldError().getDefaultMessage());<br>    return ApiResultMap.errorResult(ex.getBindingResult().getFieldError().getDefaultMessage());<br>}</p><pre><code>5. 测试结果：</code></pre><p>$curl <a href="http://localhost:8080/validdemo?email=xxxxx" target="_blank" rel="noopener">http://localhost:8080/validdemo?email=xxxxx</a></p><p>{<br>    “message”: {<br>        “code”: -1,<br>        “message”: “邮箱格式有误”<br>    }<br>}</p><pre><code>**另一种方式，使用 spring 的 @Validated 注解:**1. 配置 MethodValidationPostProcessor</code></pre><pre><code>@Beanpublic MethodValidationPostProcessor methodValidationPostProcessor() {    return new MethodValidationPostProcessor();}</code></pre><pre><code>2. 使用@Validated注解：</code></pre><p>@Validated<br>@RestController<br>public class DemoController {}</p><pre><code>3. 方法上加上校验</code></pre><p>@GetMapping(“/validdemo3”)<br>public Map&lt;String,Object&gt; demo3(@NotNull String str, @NotNull @Range(min = 0, max = 10) Integer a){<br>    return ApiResultMap.successResult(str + a);<br>}</p><pre><code>4. 测试 </code></pre><p>$curl <a href="http://localhost:8080/validdemo?str=1&amp;a=15" target="_blank" rel="noopener">http://localhost:8080/validdemo?str=1&amp;a=15</a><br>{<br>    “message”: {<br>        “code”: 202,<br>        “message”: “需要在0和10之间”<br>    }<br>}<br><code>`</code></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>java程序员张三和ios程序员李四开发某一需求，明天就要demo了，今天得抓紧联调。<br>李四:三哥，地址发下，调试绑卡。<br>张三启动服务…<br>李四：三哥，帮忙看下，这个接口报错 -1，看下上面错误呗。<br>张三打开控制台，看了一下日志与排查，数据库报错，身份证字段没传导致插入身份证为空报错。<br>张三：李四你身份证没传。…张三一边埋怨着一边加入一行if else，同时在思考别的接口是不是也有这种情况，也给加上if else.<br>没过一会儿，李四：三哥，帮我看下有报错-1了。<br>张三又去查看，同样的，这次是银行卡号没传。张三重复着以上操作可没过一会儿李四又….<br>就这样一天过去，伴随着晚霞下班的张三，心情却没那么高兴…</p><p><strong>抛出问题</strong>：是什么导致张三忙碌一天却觉得碌碌无为？是道德的沦丧还是人性的丧失？  </p><p>如果张三整合Bean Validation的话，可能就没有那么不愉快了。他只需要一次在入参model里加入校验，之后在控制器的通过轻松的 @Valid 注解，就可以省去李四重复的提问，也省去的检查其他接口是否也需要添加代码校验，代码又可以少些几行了，何乐而不为。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>Bean Validation 中内置的 constraint：  </p><ul><li>@Null    被注释的元素必须为 null</li><li>@NotNull    被注释的元素必须不为 null</li><li>@AssertTrue    被注释的元素必须为 true</li><li>@AssertFalse    被注释的元素必须为 false</li><li>@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max, min)    被注释的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction)    被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past    被注释的元素必须是一个过去的日期</li><li>@Future    被注释的元素必须是一个将来的日期</li><li>@Pattern(value)    被注释的元素必须符合指定的正则表达式</li></ul><p>Hibernate Validator 附加的 constraint：  </p><ul><li>@Email    被注释的元素必须是电子邮箱地址</li><li>@Length    被注释的字符串的大小必须在指定的范围内</li><li>@NotEmpty    被注释的字符串的必须非空</li><li>@Range    被注释的元素必须在合适的范围内</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>代码整洁</li><li>代码可读性强</li><li>解决不同开发者的不同的校验方式</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推荐使用 Bean Validation 的方式解决业务中参数校验；<br>这里只给出了一些基本的参数校验constraint，在实际业务中可根据业务情形自定义业务constraint。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;p&gt;精简业务中的代码校验。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.chenruiwen.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA神器居然还有这些小技巧</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbdo0008uifn85p3jw2s/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbdo0008uifn85p3jw2s/</id>
    <published>2018-05-08T07:18:24.000Z</published>
    <updated>2018-07-21T10:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgqja29lhj20go0b4tch.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Intellij IDEA，一个开发者甚爱的IDE，用了这么多年，其中有些小Tips你真的了解吗？</p><p>本文转载自<a href="https://blog.csdn.net/linsongbin1" target="_blank" rel="noopener">Sam哥哥聊技术</a>的技术博文。</p><p>原文地址:<a href="https://blog.csdn.net/linsongbin1/article/details/80211919" target="_blank" rel="noopener">https://blog.csdn.net/linsongbin1/article/details/80211919</a><br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Intellij IDEA真是越用越觉得它强大，它总是在我们写代码的时候，不时给我们来个小惊喜。出于对Intellij IDEA的喜爱，我决定写一个与其相关的专栏或者系列，把一些好用的Intellij IDEA技巧分享给大家。本文是这个系列的第一篇，主要介绍一些你可能不知道的但是又实用的小技巧。</p><h2 id="我最爱的【演出模式】"><a href="#我最爱的【演出模式】" class="headerlink" title="我最爱的【演出模式】"></a>我最爱的【演出模式】</h2><p>我们可以使用【Presentation Mode】，将IDEA弄到最大，可以让你只关注一个类里面的代码，进行毫无干扰的coding。</p><p>可以使用<code>Alt+V</code>快捷键，弹出View视图，然后选择<code>Enter Presentation Mode</code>。效果如下：<br><img src="https://img-blog.csdn.net/20180506101049248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>这个模式的好处就是，可以让你更加专注，因为你只能看到特定某个类的代码。可能读者会问，进入这个模式后，我想看其他类的代码怎么办？这个时候，就要考验你快捷键的熟练程度了。你可以使<code>用CTRL+E</code>弹出最近使用的文件。又或者使用<code>CTRL+N</code>和<code>CTRL+SHIFT+N</code>定位文件。</p><p>如何退出这个模式呢？很简单，使用<code>ALT+V</code>弹出view视图，然后选择<code>Exit Presentation Mode</code> 即可。但是我强烈建议你不要这么做，因为你是可以在<code>Enter Presentation Mode</code>模式下在IDEA里面做任何事情的。当然前提是，你对IDEA足够熟练。</p><h2 id="神奇的Inject-language"><a href="#神奇的Inject-language" class="headerlink" title="神奇的Inject language"></a>神奇的Inject language</h2><p>如果你使用IDEA在编写<code>JSON</code>字符串的时候，然后要一个一个\去转义双引号的话，就实在太不应该了，又烦又容易出错。在IDEA可以使用<code>Inject language</code>帮我们自动转义双引号。<br><img src="https://img-blog.csdn.net/20180506102510207?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>先将焦点定位到双引号里面，使用<code>alt+enter</code>快捷键弹出<code>inject language</code>视图，并选中<br><code>Inject language or reference</code>。<br><img src="https://img-blog.csdn.net/20180506103121907?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>选择后,切记，要直接按下<code>enter</code>回车键，才能弹出<code>inject language</code>列表。在列表中选择json组件。<br><img src="https://img-blog.csdn.net/20180506103545731?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>选择完后。鼠标焦点自动会定位在双引号里面，这个时候你再次使用<code>alt+enter</code>就可以看到 </p><p><img src="https://img-blog.csdn.net/20180506104023832?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>选中<code>Edit JSON Fragment</code>并回车，就可以看到编辑JSON文件的视图了。<br><img src="https://img-blog.csdn.net/20180506104257350?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>可以看到IDEA确实帮我们自动转义双引号了。如果要退出编辑JSON信息的视图，只需要使用<code>ctrl+F4</code>快捷键即可。</p><p><code>Inject language</code>可以支持的语言和操作多到你难以想象，读者可以自行研究。</p><h2 id="使用快捷键移动分割线"><a href="#使用快捷键移动分割线" class="headerlink" title="使用快捷键移动分割线"></a>使用快捷键移动分割线</h2><p>假设有下面的场景，某个类的名字在<code>project</code>视图里被挡住了某一部分。<br><img src="https://img-blog.csdn.net/2018050610490590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>你想完整的看到类的名字，该怎么做。一般都是使用鼠标来移动分割线，但是这样子效率太低了。可以使用<code>alt+1</code>把鼠标焦点定位到<code>project</code>视图里，然后直接使用<code>ctrl+shift+左右箭头</code>来移动分割线。</p><h2 id="ctrl-shift-enter不只是用来行尾加分号的"><a href="#ctrl-shift-enter不只是用来行尾加分号的" class="headerlink" title="ctrl+shift+enter不只是用来行尾加分号的"></a>ctrl+shift+enter不只是用来行尾加分号的</h2><p><code>ctrl+shift+enter</code>其实是表示为您收尾的意思，不只是用来给代码加分号的。比如说：<br><img src="https://img-blog.csdn.net/20180506105438146?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>这段代码，我们还需要为if语句加上大括号才能编译通过，这个时候你直接输入<code>ctrl+shift+enter</code>，IDEA会自动帮你收尾，加上大括号的。</p><h2 id="不要动不动就使用IDEA的重构功能"><a href="#不要动不动就使用IDEA的重构功能" class="headerlink" title="不要动不动就使用IDEA的重构功能"></a>不要动不动就使用IDEA的重构功能</h2><p>IDEA的重构功能非常强大，但是也有时候，在单个类里面，如果只是想批量修改某个文本，大可不必使用到重构的功能。比如说：<br><img src="https://img-blog.csdn.net/20180506111208407?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>上面的代码中，有5个地方用到了rabbitTemplate文本，如何批量修改呢？<br>首先是使用<code>ctrl+w</code>选中<code>rabbitTemplate</code>这个文本,然后依次使用5次<code>alt+j</code>快捷键，逐个选中，这样五个文本就都被选中并且高亮起来了，这个时候就可以直接批量修改了。<br><img src="https://img-blog.csdn.net/20180506111615984?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="去掉导航栏"><a href="#去掉导航栏" class="headerlink" title="去掉导航栏"></a>去掉导航栏</h2><p>去掉导航栏，因为平时用的不多。<br><img src="https://img-blog.csdn.net/20180506111913289?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>可以把红色的导航栏去掉，让IDEA显得更加干净整洁一些。使用<code>alt+v</code>，然后去掉<code>Navigation bar</code>即可。去掉这个导航栏后，如果你偶尔还是要用的，直接用<code>alt+home</code>就可以临时把导航栏显示出来。 </p><p><img src="https://img-blog.csdn.net/20180506112253301?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果想让这个临时的导航栏消失的话，直接使用esc快捷键即可。</p><h2 id="把鼠标定位到project视图里"><a href="#把鼠标定位到project视图里" class="headerlink" title="把鼠标定位到project视图里"></a>把鼠标定位到project视图里</h2><p>当工程里的包和类非常多的时候，有时候我们想知道当前类在project视图里是处在哪个位置。 </p><p><img src="https://img-blog.csdn.net/20180506112922875?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>上面图中的DemoIDEA里，你如何知道它是在spring-cloud-config工程里的哪个位置呢？<br>可以先使用<code>alt+F1</code>，弹出<code>Select in</code>视图，然后选择<code>Project View</code>中的<code>Project</code>，回车，就可以立刻定位到类的位置了。</p><p><img src="https://img-blog.csdn.net/20180506113149744?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>那如何从<code>project</code>跳回代码里呢？可以直接使用<code>esc</code>退出<code>project</code>视图，或者直接使用<code>F4</code>,跳到代码里。</p><h2 id="强大的symbol"><a href="#强大的symbol" class="headerlink" title="强大的symbol"></a>强大的symbol</h2><p>如果你依稀记得某个方法名字几个字母，想在IDEA里面找出来，可以怎么做呢？<br>直接使用ctrl+shift+alt+n，使用symbol来查找即可。<br>比如说：<br><img src="https://img-blog.csdn.net/20180506114420813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>你想找到checkUser方法。直接输入<code>user</code>即可。<br><img src="https://img-blog.csdn.net/20180506114545585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果你记得某个业务类里面有某个方法，那也可以使用首字母找到类,然后加个 <code>.</code> ，再输入方法名字也是可以的。 </p><p><img src="https://img-blog.csdn.net/20180506114751563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="如何找目录"><a href="#如何找目录" class="headerlink" title="如何找目录"></a>如何找目录</h2><p>使用<code>ctrl+shift+n</code>后，使用 <code>/</code>，然后输入目录名字即可。<br><img src="https://img-blog.csdn.net/20180506115258400?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="自动生成not-null判断语句"><a href="#自动生成not-null判断语句" class="headerlink" title="自动生成not null判断语句"></a>自动生成not null判断语句</h2><p>自动生成not null这种if判断，在IDEA里有很多种办法，其中一种办法你可能没想到。<br><img src="https://img-blog.csdn.net/20180506121917448?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>当我们使用<code>rabbitTemplate</code>. 后，直接输入<code>notnull</code>并回车，IDEA就好自动生成if判断了。 </p><p><img src="https://img-blog.csdn.net/20180506122137443?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="按照模板找内容"><a href="#按照模板找内容" class="headerlink" title="按照模板找内容"></a>按照模板找内容</h2><p>这个也是我非常喜欢的一个功能，可以根据模板来找到与模板匹配的代码块。比如说：</p><blockquote><p>想在整个工程里面找到所有的try catch语句,但是catch语句里面没有做异常处理的。</p></blockquote><p>catch语句里没有处理异常，是极其危险的。我们可以IDEA里面方便找到所有这样的代码。</p><p><img src="https://img-blog.csdn.net/20180506130226135?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>首先使用<code>ctrl+shift+A</code>快捷键弹出action框，然后输入<code>Search Struct</code> 。<br><img src="https://img-blog.csdn.net/20180506130444300?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>选择<code>Search Structurally</code>后，回车，跳转到模板视图。 </p><p><img src="https://img-blog.csdn.net/20180506130624611?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>点击<code>Existing Templates</code>按钮，选择<code>try</code>模板。为了能找出<code>catch</code>里面没有处理异常的代码块，我们需要配置一下<code>CatchStatement</code>的<code>Maximum count</code>的值，将其设置为1。</p><p>点击<code>Edit Variables</code>按钮，在界面修改<code>Maximum count</code>的值。 </p><p><img src="https://img-blog.csdn.net/20180506131057131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>最后点击<code>find</code>按钮，就可以找出catch里面没有处理异常的代码了。 </p><p><img src="https://img-blog.csdn.net/20180506131239122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>感谢 <a href="https://blog.csdn.net/linsongbin1" target="_blank" rel="noopener">Sam哥哥聊技术</a> 的分享！</p><p>此篇文章是收藏级别的文章，多学多用，才能使coding效率大大的提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgqja29lhj20go0b4tch.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Intellij IDEA，一个开发者甚爱的IDE，用了这么多年，其中有些小Tips你真的了解吗？&lt;/p&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://blog.csdn.net/linsongbin1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sam哥哥聊技术&lt;/a&gt;的技术博文。&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://blog.csdn.net/linsongbin1/article/details/80211919&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/linsongbin1/article/details/80211919&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Intellij IDEA" scheme="http://www.chenruiwen.cn/categories/Intellij-IDEA/"/>
    
    
      <category term="转载摘抄" scheme="http://www.chenruiwen.cn/tags/%E8%BD%AC%E8%BD%BD%E6%91%98%E6%8A%84/"/>
    
      <category term="Intellij IDEA" scheme="http://www.chenruiwen.cn/tags/Intellij-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自定义安装Mysql全记录</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbec001iuifn4i7tb0mb/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbec001iuifn4i7tb0mb/</id>
    <published>2018-04-22T12:18:49.000Z</published>
    <updated>2018-06-27T23:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下MySQL 5.7版本的安装过程。<br><a id="more"></a></p><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><p>零. 参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html" target="_blank" rel="noopener">官方文档</a></p><p>一. 下载mysql二进制文件，进入页面：    <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a><br>Select Operating System: Linux-Generic<br>并下载</p><p>二. 切换到root用户创建group和user</p><pre><code>root@chenruiwen:/data/mysql# groupadd mysqlroot@chenruiwen:/data/mysql# useradd -r -g mysql dba -s /bin/false mysql</code></pre><p>三. 解压下载的Mysql,重命名</p><pre><code>root@chenruiwen:/data/mysql# tar -xf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gzroot@chenruiwen:/data/mysql# mv mysql-5.7.21-linux-glibc2.12-x86_64 mysql-5.7.21</code></pre><p>四. 赋予mysql操作权限</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# chown -R dba /data/mysql/mysql-5.7.21root@chenruiwen:/data/mysql/mysql-5.7.21# chgrp -R mysql /data/mysql/mysql-5.7.21root@chenruiwen:/data/mysql/mysql-5.7.21# mkdir mysql-filesroot@chenruiwen:/data/mysql/mysql-5.7.21# chown dba:mysql mysql-files/root@chenruiwen:/data/mysql/mysql-5.7.21# chmod 750 mysql-files</code></pre><p>五. 初始化Mysql</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysqld --initialize --user=dbamysqld: Can&#39;t create directory &#39;/usr/local/mysql/data/&#39; (Errcode: 2 - No such file or directory)2018-04-08T15:25:22.856110Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2018-04-08T15:25:22.856195Z 0 [ERROR] Can&#39;t find error-message file &#39;/usr/local/mysql/share/errmsg.sys&#39;. Check error-message file location and &#39;lc-messages-dir&#39; configuration directive.2018-04-08T15:25:22.856935Z 0 [ERROR] Abortingroot@chenruiwen:/data/mysql/mysql-5.7.21#</code></pre><p>提示目录不存在，因为我的mysql目录是在/data/mysql/mysql-5.7.21</p><p>所以，要指定数据目录和basedir并初始化。</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# mkdir dataroot@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysqld --user=dba --basedir=/data/mysql/mysql-5.7.21 --datadir=/data/mysql/mysql-5.7.21/data/  --initialize-insecure2018-04-28T03:12:52.827802Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).2018-04-28T03:12:53.883717Z 0 [Warning] InnoDB: New log files created, LSN=457902018-04-28T03:12:54.084754Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2018-04-28T03:12:54.150087Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 0aca257d-4a92-11e8-af3b-00163e089ff5.2018-04-28T03:12:54.153185Z 0 [Warning] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2018-04-28T03:12:54.153653Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.</code></pre><p>这里我使用了 <strong>–initialize-insecure</strong> 参数，不设置root密码。<br>如果是 <strong>–initialize</strong> ，会随机生成一个密码。</p><p>六. 开启SSL，生成密钥文件</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysql_ssl_rsa_setup2018-04-28 11:21:57 [ERROR]   Failed to access directory pointed by --datadir. Please make sure that directory exists and is accessible by mysql_ssl_rsa_setup. Supplied value : /usr/local/mysql/data</code></pre><p>报错,需要修改配置文件。修改 /etc/my.cnf –datadir 属性,创建 my.cnf</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# vi /etc/my.cnf</code></pre><p>MySQL配置文件简单版：</p><pre><code>[mysqld]# GENERALcharacter-set-server=utf8symbolic-links=0basedir=/data/mysql/mysql-5.7.21datadir=/data/mysql/mysql-5.7.21/datasocket=/tmp/mysql.sockuser=dbaport=3306pid-file=/data/mysql/mysql-5.7.21/data/mysql.piddefault_storage_engine=InnoDB#LOGGINGlog_error=/data/mysql/mysql-5.7.21/log/mysql-error.log#OTHERopen_files_limit=65535[client]socket=/tmp/mysql.sockport=3306[mysqld_safe]log-error=/data/mysql/mysql-5.7.21/log/mysql-error.logpid-file=/data/mysql/mysql-5.7.21/data/mysql.pid</code></pre><p>定义的日志目录和文件手工创建一下，然后重新运行：</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysql_ssl_rsa_setupGenerating a 2048 bit RSA private key............................................+++........................+++writing new private key to &#39;ca-key.pem&#39;-----Generating a 2048 bit RSA private key....................................+++.................+++writing new private key to &#39;server-key.pem&#39;-----Generating a 2048 bit RSA private key..............................................................................+++..........................................+++writing new private key to &#39;client-key.pem&#39;-----root@chenruiwen:/data/mysql/mysql-5.7.21# </code></pre><p>更多开启SSL相关请参考官方文档:<a href="https://dev.mysql.com/doc/refman/5.7/en/creating-ssl-rsa-files.html" target="_blank" rel="noopener"><br>Creating SSL and RSA Certificates and Keys</a><br>七. 安全启动MySQL服务</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysqld_safe --user=dba &amp;</code></pre><p>查看MySQL服务进程</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# ps -ef|grep mysqlroot     14899 11849  0 15:20 pts/0    00:00:00 /bin/sh bin/mysqld_safe --user=dbadba      15135 14899  0 15:20 pts/0    00:00:00 /data/mysql/mysql-5.7.21/bin/mysqld --basedir=/data/mysql/mysql-5.7.21 --datadir=/data/mysql/mysql-5.7.21/data --plugin-dir=/data/mysql/mysql-5.7.21/lib/plugin --user=dba --log-error=/data/mysql/mysql-5.7.21/log/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql-5.7.21/data/mysql.pid --socket=/tmp/mysql.sock --port=3306root     15201 11849  0 15:27 pts/0    00:00:00 grep --color=auto mysql</code></pre><p>启动成功。</p><p>八. (可选项)加到系统服务</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# cp support-files/mysql.server /etc/init.d/mysql.server</code></pre><p>修改 mysqld 文件里的 basedir，datadir， mysqld_pid_file_path属性</p><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# mysql -uroot -pThe program &#39;mysql&#39; can be found in the following packages: * mysql-client-core-5.7 * mariadb-client-core-10.0Try: apt install &lt;selected package&gt;</code></pre><p>安装客户端</p><pre><code>root@chenruiwen:/data/mysql/mysql-5.7.21# apt-get updateroot@chenruiwen:/data/mysql/mysql-5.7.21# apt-get install mysql-client-core-5.7</code></pre><p>安装完成后重新连接MySQL，输入密码时直接回车，登录成功。</p><p>修改 root 密码：</p><pre><code>mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; update user set authentication_string = password(&#39;123456&#39;), password_expired = &#39;N&#39;, password_last_changed = now() where user = &#39;root&#39;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 1</code></pre><p>退出，重启即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记录一下MySQL 5.7版本的安装过程。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/tags/mysql/"/>
    
      <category term="运维" scheme="http://www.chenruiwen.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>java8实战学习总结</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbe1000ruifnuttwnjcu/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbe1000ruifnuttwnjcu/</id>
    <published>2018-04-21T15:38:49.000Z</published>
    <updated>2018-07-21T10:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java8作为一次大的升级，语法层面上有很大的改变，于是，来尝尝Java8的鲜。(ps: 哈哈，java10都出了，java8还不熟咋办呢~ 学学吧~)</p><a id="more"></a><h2 id="为什么要用Java8"><a href="#为什么要用Java8" class="headerlink" title="为什么要用Java8"></a>为什么要用Java8</h2><ul><li><strong>elasticsearch:</strong> Elasticsearch requires Java 8 or later. Use the official Oracle distribution or an open-source distribution such as OpenJDK.</li><li><strong>dubbo:</strong> Requires JDK1.8+, if you use lower version, see 1.6+, use 2.5.5</li><li><strong>spring:</strong> JDK 8+ for Spring Framework 5.x<br>……</li></ul><p>很多主流框架已经使用java8进行升级开发，java8是趋势，是时候一起拥抱java8了.</p><h2 id="java8语言新特性"><a href="#java8语言新特性" class="headerlink" title="java8语言新特性"></a>java8语言新特性</h2><ul><li>函数式编程</li><li>Lambda表达式</li><li>接口的默认方法和静态方法</li><li>stream API</li><li>新的类库：Optional,Streams,Date/Time API (JSR 310)…</li><li>JVM新特性</li></ul><h3 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h3><p>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。</p><h4 id="1-1-lambda的基本语法是："><a href="#1-1-lambda的基本语法是：" class="headerlink" title="1.1 lambda的基本语法是："></a>1.1 lambda的基本语法是：</h4><pre><code>(parameters) -&gt; expression</code></pre><p>或者</p><pre><code>(parameters) -&gt; { statements; }</code></pre><p>eg:java8中有效的lambda表达式：</p><ol><li><p>一个String类型的参数并返回一个int。Lambda中没有return语句，因为已经隐含了return。</p><pre><code>(String s) -&gt; s.length()</code></pre></li><li><p>两个int类型的参数而没有返回值。</p><pre><code>(int x, int y) -&gt; { System.out.println(&quot;Result:&quot;); System.out.println(x+y);}</code></pre></li><li>没有参数，返回一个int<pre><code>() -&gt; 1</code></pre><h4 id="1-2-函数式接口"><a href="#1-2-函数式接口" class="headerlink" title="1.2 函数式接口"></a>1.2 函数式接口</h4></li></ol><ul><li>函数式接口(函数式接口就是只定义一个抽象方法的接口)</li><li>函数描述符(函数式接口的抽象方法的签名 就是 lambda表达式的签名)</li></ul><p>java8中接口的变化:<br>Java 8用<strong>默认方法</strong>与<strong>静态方法</strong>这两个新概念来扩展接口的声明。<br>此功能是为了向后兼容性增加，使旧接口可用于利用JAVA8，lambda表达式的能力<br>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。</p><p>在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。</p><p>目前已存在的函数式接口有：Comparable、Runnable和Callable等。<br>java8在java.util.function中有引入了很多个新的函数式接口:</p><ul><li>Predicate<t>  输入参数为类型T， 输出为类型boolean， 记作 T -&gt; boolean</t></li><li>Consumer<t>  输入参数为类型T， 输出为void， 记作 T -&gt; void</t></li><li>Function&lt;T,R&gt;   输入参数为类型T， 输出为类型R， 记作 T -&gt; R </li><li>Supplier<t>   没有输入参数， 输出为类型T， 记作 void -&gt; T<br>…</t></li></ul><h4 id="1-3方法引用"><a href="#1-3方法引用" class="headerlink" title="1.3方法引用"></a>1.3方法引用</h4><p>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。<br>当你需要使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。</p><p><strong>三种方法引用：</strong> </p><ol><li>指向静态方法的方法引用。<br>lambda表达式:   (args) -&gt; ClassName.staticMethod(args)<br>方法引用:       ClassName::staticMethod</li></ol><p>比如</p><pre><code>s -&gt; Integer.valueOf(s) 等价于 Integer::valueOf</code></pre><ol start="2"><li>指向任意类型实例方法的方法引用。<br>lambda表达式:   (arg0, rest) -&gt; arg0.instanceMethod(rest)<br>方法引用:       ClassName::instanceMethod<br>(上面args0是ClassName类型的)</li></ol><p>比如</p><pre><code>(str, integer) -&gt; str.substring(integer) 等价于 String::substring</code></pre><ol start="3"><li>指向现有对象的实例方法的方法引用。<br>lambda表达式:   (args) -&gt; expr.instanceMethod(args)<br>方法引用:       expr::instanceMethod</li></ol><p>比如</p><pre><code>(Apple arg) -&gt; appleExpr.compareAppleWight(arg) 等价于 appleExpr::compareAppleWight</code></pre><ul><li>构造函数的方法引用。<br>对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用：<br>ClassName::new。它的功能与指向静态方法的引用类似。</li></ul><p>比如创建一个Apple对象。<br>空参构造器Apple()：</p><pre><code>Supplier&lt;Apple&gt; c1 = Apple::new;Apple a1 = c1.get();等价于Supplier&lt;Apple&gt; c1 = () -&gt; new Apple();Apple a1 = c1.get();</code></pre><p>两个参数的构造函数Apple(String color, Integer weight)：</p><pre><code>BiFunction&lt;Integer, String, Apple&gt; biFunction = Apple::new;Apple apple2 = biFunction.apply(155, &quot;green&quot;);等价于BiFunction&lt;Integer, String, Apple&gt; biFunction = (weight, color) -&gt; new Apple(weight, color);Apple apple2 = biFunction.apply(155, &quot;green&quot;);</code></pre><h4 id="1-4-复合lambda表达式"><a href="#1-4-复合lambda表达式" class="headerlink" title="1.4 复合lambda表达式"></a>1.4 复合lambda表达式</h4><ol><li>比较器(Comparator<t>)复合(reversed(),thenComparing())</t></li><li>谓词(Predicate<t>)复合(negate(),and(),or())</t></li><li>函数(Function&lt;T, V&gt;)复合(compose(),andThen(),identity())</li></ol><h3 id="2-Stream-API"><a href="#2-Stream-API" class="headerlink" title="2.Stream API"></a>2.Stream API</h3><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</p><p>Stream API(java.util.stream.*)可以让你的代码具备：</p><ul><li>声明性：更简洁，更易读</li><li>可复合：更灵活</li><li>可并行：性能更好</li></ul><h4 id="2-1-什么是流"><a href="#2-1-什么是流" class="headerlink" title="2.1 什么是流"></a>2.1 什么是流</h4><p>流不是一种数据结构，而是处理集合元素的相关计算，更像一个高级的 Iterator。单向，不可往复，数据只能遍历一次。</p><p><strong>如何使用流？</strong>  </p><ol><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ol><h4 id="2-2-使用流"><a href="#2-2-使用流" class="headerlink" title="2.2 使用流"></a>2.2 使用流</h4><ul><li>筛选、切片和匹配</li><li>查找、匹配和归约</li><li>使用数值范围等数值流</li><li>从多个源创建流</li><li>无限流</li></ul><h5 id="2-2-1-筛选，切片"><a href="#2-2-1-筛选，切片" class="headerlink" title="2.2.1 筛选，切片"></a>2.2.1 筛选，切片</h5><ul><li>filter  (筛选过滤)</li><li>distinct (去重)</li><li>limit (截取)</li><li>skip  (跳过)</li></ul><h5 id="2-2-2-映射"><a href="#2-2-2-映射" class="headerlink" title="2.2.2 映射"></a>2.2.2 映射</h5><ul><li>map (映射:接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素)</li><li>flatMap (flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。)</li></ul><h5 id="2-2-3-查找和匹配"><a href="#2-2-3-查找和匹配" class="headerlink" title="2.2.3 查找和匹配"></a>2.2.3 查找和匹配</h5><ul><li>anyMatch (检查谓词是否至少匹配一个元素)</li><li>allMatch (检查谓词是否匹配所有元素)</li><li>noneMatch (检查是否没有任何元素与给定的谓词匹配)</li><li>findAny (返回当前流中的任意元素Optional<t>。它可以与其他流操作结合使用。)</t></li><li>findFirst (返回流中第一个元素Optional<t>)</t></li></ul><h5 id="2-2-4-reduce"><a href="#2-2-4-reduce" class="headerlink" title="2.2.4 reduce"></a>2.2.4 reduce</h5><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p><ul><li>Optional<t> reduce(BinaryOperator<t> accumulator);</t></t></li><li>T reduce(T identity, BinaryOperator<t> accumulator);</t></li><li>U reduce(U identity,BiFunction&lt;U, ? super T, U&gt;      accumulator,BinaryOperator&lt; U &gt; combiner);</li></ul><h5 id="2-2-5-数值流"><a href="#2-2-5-数值流" class="headerlink" title="2.2.5 数值流"></a>2.2.5 数值流</h5><ul><li>IntStream</li><li>DoubleStream</li><li>LongStream</li></ul><h5 id="2-2-6-创建流"><a href="#2-2-6-创建流" class="headerlink" title="2.2.6 创建流"></a>2.2.6 创建流</h5><ul><li>由值创建流(Stream.of)</li><li>由数组创建流(Arrays.stream(array))</li><li>由文件生成流(java.nio.file.Files)</li><li>由函数生成流：创建无限流(Stream.iterate和Stream.generate) </li></ul><h5 id="2-3-收集器"><a href="#2-3-收集器" class="headerlink" title="2.3 收集器"></a>2.3 收集器</h5><ul><li>用Collectors类创建和使用收集器</li><li>将数据流归约为一个值</li><li>汇总：归约的特殊情况</li><li>数据分组和分区</li><li>自定义收集器</li></ul><h6 id="2-3-1-归约和汇总"><a href="#2-3-1-归约和汇总" class="headerlink" title="2.3.1 归约和汇总"></a>2.3.1 归约和汇总</h6><p>Stream.reduce 与 Stream.collect的区别：<br>Stream.reduce，常用的方法有average, sum, min, max, and count，返回单个的结果值，并且reduce操作每处理一个元素总是创建一个新值。<br>Stream.collect修改现存的值，而不是每处理一个元素，创建一个新值。</p><h6 id="2-3-2-数据分组"><a href="#2-3-2-数据分组" class="headerlink" title="2.3.2 数据分组"></a>2.3.2 数据分组</h6><ul><li>一级分组<pre><code>Map&lt;Dish.Type, List&lt;Dish&gt;&gt; groupByType = menuList.stream().collect(groupingBy(Dish::getType));</code></pre></li><li>多级分组<pre><code>Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; groupByTypeAndCalories = menuList.stream().collect(          groupingBy(Dish::getType,                  groupingBy(dish -&gt; {                      if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;                      else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;                      else return CaloricLevel.FAT;                  }))  );</code></pre></li><li>按子组收集数据<pre><code>Map&lt;Dish.Type, Long&gt; groupByTypeToCount = menuList.stream().collect(groupingBy(Dish::getType, counting()));</code></pre></li><li>分区(分区是一种特殊的分组，结果map至少包含两个不同的分组——一个true，一个false。)<pre><code>Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionByVegeterian =              menuList.stream().collect(partitioningBy(Dish::isVegetarian));</code></pre><h6 id="2-3-3-Collector接口"><a href="#2-3-3-Collector接口" class="headerlink" title="2.3.3 Collector接口"></a>2.3.3 Collector接口</h6></li></ul><pre><code>public interface Collector&lt;T, A, R&gt; {    Supplier&lt;A&gt; supplier()    BiConsumer&lt;A, T&gt; accumulator()    Function&lt;A, R&gt; finisher()    BinaryOperator&lt;A&gt; combiner()    Set&lt;Characteristics&gt; characteristics()}</code></pre><p>Collector接口的三个泛型：</p><ul><li>T：stream在调用collect方法收集前的数据类型</li><li>A：A是T的累加器，遍历T的时候，会把T按照一定的方式添加到A中，换句话说就是把一些T通过一种方式变成A</li><li>R：R可以看成是A的累加器，是最终的结果，是把A汇聚之后的数据类型，换句话说就是把一些A通过一种方式变成R</li></ul><p>通过自定义ToList收集器理解接口方法：</p><ul><li><p>Supplier<a> supplier()<br>怎么创建一个累加器（这里对应的是如何创建一个List）</a></p></li><li><p>BiConsumer&lt;A, T&gt; accumulator()<br>怎么把一个对象添加到累加器中（这里对应的是如何在List里添加一个对象，当然是调用add方法）</p></li><li><p>Function&lt;A, R&gt; finisher()<br>其实就是怎么把A转化为R，由于是toList，所以A和R是一样的类型，这里其实用就是Function.identity</p></li><li><p>BinaryOperator<a> combiner()<br>它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并（这里对应的是如何把List和List合并起来，当然是调用addAll，这里由于最终要返回List，所以A和R是一个类型，都是List所以才调用addAll）</a></p></li><li><p>Set<characteristics> characteristics()<br>会返回一个不可变的Characteristics集合，它定义<br>了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示，toList这里只用了Characteristics.IDENTITY_FINISH</characteristics></p></li></ul><h5 id="2-4-并行数据处理"><a href="#2-4-并行数据处理" class="headerlink" title="2.4 并行数据处理"></a>2.4 并行数据处理</h5><p><strong>并行流：</strong><br>可以通过对收集源调用parallelStream方法来把集合转换为并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p><p><strong>问题:并行流用的线程是从哪儿来的？有多少个？怎么自定义这个过程呢？</strong><br>并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available-Processors()得到的。<br>但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism 来改变线程池大小，如下所示：<br>System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”);<br>这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议你不要修改它。</p><p><strong>使用并行流：</strong><br>本地测试的过程中，并行流比顺序流效果差。原因可能与机器，处理的数据量，使用并行流的方式等有关系。  </p><p>是否使用并行流需考虑如下几种情况：</p><ol><li>留意装箱。(使用（IntStream、LongStream、DoubleStream来避免装箱拆箱)</li><li>有些操作本身在并行流上的性能就比顺序流差。(limit,findFirst等依赖于元素顺序的操作)</li><li>考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。</li><li>数据量较小的情况不适合并行流。</li><li>考虑流背后的数据结构是否易于分解。</li><li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。</li><li>考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。</li></ol><p>流的数据源<br>源 | 可分解性<br>—|—<br>ArrayList | 极佳<br>LinkedList | 差<br>IntStream.range | 极佳<br>Stream.iterate | 差<br>HashSet | 好<br>TreeSet | 好</p><h3 id="3-Optional使用"><a href="#3-Optional使用" class="headerlink" title="3.Optional使用"></a>3.Optional使用</h3><ul><li>使用Optional避免null引用</li><li>整洁代码中对null的检查</li><li>Optional的使用</li></ul><p>java中的null带来了种种问题：典型常见，使代码膨胀，自身无意义等等等。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>empty</td><td>返回一个空的Optional 实例</td></tr><tr><td>filter</td><td>如果值存在并且满足提供的谓词，就返回包含该值的Optional 对象；否则返回一个空的Optional 对象</td></tr><tr><td>flatMap</td><td>如果值存在，就对该值执行提供的mapping函数调用，返回一个Optional 类型的值，否则就返回一个空的Optional 对象</td></tr><tr><td>get</td><td>如果该值存在，将该值用Optional封装返回，否则抛出一个NoSuchElementException 异常</td></tr><tr><td>ifPresent</td><td>如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td>isPresent</td><td>如果值存在就返回true，否则返回false</td></tr><tr><td>map</td><td>如果值存在，就对该值执行提供的mapping 函数调用</td></tr><tr><td>of</td><td>将指定值用Optional封装之后返回，如果该值为null，则抛出一个NullPointerException异常</td></tr><tr><td>ofNullable</td><td>将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional 对象</td></tr><tr><td>orElse</td><td>如果有值则将其返回，否则返回一个默认值</td></tr><tr><td>orElseGet</td><td>如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr><tr><td>orElseThrow</td><td>如果有值则将其返回，否则抛出一个由指定的Supplier接口生成的异常</td></tr></tbody></table><p>注意：Optional 无法序列化</p><h3 id="4-新的日期和时间API"><a href="#4-新的日期和时间API" class="headerlink" title="4.新的日期和时间API"></a>4.新的日期和时间API</h3><p>新的 java.time 中包含了所有关于：<br>时钟（Clock）、本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。  </p><p>历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。<br>目前Java8新增了java.time包定义的类表示日期-时间概念的规则，很方便使用；最重要的一点是<strong>值不可变，且线程安全</strong>。</p><p>本地日期时间API:</p><ul><li>LocalDate(年月日)</li><li>LocalTime(时分秒)</li><li>localDateTime(年月日时分秒)</li></ul><p>时区API：</p><ul><li>ZonedDateTime</li></ul><p>时钟API：</p><ul><li>Clock</li></ul><p>计算日期时间差API：</p><ul><li>Period(处理有关基于时间的日期数量。)</li><li>Duration(处理有关基于时间的时间量。)</li></ul><p>时间格式化API</p><ul><li>DateTimeFormatter(DateTimeFormatter实例都是线程安全<br>的)</li></ul><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><ol><li>java类库标准base64编码使用方式:<br><code>`</code><br>final String text = “测试Abc123!!￥￥”;<br>final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8));<br>System.out.println(encoded); // 5rWL6K+VQWJjMTIzISHvv6Xvv6U=<br>final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);<br>System.out.println(decoded); // 测试Abc123!!￥￥</li></ol><p>// url encode<br>final String url = “<a href="https://www.chenruiwen.cn/abc?foo=中文&amp;￥%&amp;bar=hello123&amp;baz=https://abc/def123&quot;">https://www.chenruiwen.cn/abc?foo=中文&amp;￥%&amp;bar=hello123&amp;baz=https://abc/def123&quot;</a>;<br>final String encoded2 = Base64.getUrlEncoder().encodeToString(url.getBytes(StandardCharsets.UTF_8));<br>System.out.println(encoded2); // aHR0cDovL3d3dy5qaW5odWkzNjUuY29tL2FiYz9mb2895Lit5paHJu-_pSUmYmFyPWhlbGxvMTIzJmJhej1odHRwOi8vYWJjL2RlZjEyMw==<br>final String decoded2 = new String(Base64.getUrlDecoder().decode(encoded2), StandardCharsets.UTF_8);<br>System.out.println(decoded2); // <a href="https://www.chenruiwen.cn/abc?foo=中文&amp;￥%&amp;bar=hello123&amp;baz=https://abc/def123">https://www.chenruiwen.cn/abc?foo=中文&amp;￥%&amp;bar=hello123&amp;baz=https://abc/def123</a></p><p><code>`</code></p><ol start="2"><li>jvm的变化:<br>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。  JVM选项    -XX:PermSize与-XX:MaxPermSize分别被<br>-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Java8 作为 Java 语言的一次重大发布，包含语法上的更改、新的方法与数据类型，以及一些能默默提升应用性能的隐性改善。而且java8有利于提高开发生产力，对于开发者来说是好事，也是趋势。但是生产中使用java8可能存在风险，在正式使用Java8之前，不妨先体验一下java8的神奇。</p><p>附《java8 in action》源码:<a href="https://github.com/java8/Java8InAction.git" target="_blank" rel="noopener">https://github.com/java8/Java8InAction.git</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;java8作为一次大的升级，语法层面上有很大的改变，于是，来尝尝Java8的鲜。(ps: 哈哈，java10都出了，java8还不熟咋办呢~ 学学吧~)&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.chenruiwen.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微博图床插件打包</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbej001xuifn2vk5hoz5/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbej001xuifn2vk5hoz5/</id>
    <published>2018-04-20T06:31:43.000Z</published>
    <updated>2018-07-21T10:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寻找一个免费的图床软件，微博图床真的是太好不过了~~（手动感谢微博图床！）。之前安装微博图床的chrome插件，本人手贱删了，现在暂时也没翻到墙外，一时间需要重新安装微博图床的chrome插件，甚是着急。网上提供的一些插件也都没用，只能另求他路。<br><a id="more"></a></p><h1 id="通过自己打包安装微博图床插件"><a href="#通过自己打包安装微博图床插件" class="headerlink" title="通过自己打包安装微博图床插件"></a>通过自己打包安装微博图床插件</h1><ol><li><p>链接到微博图床github地址并下载。url如下：</p><pre><code>https://github.com/suxiaogang/WeiboPicBed</code></pre></li><li><p>打开chrome扩展程序<br>打开chrome浏览器，输入如下地址：</p><pre><code>chrome://extensions/</code></pre></li><li><p>打开开发者模式，点击 打包扩展程序<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fq68oqn95lj20mn09ygmb.jpg" alt=""></p></li><li><p>打包扩展程序， 扩展程序目录选择 github上 clone下来的目录，点击打包即可。<br>会在同级目录下生成 .crx 和 .pem结尾文件，其中 .crx结尾文件即是扩展程序<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fq68qz213aj20fj04wmxd.jpg" alt=""></p></li></ol><h1 id="安装微博图床插件"><a href="#安装微博图床插件" class="headerlink" title="安装微博图床插件"></a>安装微博图床插件</h1><p>直接拖动微博图床插件(WeiboPicBed.crx)至chrome扩展程序即可。然后你就可以肆意上传图片了~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;寻找一个免费的图床软件，微博图床真的是太好不过了~~（手动感谢微博图床！）。之前安装微博图床的chrome插件，本人手贱删了，现在暂时也没翻到墙外，一时间需要重新安装微博图床的chrome插件，甚是着急。网上提供的一些插件也都没用，只能另求他路。&lt;br&gt;
    
    </summary>
    
      <category term="tips" scheme="http://www.chenruiwen.cn/categories/tips/"/>
    
    
      <category term="tool" scheme="http://www.chenruiwen.cn/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>基于hexo+nginx快速建站</title>
    <link href="http://www.chenruiwen.cn/2018/cjjvavbeg001puifng5cjn2eo/"/>
    <id>http://www.chenruiwen.cn/2018/cjjvavbeg001puifng5cjn2eo/</id>
    <published>2018-04-18T15:10:32.000Z</published>
    <updated>2018-07-21T10:57:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgqs867o5j20xc0jiaix.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟公司大神学习技术知识，发现大神们都有自己的技术博客，拥有个人网站，感觉很酷。所以趁着一波阿里云打折，开启自己个人网站之路。准备着手从个人博客网站开始，无奈自己是一个小小后端程序猿，前端技术了解不多，难道要开始先积累前端技术栈再建站吗？orz。当然不，网上有大量博客框架和教程可以快速建站，比如Hexo,Wordpress等。本人博客 1.0版本就准备用hexo开始。<br>本文并非部署到github上，想要部署到github另行参考。<br><a id="more"></a></p><h2 id="Hexo特点"><a href="#Hexo特点" class="headerlink" title="Hexo特点"></a>Hexo特点</h2><p>不妨登录<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a>瞧一瞧。</p><ul><li>Blazing Fast</li><li>Markdown Support</li><li>One-Command Deployment</li><li>Various Plugins</li></ul><p>总之就是很快，支持markdown，简单到一键部署，拥有多样性插件。</p><h2 id="快速搭建博客"><a href="#快速搭建博客" class="headerlink" title="快速搭建博客"></a>快速搭建博客</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>一台阿里云ECS，环境安装有:</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>, </li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="https://nginx.org/" target="_blank" rel="noopener">Nginx</a></li></ul><p>Ubuntu安装Node.js</p><pre><code class="python"># 安装依赖包python-software-propertiesapt-get install python-software-propertiescurl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -apt-get install nodejs</code></pre><p>Ubuntu安装Git</p><pre><code>add-apt-repository ppa:git-core/ppaapt updateapt install git</code></pre><p>Ubuntu安装Nginx（略）</p><p>安装 Hexo</p><pre><code>npm install -g hexo-cli</code></pre><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>创建博客需要文件</p><pre><code>cd /datamidir hexo-blogcd hexo-bloghexo init$ npm install</code></pre><h3 id="配置网站信息"><a href="#配置网站信息" class="headerlink" title="配置网站信息"></a>配置网站信息</h3><p>修改 _config.yml 文件, 仅修改了站点信息和地址信息, 更多的配置信息参考官网</p><pre><code># Sitetitle: 陈瑞文的个人网站subtitle:description: 你好，旅行者keywords:author: 陈瑞文language: zh-Hanstimezone:# URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://www.chenruiwen.cnroot: /permalink: :year/:month/:day/:title/permalink_defaults:</code></pre><p>顺便下载了github上比较高排名的hexo主题：Next.</p><pre><code>git clone https://github.com/iissnan/hexo-theme-next</code></pre><p>将文件夹拷贝到Hexo博客目录的themes文件夹下，并修改站点主题</p><pre><code>theme: next</code></pre><p>剩下的个性化配置参考：<br><a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">https://theme-next.iissnan.com/getting-started.html</a><br>进行配置。此外，参考了大佬们的文章：</p><ul><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</a></li><li><a href="https://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html" target="_blank" rel="noopener">hexo高阶教程next主题优化</a></li><li><a href="https://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="https://www.dingxuewen.com/categories/Site/" target="_blank" rel="noopener">Hexo搭建博客的个性化设置</a></li></ul><h3 id="通过Nginx发布"><a href="#通过Nginx发布" class="headerlink" title="通过Nginx发布"></a>通过Nginx发布</h3><h4 id="Nginx下载安装"><a href="#Nginx下载安装" class="headerlink" title="Nginx下载安装"></a>Nginx下载安装</h4><p>略。  </p><h4 id="部署静态站点"><a href="#部署静态站点" class="headerlink" title="部署静态站点"></a>部署静态站点</h4><p>生成静态文件:</p><pre><code>➜  hexo-blog hexo g➜  hexo-blog ls_config.yml       node_modules      public            themesdb.json           package-lock.json scaffoldsdebug.log         package.json      source</code></pre><p>生成好的静态文件在public 文件夹内。</p><h4 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h4><p>修改nginx配置文件:</p><pre><code>vi /usr/local/nginx/conf/nginx.conf</code></pre><p>仅需修改http模块的server配置：</p><pre><code>server {        listen       80;        server_name  www.chenruiwen.cn;        charset utf-8;        root   /data/hexo-blog/public;# 这里是静态文件地址        location / {            index  index.html;        }}</code></pre><p>重新加载nginx：</p><pre><code>nginx -s reload</code></pre><p>至此，网站已初步建成。</p><h3 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h3><h5 id="通过git部署"><a href="#通过git部署" class="headerlink" title="通过git部署"></a>通过git部署</h5><ul><li>创建GitHub Repository(略)</li><li>修改配置文件_config.yml<pre><code>deploy:type: gitrepo: https://github.com/crrrrrw/hexo_static_page.gitbranch: master</code></pre></li><li>安装hexo git插件  <pre><code>npm install hexo-deployer-git --save</code></pre></li><li>部署<pre><code>hexo generatehexo deploy</code></pre>这样，所有文件就都提交到github库上了。</li></ul><p>服务器上，克隆静态文件</p><pre><code>cd /datagit clone https://github.com/crrrrrw/hexo_static_page.gitgit pull origin master</code></pre><p>即可实现静态文件的更新。然后nginx重新指向这个静态文件目录即可。</p><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>思路a:<br>脚本定时更新github地址。</p><p>思路b:<br>基于git hooks实现push后的自动化部署。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，搭建博客环境很简单，不过还有很多的工作要做，比如优化自己博客的样式，增加一些有意思的功能等，以后会慢慢优化的。当然，最重要的是写出好的有用的博文分享出去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgqs867o5j20xc0jiaix.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;跟公司大神学习技术知识，发现大神们都有自己的技术博客，拥有个人网站，感觉很酷。所以趁着一波阿里云打折，开启自己个人网站之路。准备着手从个人博客网站开始，无奈自己是一个小小后端程序猿，前端技术了解不多，难道要开始先积累前端技术栈再建站吗？orz。当然不，网上有大量博客框架和教程可以快速建站，比如Hexo,Wordpress等。本人博客 1.0版本就准备用hexo开始。&lt;br&gt;本文并非部署到github上，想要部署到github另行参考。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.chenruiwen.cn/categories/blog/"/>
    
    
      <category term="blog" scheme="http://www.chenruiwen.cn/tags/blog/"/>
    
  </entry>
  
</feed>
