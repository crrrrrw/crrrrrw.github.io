<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chen RuiWen&#39;s Space</title>
  
  <subtitle>Life is real, life is earnest</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.chenruiwen.cn/"/>
  <updated>2018-09-08T16:04:47.785Z</updated>
  <id>https://www.chenruiwen.cn/</id>
  
  <author>
    <name>陈瑞文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析java并发包(三)：阻塞队列(BlockingQueue)</title>
    <link href="https://www.chenruiwen.cn/java-concurrency/java-util-concurrent-BlockingQueue/"/>
    <id>https://www.chenruiwen.cn/java-concurrency/java-util-concurrent-BlockingQueue/</id>
    <published>2018-09-08T08:16:24.000Z</published>
    <updated>2018-09-08T16:04:47.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>阻塞队列 (<code>BlockingQueue</code>)是<code>j.u.c</code>下重要的数据结构，<code>BlockingQueue</code>提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。</p><a id="more"></a><h2 id="接口-BlockingQueue"><a href="#接口-BlockingQueue" class="headerlink" title="接口 BlockingQueue"></a>接口 BlockingQueue</h2><h3 id="提供的方法API"><a href="#提供的方法API" class="headerlink" title="提供的方法API"></a>提供的方法API</h3><p>从API文档上看，<code>BlockingQueue</code>定义的方法有四种形式，具有不同的操作方式，不能立即满足，但可能在将来的某个时间点满足：一个抛出异常，第二个返回一个特殊值（ null或false ，具体取决于操作），第三个程序将无限期地阻止当前线程，直到操作成功为止，而第四个程序块在放弃之前只有给定的最大时限。 这些方法总结在下表中：</p><table><thead><tr><th>method\way</th><th>Throws exception</th><th>Special value</th><th>Blocks</th><th>Times out</th></tr></thead><tbody><tr><td>Insert</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit) </td></tr><tr><td>Remove</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>Examine</td><td>element()</td><td>peek()</td><td>not applicable</td><td>not applicable</td></tr></tbody></table><p>简单解释一下四种行为方式：</p><ul><li>抛异常(Throws exception)：如果试图的操作无法立即执行，抛一个异常。</li><li>特定值(Special value)：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li><li>阻塞(Blocks)：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时(Times out)：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是true / false)。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>阻塞队列的典型使用场景就是生产者 - 消费者场景，它可以安全的与多个生产者和多个消费者一起使用。引用API文档里的例子：</p><pre><code class="java">class Producer implements Runnable {   private final BlockingQueue queue;   Producer(BlockingQueue q) { queue = q; }   public void run() {     try {       while (true) { queue.put(produce()); }     } catch (InterruptedException ex) { ... handle ...}   }   Object produce() { ... } } class Consumer implements Runnable {   private final BlockingQueue queue;   Consumer(BlockingQueue q) { queue = q; }   public void run() {     try {       while (true) { consume(queue.take()); }     } catch (InterruptedException ex) { ... handle ...}   }   void consume(Object x) { ... } } class Setup {   void main() {     BlockingQueue q = new SomeQueueImplementation();     Producer p = new Producer(q);     Consumer c1 = new Consumer(q);     Consumer c2 = new Consumer(q);     new Thread(p).start();     new Thread(c1).start();     new Thread(c2).start();   } }</code></pre><h3 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h3><ul><li>不接受null元素。当尝试对一个阻塞队列执行add,put或offer一个null对象时，会抛出NullPointerException。</li><li>BlockingQueue实现是线程安全的。 所有排队方法使用内部锁或其他形式的并发控制在原子上实现其效果。 </li></ul><h2 id="BlockingQueue常见实现类与介绍"><a href="#BlockingQueue常见实现类与介绍" class="headerlink" title="BlockingQueue常见实现类与介绍"></a>BlockingQueue常见实现类与介绍</h2><ul><li>有界阻塞队列：ArrayBlockingQueue,LinkedBlockingQueue…</li><li>无界阻塞队列：PriorityBlockingQueue,DelayQueue…</li><li>优先级阻塞队列：PriorityBlockingQueue</li><li>延迟阻塞队列：DelayQueue</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>有界阻塞队列，FIFO队列，内部是通过数组实现的，大小固定，创建后容量无法修改。尝试put成满的队列的元件将导致在操作阻挡; 尝试take从空队列的元件将类似地阻塞。</p><p>举个栗子：</p><pre><code class="java">public class BlockingQueueTest {    /**     * 实例化一个队列，队列中的容量为10     */    private static BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(10);    public static void main(String[] args) {        ScheduledExecutorService product = Executors.newScheduledThreadPool(1);        Random random = new Random();        product.scheduleAtFixedRate(() -&gt; {            int value = random.nextInt(101);            try {                blockingQueue.offer(value);  //offer()方法就是往队列的尾部设置值                System.out.println(&quot;已经往队列里加入数据:&quot; + value);            } catch (Exception ex) {                ex.printStackTrace();            }        }, 0, 100, TimeUnit.MILLISECONDS);  //每100毫秒执行线程        new Thread(() -&gt; {            while (true) {                try {                    Thread.sleep(1000);                    Integer poll = blockingQueue.poll();// 弹出                    System.out.println(&quot;已经从队列里取出数据:&quot; + poll);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }).start();    }}</code></pre><p>以上实现一个固定队列的例子，容量为10，可以通过构造器创建容量大小为n的阻塞队列。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>有界阻塞队列，FIFO队列，基于链表实现，创建时可以不指定容量，不指定时默认容量Integer.MAX_VALUE。队列的节点可以动态扩展，只是不能超过容量。这一点上与<code>ArrayBlockingQueue</code>区别在于<code>ArrayBlockingQueue</code>创建后不能再扩展队列的元素了。</p><p>使用方式，将上面的<code>BlockingQueueTest</code>里的阻塞队列的实现改为<code>LinkedBlockingQueue</code>即可。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>无界阻塞队列，优先级排序。<code>PriorityBlockingQueue</code>只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容。所以，虽然这个队列逻辑上无界，但是可能会耗尽资源导致OOM的问题。<code>PriorityBlockingQueue</code>的内部排序默认是自然排序，也可通过<code>omparator</code>指定排序规则，便于自定义优先级逻辑。</p><p><code>PriorityBlockingQueue</code>内部也是通过数组实现，数组的容量可以动态扩展，源码如下：</p><pre><code class="java">/** * Tries to grow array to accommodate at least one more element * (but normally expand by about 50%), giving up (allowing retry) * on contention (which we expect to be rare). Call only while * holding lock. * * @param array the heap array * @param oldCap the length of the array */private void tryGrow(Object[] array, int oldCap) {    lock.unlock(); // must release and then re-acquire main lock    Object[] newArray = null;    if (allocationSpinLock == 0 &amp;&amp;        UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset,                                 0, 1)) {        try {            int newCap = oldCap + ((oldCap &lt; 64) ?                                   (oldCap + 2) : // grow faster if small                                   (oldCap &gt;&gt; 1));            if (newCap - MAX_ARRAY_SIZE &gt; 0) {    // possible overflow                int minCap = oldCap + 1;                if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE)                    throw new OutOfMemoryError();                newCap = MAX_ARRAY_SIZE;            }            if (newCap &gt; oldCap &amp;&amp; queue == array)                newArray = new Object[newCap];        } finally {            allocationSpinLock = 0;        }    }    if (newArray == null) // back off if another thread is allocating        Thread.yield();    lock.lock();    if (newArray != null &amp;&amp; queue == array) {        queue = newArray;        System.arraycopy(array, 0, newArray, 0, oldCap);    }}</code></pre><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>无界阻塞队列，其元素是一个<code>Delayed</code>元素，其元素只能在其延迟到期时才被使用。在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><p>其使用场景：</p><ul><li>定时任务调度。通过<code>DelayQueue</code>保存执行的任务和执行时间，当从<code>DelayQueue</code>中获取到任务时立即执行，从而实现定时调度。</li><li>缓存有效期。缓存元素的有效期，当循环获取队列的元素时，只要获取到就说明缓存有效期过了。</li></ul><h3 id="其他队列"><a href="#其他队列" class="headerlink" title="其他队列"></a>其他队列</h3><p>除了常用的队列以外，jdk还提供了一些其他的实现，比如：<code>SynchronousQueue</code>，<code>LinkedTransferQueue</code>，<code>LinkedBlockingDeque</code>等，各有特色与其使用场景。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;阻塞队列 (&lt;code&gt;BlockingQueue&lt;/code&gt;)是&lt;code&gt;j.u.c&lt;/code&gt;下重要的数据结构，&lt;code&gt;BlockingQueue&lt;/code&gt;提供了线程安全的队列访问方式：
当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。&lt;/p&gt;
    
    </summary>
    
      <category term="java-concurrency" scheme="https://www.chenruiwen.cn/categories/java-concurrency/"/>
    
    
      <category term="java" scheme="https://www.chenruiwen.cn/tags/java/"/>
    
      <category term="java concurrency" scheme="https://www.chenruiwen.cn/tags/java-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>浅析java并发包(二)：并发容器类</title>
    <link href="https://www.chenruiwen.cn/java-concurrency/java-util-concurrent-collections/"/>
    <id>https://www.chenruiwen.cn/java-concurrency/java-util-concurrent-collections/</id>
    <published>2018-09-02T08:16:24.000Z</published>
    <updated>2018-09-02T08:03:27.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>jdk1.5之前，线程安全的容器类有<code>HashTable</code>,<code>Vector</code>等实现。但是其内部使用的是<code>synchronized</code>内置锁这样重量级的实现，在高并发的情况下大大影响性能。jdk1.5之后，<code>j.u.c</code>中有了基于<code>CAS</code>实现的更加高并发的实现来极大的提高伸缩性。<a id="more"></a></p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><code>ConcurrentHashMap</code>是当前最常使用的并发容器之一，它同样也实现了<code>AbstractMap</code>接口，所以使用它就像是使用<code>HashMap</code>等线程不安全的容器一样使用。</p><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><pre><code class="java">static final class HashEntry&lt;K,V&gt; {    final int hash;    final K key;    volatile V value;    volatile HashEntry&lt;K,V&gt; next;}</code></pre><p>和<code>HashMap</code>类似，也是基于哈希桶的结构，最主要的区别在于，<code>ConcurrentHashMap</code>采用了分段锁<code>Segment</code>来加锁，并不是整个结构都加锁，使得多个线程可以访问不同分段锁上的桶，从而实现更高的并发。</p><p>关于<code>并发等级</code>，即分段锁的个数，在源码里默认的并发等级是16：</p><pre><code class="java">/** * The default concurrency level for this table. Unused but * defined for compatibility with previous versions of this class. */private static final int DEFAULT_CONCURRENCY_LEVEL = 16;</code></pre><p><code>Segment</code>的结构:</p><pre><code class="java">/** * Stripped-down version of helper class used in previous version, * declared for the sake of serialization compatibility */static class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {    private static final long serialVersionUID = 2249069246763182397L;    final float loadFactor;    Segment(float lf) { this.loadFactor = lf; }}</code></pre><p>所以其大致的结构是这样的:<img src="https://ws1.sinaimg.cn/large/87faef88ly1fuv78147kbj20pr0ij0t3.jpg" alt=""></p><h3 id="重要的方法"><a href="#重要的方法" class="headerlink" title="重要的方法"></a>重要的方法</h3><h4 id="put-K-key-V-value"><a href="#put-K-key-V-value" class="headerlink" title="put(K key, V value)"></a>put(K key, V value)</h4><pre><code class="java">public V put(K key, V value) {    return putVal(key, value, false);}</code></pre><p>如果key存在也替换value值：</p><pre><code class="java">/** Implementation for put and putIfAbsent */final V putVal(K key, V value, boolean onlyIfAbsent) {    if (key == null || value == null) throw new NullPointerException();    int hash = spread(key.hashCode());    int binCount = 0;    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh;        if (tab == null || (n = tab.length) == 0)            tab = initTable();        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;                   // no lock when adding to empty bin        }        else if ((fh = f.hash) == MOVED)            tab = helpTransfer(tab, f);        else {            V oldVal = null;            synchronized (f) {                if (tabAt(tab, i) == f) {                    if (fh &gt;= 0) {                        binCount = 1;                        for (Node&lt;K,V&gt; e = f;; ++binCount) {                            K ek;                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) {                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            }                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) {                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            }                        }                    }                    else if (f instanceof TreeBin) {                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) {                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        }                    }                }            }            if (binCount != 0) {                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            }        }    }    addCount(1L, binCount);    return null;}</code></pre><p>简诉以上代码逻辑：</p><ol><li>判断key,value均不能为null。</li><li>计算key的hash值。</li><li>开始遍历整个table。<ol><li>table为null时初始化table</li><li>计算节点位置，如果该位置没有别的节点则直接插入，不需要加锁</li><li><code>(fh = f.hash) == MOVED</code>，如果有线程正在扩容，则先帮助扩容4 如果该节点位置有别的节点，加锁处理。<ol><li>如果该节点位置上目前<code>fh &gt;= 0</code>，则为链表结构，遍历链表，如果key节点相同则替换value，否则插入链表尾部。</li><li>如果该位置节点上是<code>TreeBin</code>类型，则以红黑树的方式赠加节点。</li></ol></li></ol></li><li>ConcurrentHashMap 的 size + 1。</li></ol><h4 id="get-Object-key"><a href="#get-Object-key" class="headerlink" title="get(Object key)"></a>get(Object key)</h4><pre><code class="java">public V get(Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    int h = spread(key.hashCode());    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (e = tabAt(tab, (n - 1) &amp; h)) != null) {        if ((eh = e.hash) == h) {            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))                return e.val;        }        else if (eh &lt; 0)            return (p = e.find(h, key)) != null ? p.val : null;        while ((e = e.next) != null) {            if (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))                return e.val;        }    }    return null;}</code></pre><p>简诉以上代码逻辑：</p><ol><li>计算key的hash值。</li><li>判断table是否有值，没值直接返回null。</li><li>获取table中的node节点，如果是链表则遍历查找到相同key的value，如果是红黑树则调用<code>e.find(h, key)</code>找到value。</li></ol><h4 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h4><p>size()操作是一个费劲的操作，在1.7以及之前的版本中，size()是需要获取每个<code>Segment</code>中的count值累加获取的，由于可能存在size的同时有线程正在put或者remove操作，所以其返回的值可能不精确。</p><p>而1.8之后，ConcurrentHashMap提供了<code>baseCount</code>、<code>counterCells</code>两个辅助变量和一个<code>CounterCell</code>辅助内部类来计算size()。</p><p>具体代码暂不展示了，在实际操作中实际上很少用到<code>size()</code>方法。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArrayList</code>是用于替代同步List,它提供了更好的并发性。同理的<code>CopyOnWriteArrayList</code>是替代同步Set。</p><p><code>写入时复制(Copy-On-Write)</code>，这一类容器的特点是，访问该对象时不需要再进行一次同步，但每次修改时都会创建并重新发布一个新的容器副本从而实现可变性。</p><p>读写分离，写在一个新的副本数组上执行，此处需加锁；读操作直接读原始数组。写操作完成后会把原始数组指向新数组：</p><pre><code class="java">public boolean add(E e) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        Object[] newElements = Arrays.copyOf(elements, len + 1);        newElements[len] = e;        setArray(newElements);        return true;    } finally {        lock.unlock();    }}final void setArray(Object[] a) {    array = a;}</code></pre><p>因此，增删元素等都是花费很大的开销，典型的空间换时间的方式，只有当迭代操作远远多于修改操作时，才应当使用<code>Copy-On-Write</code>容器。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除此之外，还有一些有各自应用场景的并发集合类比如<code>ConcurrentSkipListMap</code>和<code>ConcurrentSkipListSet</code>。最主要的重点集合类便是<code>ConcurrentHashMap</code>了，其代码在jdk1.7和1.8之间还有不同。建议阅读源码顺序：<code>1.7的HashMap</code>-&gt;<code>1.7的ConcurrentHashMap</code>-&gt;<code>1.8的HashMap</code>-&gt;<code>1.8的ConcurrentHashMap</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;jdk1.5之前，线程安全的容器类有&lt;code&gt;HashTable&lt;/code&gt;,&lt;code&gt;Vector&lt;/code&gt;等实现。但是其内部使用的是&lt;code&gt;synchronized&lt;/code&gt;内置锁这样重量级的实现，在高并发的情况下大大影响性能。
jdk1.5之后，&lt;code&gt;j.u.c&lt;/code&gt;中有了基于&lt;code&gt;CAS&lt;/code&gt;实现的更加高并发的实现来极大的提高伸缩性。
    
    </summary>
    
      <category term="java-concurrency" scheme="https://www.chenruiwen.cn/categories/java-concurrency/"/>
    
    
      <category term="java" scheme="https://www.chenruiwen.cn/tags/java/"/>
    
      <category term="java concurrency" scheme="https://www.chenruiwen.cn/tags/java-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>浅析java并发包(一)：原子类和锁</title>
    <link href="https://www.chenruiwen.cn/java-concurrency/java-util-concurrent-atomic-and-locks/"/>
    <id>https://www.chenruiwen.cn/java-concurrency/java-util-concurrent-atomic-and-locks/</id>
    <published>2018-08-20T15:16:24.000Z</published>
    <updated>2018-08-21T13:14:37.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>jdk 1.5</code>开始，新增了<code>java.util.concurrent</code>包（以下简称<code>j.u.c</code>），是一系列关于并发的工具类，是java并发编程必知必会的内容。今儿准备简单介绍一些常用的工具类。</p><a id="more"></a><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p><code>java.util.concurrent.atomic</code>包提供了一些专门为线程安全设计的java操作原子类。见名知意，类名基本以 <code>Atomic</code> 开头，表示这些类都是线程安全的。</p><p>明明提供线程安全的锁，为什么还要提供这些基础的类呢？</p><p>这就必须说明，这些原子类与通过<code>synchronized</code>加锁实现的对象不同，以往通过<code>synchronized</code>等加锁的实现我们认为是一种悲观锁的体现，即不论谁来操作，都假设最坏的情况，必须加锁独占，让其他需要操作的线程挂起等待锁释放。这种情况是具有比较大的开销的，线程抢占锁的花费的时间代价非常高。</p><p>所以这里就体现了原子类存在的强大意义。原子类的底层代码是利用了现代CPU的<code>CAS</code>指令来完成赋值操作的。<code>CAS</code>是乐观锁技术，原称:<code>Compare and Swap</code>,比较并交换。操作之前会比较内存值V与预期值A是否一致，并且仅当V == A时，才会把V赋值为新值B。</p><p>举个例子，<code>AtomicInteger</code>的<code>incrementAndGet</code>操作:</p><pre><code class="java">public final int incrementAndGet() {    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;}</code></pre><p>其调用了<code>sun.misc.Unsafe</code>的方法，这里的<code>compareAndSwapInt</code>是一个本地方法，起调用了CPU的CAS指令。</p><pre><code class="java">public final int getAndAddInt(Object var1, long var2, int var4) {    int var5;    do {        var5 = this.getIntVolatile(var1, var2);    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));    return var5;}</code></pre><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><code>java.util.concurrent.locks</code>包下提供了很方方便加锁的工具。其下最知名的应该是<code>ReentrantLock</code>，但是提到<code>ReentrantLock</code>之前，最需要提的是<code>AbstractQueuedSynchronizer</code>。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p><code>AbstractQueuedSynchronizer</code>简称<code>AQS</code>，见名知意，抽象的基于队列的同步器，本质上是提供并定义了一套多线程访问共享资源的模板。这个模板应用广泛，大部分锁的实现都基于此：<img src="https://ws1.sinaimg.cn/large/87faef88ly1fud1ftyagjj21kc0eoq7u.jpg" alt=""></p><p>源码中的描述:</p><blockquote><p>The wait queue is a variant of a “CLH” (Craig, Landin, and Hagersten) lock queue.</p></blockquote><p><code>CLH</code>是一种自旋锁，提供先来先服务的公平性，其基于链表，申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p><p><code>AQS</code>提供了两种资源共享方式:<code>Exclusive</code>(独占) 和 <code>Shared</code>(共享)。</p><p>我们开发中自定义队列同步器很少，更多的实现都在jdk中。</p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p><code>ReentrantLock</code>是开发中比较常用的显示锁。其性能在jdk1.5的时候是比<code>synchronized</code>关键字高出许多的，但是jdk1.6之后二者实际上不分伯仲。但是<code>ReentrantLock</code>还是有其独特的特性：轮询锁、定时锁、可中断锁、公平锁等，并且使用更加灵活。</p><p>其基本使用方式:</p><pre><code class="java">Lock lock = new ReentrantLock();...lock.lock(); // 上锁try {    // 处理共享资源} finally {    lock.unlock(); // 解锁} </code></pre><h4 id="轮询锁与定时锁"><a href="#轮询锁与定时锁" class="headerlink" title="轮询锁与定时锁"></a>轮询锁与定时锁</h4><p>轮询锁与定时锁是由<code>tryLock</code>方法实现的，与无条件的锁获取方式相比，它具有跟完善的错误回复机制。</p><h5 id="轮询锁之转账问题"><a href="#轮询锁之转账问题" class="headerlink" title="轮询锁之转账问题"></a>轮询锁之转账问题</h5><p>假设在银行系统把账户A的钱转给账户B，必须保证多线程并发安全，加锁是必不可少的，但是在获取多个锁的情况下，如果通过内置锁，很可能发生死锁问题。</p><p>解决方式：通过<code>tryLock</code>尝试同时获取多个锁，如果不能同时获取，就回退重试。</p><p>账户类，每个账户都持有一把锁：</p><pre><code class="java">@Data@Builderclass Account {    private BigDecimal balance; // 账户余额    private String name; // 账户名称    public Lock lock;    void debit(BigDecimal amount) {        balance = balance.subtract(amount);    }    void credit(BigDecimal amount) {        balance = balance.add(amount);    }    @Override    public String toString() {        return new StringBuilder(name).append(&quot;的余额为:&quot;).append(balance).toString();    }}</code></pre><p>使用<code>tryLock</code>尝试获取锁，进行两个账户的转账:</p><pre><code class="java">public class TransferService {    public boolean transferAccount(Account fromAcct, Account toAcct, BigDecimal amount, long timeout) throws InterruptedException {        long stopTime = System.currentTimeMillis() + timeout;        while (true) {            if (fromAcct.lock.tryLock()) {                try {                    if (toAcct.lock.tryLock()) {                        try {                            if (fromAcct.getBalance().compareTo(amount) &lt; 0) {                                throw new RuntimeException(&quot;转账账户余额不足&quot;);                            } else {                                fromAcct.debit(amount);                                toAcct.credit(amount);                                System.out.println(&quot;转账人:&quot; + fromAcct.toString());                                System.out.println(&quot;被转账人:&quot; + toAcct.toString());                                return true;                            }                        } finally {                            toAcct.lock.unlock();                        }                    } else {                        System.out.println(&quot;toAcct.lock.tryLock() false&quot;);                    }                } finally {                    fromAcct.lock.unlock();                }            } else {                System.out.println(&quot;fromAcct.lock.tryLock() false&quot;);            }            if (System.currentTimeMillis() &gt; stopTime) {                return false;            }            Thread.sleep(1000L);        }    }    public static void main(String[] args) {        Lock lock1 = new ReentrantLock();        Lock lock2 = new ReentrantLock();        final Account fromAcct = Account.builder().lock(lock1).name(&quot;老王&quot;).balance(new BigDecimal(1000)).build();        final Account toAcct = Account.builder().lock(lock2).name(&quot;老李&quot;).balance(new BigDecimal(1000)).build();        TransferService service = new TransferService();        Runnable runnable = new Runnable() {            @Override            public void run() {                try {                    service.transferAccount(fromAcct, toAcct, new BigDecimal(50), 1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        };        for (int i = 0; i &lt; 10; i++) {            new Thread(runnable).start();        }    }}</code></pre><p>如下运行结果，可以看到尝试获取锁多次。如果修改调用参数里的timeout 值，可能会出现转账失败的情况。</p><pre><code>fromAcct.lock.tryLock() false转账人:老王的余额为:950被转账人:老李的余额为:1050转账人:老王的余额为:900fromAcct.lock.tryLock() false被转账人:老李的余额为:1100转账人:老王的余额为:850被转账人:老李的余额为:1150fromAcct.lock.tryLock() false转账人:老王的余额为:800被转账人:老李的余额为:1200fromAcct.lock.tryLock() false转账人:老王的余额为:750被转账人:老李的余额为:1250fromAcct.lock.tryLock() falsefromAcct.lock.tryLock() false转账人:老王的余额为:700被转账人:老李的余额为:1300fromAcct.lock.tryLock() falsefromAcct.lock.tryLock() false转账人:老王的余额为:650被转账人:老李的余额为:1350fromAcct.lock.tryLock() falsefromAcct.lock.tryLock() false转账人:老王的余额为:600被转账人:老李的余额为:1400fromAcct.lock.tryLock() false转账人:老王的余额为:550被转账人:老李的余额为:1450转账人:老王的余额为:500被转账人:老李的余额为:1500</code></pre><h5 id="定时锁的使用"><a href="#定时锁的使用" class="headerlink" title="定时锁的使用"></a>定时锁的使用</h5><p>关键方法<code>tryLock(long timeout, TimeUtil unit)</code>，即申请获取锁设置等待时间，在此等待时间内尝试获取锁，如果锁被其他线程占有，则返回false.这种方式可以有效的避免死锁的发生。</p><pre><code class="java">public class Service {    public ReentrantLock lock = new ReentrantLock();    public void waitMethod() {        try {            if (lock.tryLock(3, TimeUnit.SECONDS)) {                System.out.println(Thread.currentThread().getName() + &quot;获得锁的时间:&quot; + System.currentTimeMillis());                Thread.sleep(10000);            } else {                System.out.println(Thread.currentThread().getName() + &quot;没有获得锁&quot;);            }        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            if (lock.isHeldByCurrentThread()) {                lock.unlock();            }        }    }}public class Run_tryLock_param {    public static void main(String[] args) {        final Service service = new Service();        Runnable runnable = new Runnable() {            public void run() {                System.out.println(Thread.currentThread().getName() + &quot; 调用waitMethod时间:&quot; + System.currentTimeMillis());                service.waitMethod();            }        };        Thread threadA = new Thread(runnable);        threadA.setName(&quot;A&quot;);        threadA.start();        Thread threadB = new Thread(runnable);        threadB.setName(&quot;B&quot;);        threadB.start();    }}</code></pre><p>如上所示，运行结果:</p><pre><code>A 调用waitMethod时间:1534690399458B 调用waitMethod时间:1534690399458A获得锁的时间:1534690399459B没有获得锁</code></pre><h4 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h4><p>java的内置锁<code>synchronized</code>就是不可中断的锁，其不可中断的阻塞机制使得实现可取消的任务变得复杂。</p><p><code>Lock</code>是可中断锁，<code>lockInterruptibly</code>可以使得在获得锁的同时保持对中断的响应。</p><p><code>lockInterruptibly</code>基本使用方式:</p><pre><code class="java">public void method() throws InterruptedException {    lock.lockInterruptibly();    try {       //do something    }    finally {        lock.unlock();    }  }</code></pre><h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><code>ReentrantReadWriteLock</code>读写锁，它除了实现了<code>Lock</code>接口外，同时也实现了<code>ReadWriteLock</code>接口。</p><pre><code class="java">public interface ReadWriteLock {    /**     * Returns the lock used for reading.     *     * @return the lock used for reading     */    Lock readLock();    /**     * Returns the lock used for writing.     *     * @return the lock used for writing     */    Lock writeLock();}</code></pre><p>总所周知，<code>ReentrantLock</code>是排它锁，无论什么操作（read or write），其同一时间只能一个线程访问。但是实际应用中，读操作往往是占据最多的场景，那么绝大部分读取的场景能否采用共享锁呢？<code>ReentrantReadWriteLock</code>就能满足这一点，它允许读读共享，但是读写，写写是排他的操作。</p><p>应用场景，见<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">java doc api</a>提供了一个读写锁的生动的使用范例：</p><blockquote><p> Here is a code sketch showing how to perform lock downgrading after updating a cache (exception handling is particularly tricky when handling multiple locks in a non-nested fashion):<code>`</code>javaclass CachedData {   Object data;   volatile boolean cacheValid;   final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</p></blockquote><p>   void processCachedData() {     rwl.readLock().lock(); // 1.加读锁     if (!cacheValid) {       // Must release read lock before acquiring write lock       rwl.readLock().unlock(); // 2.释放读锁，因为要加写锁，不支持锁升级，只能先解读锁再加写锁       rwl.writeLock().lock();// 3.加写锁       try {         // Recheck state because another thread might have         // acquired write lock and changed state before we did.         if (!cacheValid) { // 见上面英文解释，简单的说避免重复写入数据           data = …           cacheValid = true;         }         // Downgrade by acquiring read lock before releasing write lock         rwl.readLock().lock();// 4.锁降级，写锁变读锁       } finally {         rwl.writeLock().unlock(); // Unlock write, still hold read  5.见英文，解写锁，仍然能读       }     }</p><pre><code> try {   use(data); } finally {   rwl.readLock().unlock(); // 6.最终释放读锁 }</code></pre><p>   } }<code>`</code>为什么要有锁降级？<br>因为锁降级的过程能避免在写锁释放，加读锁的过程中，此时读取的数据不会被其他线程竞争到写锁更新数据导致脏读问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>j.u.c</code>是实现java高并发必知必会的重要内容。在很多web相关框架中都有体现，也是java程序猿进阶的必备技能之一，多学多用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;jdk 1.5&lt;/code&gt;开始，新增了&lt;code&gt;java.util.concurrent&lt;/code&gt;包（以下简称&lt;code&gt;j.u.c&lt;/code&gt;），是一系列关于并发的工具类，是java并发编程必知必会的内容。今儿准备简单介绍一些常用的工具类。&lt;/p&gt;
    
    </summary>
    
      <category term="java-concurrency" scheme="https://www.chenruiwen.cn/categories/java-concurrency/"/>
    
    
      <category term="java" scheme="https://www.chenruiwen.cn/tags/java/"/>
    
      <category term="java concurrency" scheme="https://www.chenruiwen.cn/tags/java-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>再见，艾泽拉斯</title>
    <link href="https://www.chenruiwen.cn/essay/Goodbye-Azeroth/"/>
    <id>https://www.chenruiwen.cn/essay/Goodbye-Azeroth/</id>
    <published>2018-08-13T13:24:03.000Z</published>
    <updated>2018-08-13T15:19:33.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="再见"><a href="#再见" class="headerlink" title="再见"></a>再见</h2><p>终于，这一刻还是来了。2018年8月13日开始，彻底AFK了。虽然玩的菜，但好歹是玩的最久的游戏，就此告别，很开心有生之年去过艾泽拉斯。</p><a id="more"></a><h2 id="AFK的原因"><a href="#AFK的原因" class="headerlink" title="AFK的原因"></a>AFK的原因</h2><p>直接原因，是月卡的推出的这两年。官方公告：</p><blockquote><p>《魔兽世界》已于2016年8月4日从分钟付费模式转为包月畅玩模式。此后的两年内，账号里仍有剩余分钟时间的玩家可以选择继续消耗分钟进行游戏，也可通过游戏内的兑换功能，按以下比例将分钟换为包月模式下的天数：</p><p>150分钟=1天；不足150分钟的部分按150分钟计算</p><p>自2018年8月4日起，玩家将无法使用分钟时间继续登录游戏。我们将通过专题网站为这部分玩家提供如下的兑换选项：</p><p>150分钟=1天；不足150分钟的部分按150分钟计算</p><p>或以90分钟=1点的比例退还暴雪游戏点数至游戏账号关联的暴雪游戏通行证，小数部分向上取整，如7.1点计为8点。</p><p>注：账号冻结期间不能参与兑换；而通过战友招募等途径获取的免费时间将无法转为暴雪游戏点数，仅可换成包月天数。</p></blockquote><p>2016年的8月4日之前得到了官方公告，2016年8月4日后将不再支持点卡。于是乎大批休闲玩家(没时间一直玩)的玩家大批量囤游戏时间。没错，包括我，我囤了十张点卡。时间过得真的飞快，得到官方公告后才发现自那以后居然已经过了两年时间了…这两年的时间总共的游戏时间还不到24小时。</p><p>根本原因，则是时间。</p><p>今天，又重新把时间兑换成了战网点数。感觉青春突然又走了一些。</p><p><img src="https://ws1.sinaimg.cn/large/87faef88ly1fu8exz3bf7j21ui1407fa.jpg" alt=""><img src="https://ws1.sinaimg.cn/large/87faef88ly1fu8eybjlzej21uo13qk29.jpg" alt=""><img src="https://ws1.sinaimg.cn/large/87faef88ly1fu8eyi1f1qj21ug13sgw6.jpg" alt=""></p><h2 id="初识艾泽拉斯"><a href="#初识艾泽拉斯" class="headerlink" title="初识艾泽拉斯"></a>初识艾泽拉斯</h2><p>那是2008年的夏天，那年初中刚毕业，和磊少顺子去常州找好哥们猴子玩。猴子算是我对电脑的”启蒙老师”，他教会了我电脑是如何用来玩游戏的。。。猴子初中的时候离开了我们。。。不是永久的那种，跟他父母移居到常州去了，每年还是能回蚌埠来玩几天的。</p><p>在常州度过了难忘的几天，我们宅在家里玩游戏，第一次接触魔兽是那时候看猴子和他朋友打22竞技场，他们是战德组合，猴子就是德，所以就打德。炫酷的界面，复杂的技能栏，各种监控插件，最重要的是种族好多啊，牛头人真的很可爱，仅次于兽人妹纸。</p><p>后来上了高一后，上网吧成了周末的必备活动，好孩子表示周一到周五不能上网吧，原因是没时间。</p><p>那时候的周末总是那么美好，周六上午包个早机，中午回家吃饭后上一会儿网接着去打球，简单而充实的快乐。高一那年，认识了鸣鸣，一个活逗比。那会儿开号也是要花一张大卡的，我俩分表练了侏儒盗贼和侏儒法师。为什么玩侏儒，可能是比较符合我们猥琐的气质吧。</p><p>那会儿印象最深的是艾尔文森林的鱼人族们，嗯，让我们跑尸的那群哇啦啦们。</p><p>然后是杀霍格，第一个小BOSS，年轻的我以为同级的怪都能打过，没想到是还得靠磊少的大号SS带了把。吐槽一下磊少的术士， ID:囡囡不坏。嗯，非常接地气。</p><p>第一个FB，西部荒野的地下矿井。还是靠磊少的SS。套用磊少一句话：火石法杖，极品。</p><p>后来记得很清楚，17级的时候，号被盗了。那时候的盗号还是非常疯狂的，用密保吧太费事，不用密保稳被盗，没想到的是我的不到20级的号都能被盗。于是乎，我的第一个侏儒贼算是折戟了。</p><h2 id="再识艾泽拉斯"><a href="#再识艾泽拉斯" class="headerlink" title="再识艾泽拉斯"></a>再识艾泽拉斯</h2><p>很长一段时间没有玩了，后来猴子给了个号，44级人类盗贼，又让我重新回到艾泽拉斯。不得不说，人类盗贼潜行的样子真的很猥琐。</p><p>第一次荣誉击杀，是在塔纳瑞斯，野外遇到一个部落的猎人，第一反应，潜行。嗯，盗贼就得有盗贼的样子。悄悄潜过去，偷袭，背刺，肾击。总之就是一顿技能上去追着干。职业优势了也是，拿下艾泽拉斯一血。</p><p>【得睡觉了，未完待续…】</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;再见&quot;&gt;&lt;a href=&quot;#再见&quot; class=&quot;headerlink&quot; title=&quot;再见&quot;&gt;&lt;/a&gt;再见&lt;/h2&gt;&lt;p&gt;终于，这一刻还是来了。2018年8月13日开始，彻底AFK了。虽然玩的菜，但好歹是玩的最久的游戏，就此告别，很开心有生之年去过艾泽拉斯。&lt;/p&gt;
    
    </summary>
    
      <category term="essay" scheme="https://www.chenruiwen.cn/categories/essay/"/>
    
    
      <category term="essay" scheme="https://www.chenruiwen.cn/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>MacOS解决pycurl安装的坑</title>
    <link href="https://www.chenruiwen.cn/python/macos-fix-problem-about-pycurl-install/"/>
    <id>https://www.chenruiwen.cn/python/macos-fix-problem-about-pycurl-install/</id>
    <published>2018-08-11T02:20:07.000Z</published>
    <updated>2018-08-14T14:12:02.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录<code>macos</code>安装<code>pycurl</code>过程中的爬坑过程。</p><a id="more"></a><h2 id="爬坑过程记录"><a href="#爬坑过程记录" class="headerlink" title="爬坑过程记录"></a>爬坑过程记录</h2><p>本来目的是安装<code>pyspider</code>的, 安装<code>pyspider</code>必须依赖<code>pycurl</code>。</p><p>本人环境：</p><ul><li>Python 3.6.4</li><li>MacOS 10.12 Sierra</li></ul><h3 id="初次安装-pycurl"><a href="#初次安装-pycurl" class="headerlink" title="初次安装 pycurl"></a>初次安装 pycurl</h3><p>第一次安装pycurl。直接 <code>pip</code> 安装</p><pre><code>pip install pycurl</code></pre><p>可是安装并不顺利。安装报错:</p><pre><code>    ...  File &quot;/private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-install-y_b53n5l/pycurl/setup.py&quot;, line 316, in configure_unix    specify the SSL backend manually.&#39;&#39;&#39;)__main__.ConfigurationError: Curl is configured to use SSL, but we have not been able to determine which SSL backend it is using. Please see PycURL documentation for how to specify the SSL backend manually.----------------------------------------Command &quot;python setup.py egg_info&quot; failed with error code 1 in /private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-install-y_b53n5l/pycurl/</code></pre><p>可以看到报错应该是因为 使用ssl配置的原因。查看<a href="https://pycurl.io/docs/latest/install.html" target="_blank" rel="noopener">官方PycURL Installation¶</a>，可以不使用ssl安装。</p><h3 id="第二次安装-pycurl"><a href="#第二次安装-pycurl" class="headerlink" title="第二次安装 pycurl"></a>第二次安装 pycurl</h3><p>第二次安装，配置不使用ssl安装。</p><pre><code># upgrade pip if necessarypip install --upgrade pip# remove current pycurlpip uninstall pycurl# set PYCURL_SSL_LIBRARYexport PYCURL_SSL_LIBRARY=nss# recompile and install pycurlpip install --compile pycurl</code></pre><p>可是还是报错:</p><pre><code>...build/temp.macosx-10.12-x86_64-3.6/src/stringcompat.o build/temp.macosx-10.12-x86_64-3.6/src/threadsupport.o build/temp.macosx-10.12-x86_64-3.6/src/util.o -lssl3 -lcurl -o build/lib.macosx-10.12-x86_64-3.6/pycurl.cpython-36m-darwin.so    ld: library not found for -lssl3    clang: error: linker command failed with exit code 1 (use -v to see invocation)    error: command &#39;clang&#39; failed with exit status 1    ----------------------------------------Command &quot;/Users/chenruiwen/.pyenv/versions/3.6.4/bin/python3.6 -u -c &quot;import setuptools, tokenize;__file__=&#39;/private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-install-syesb72n/pycurl/setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\r\n&#39;, &#39;\n&#39;);f.close();exec(compile(code, __file__, &#39;exec&#39;))&quot; install --record /private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-record-ch2zxgp5/install-record.txt --single-version-externally-managed --compile&quot; failed with error code 1 in /private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-install-syesb72n/pycurl/</code></pre><p>二次吐血。</p><h3 id="第三次安装pycurl"><a href="#第三次安装pycurl" class="headerlink" title="第三次安装pycurl"></a>第三次安装pycurl</h3><p>还是根据官网，<code>nss</code>不可以，配置成<code>openssl</code>试试吧。</p><pre><code>pip uninstall pycurlexport PYCURL_SSL_LIBRARY=opensslpip install --compile pycurl</code></pre><p>还是那个熟悉的味道:</p><pre><code>...clang -Wno-unused-result -Wsign-compare -Wunreachable-code -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -I/usr/local/Cellar/openssl/1.0.2o_1/include -DPYCURL_VERSION=&quot;7.43.0.2&quot; -DHAVE_CURL_SSL=1 -DHAVE_CURL_OPENSSL=1 -DHAVE_CURL_SSL=1 -I/Users/chenruiwen/.pyenv/versions/3.6.4/include/python3.6m -c src/docstrings.c -o build/temp.macosx-10.12-x86_64-3.6/src/docstrings.o    In file included from src/docstrings.c:4:    src/pycurl.h:164:13: fatal error: &#39;openssl/ssl.h&#39; file not found    #   include &lt;openssl/ssl.h&gt;                ^~~~~~~~~~~~~~~    1 error generated.    error: command &#39;clang&#39; failed with exit status 1    ----------------------------------------Command &quot;/Users/chenruiwen/.pyenv/versions/3.6.4/bin/python3.6 -u -c &quot;import setuptools, tokenize;__file__=&#39;/private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-install-aavrg23s/pycurl/setup.py&#39;;f=getattr(tokenize, &#39;open&#39;, open)(__file__);code=f.read().replace(&#39;\r\n&#39;, &#39;\n&#39;);f.close();exec(compile(code, __file__, &#39;exec&#39;))&quot; install --record /private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-record-l0npewt_/install-record.txt --single-version-externally-managed --compile&quot; failed with error code 1 in /private/var/folders/nx/khfvbh1d6vg334173fsxzb9r0000gn/T/pip-install-aavrg23s/pycurl/</code></pre><p>三次吐血。可以看到引入 <code>openssl/ssl.h</code>失败了。继续google解决一下。</p><h3 id="第四次安装pycurl"><a href="#第四次安装pycurl" class="headerlink" title="第四次安装pycurl"></a>第四次安装pycurl</h3><p>从 <code>stackoverflow</code> 搜到一个<a href="https://stackoverflow.com/questions/21096436/ssl-backend-error-when-using-openssl" target="_blank" rel="noopener">解决方案</a>,准备尝试一下。</p><pre><code>pip uninstall pycurlexport PYCURL_SSL_LIBRARY=opensslexport LDFLAGS=-L/usr/local/opt/openssl/libexport CPPFLAGS=-I/usr/local/opt/openssl/includepip install pycurl --compile --no-cache-dir</code></pre><p>果然安装成功了！可喜可贺！可是我们用python导入pycurl试试：</p><pre><code>&gt;&gt;&gt; import pycurlTraceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ImportError: pycurl: libcurl link-time ssl backend (none/other) is different from compile-time ssl backend (openssl)</code></pre><p>四次吐血。 不过这次的问题应该是系统版本问题，刚刚 <code>stackoverflow</code>上的解决方案要求是系统<code>OSX 10.13</code>，于是乎备份系统，升级到<code>macOS 10.13 High Sierra</code>。大胆的童鞋可以不备份升级，比如我(:D)。</p><p>升级完成后尝试一下导入pycurl:</p><pre><code>&gt;&gt;&gt; import pycurl&gt;&gt;&gt;</code></pre><p>成功解决问题。吐血完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记录&lt;code&gt;macos&lt;/code&gt;安装&lt;code&gt;pycurl&lt;/code&gt;过程中的爬坑过程。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://www.chenruiwen.cn/categories/python/"/>
    
    
      <category term="python" scheme="https://www.chenruiwen.cn/tags/python/"/>
    
      <category term="pycurl" scheme="https://www.chenruiwen.cn/tags/pycurl/"/>
    
  </entry>
  
  <entry>
    <title>redis“冷门”知识点：HyperLogLog</title>
    <link href="https://www.chenruiwen.cn/redis/redis-hyperloglog/"/>
    <id>https://www.chenruiwen.cn/redis/redis-hyperloglog/</id>
    <published>2018-08-05T07:08:24.000Z</published>
    <updated>2018-08-13T14:23:20.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天，我司大牛分享redis知识点，讲到redis数据结构的时候，抛出一个问题：如果要统计网站uv，你准备怎么实现？</p><p>和大多数普通开发人员一样，想到的第一个想法是存到set集合里。可是这样真的好吗？</p><p>后来找到了更好的方式，redis“冷门”数据结构:<code>HyperLogLog</code>。（说是“冷门”，可能只是我不知道罢了:D）</p><a id="more"></a><h2 id="问题回顾"><a href="#问题回顾" class="headerlink" title="问题回顾"></a>问题回顾</h2><blockquote><p>你准备如何实现统计大型网站的网页UV数据？</p></blockquote><p>uv数据不像pv数据，pv可能只需要在redis中使用一个计数器，每次访问<code>incrby</code>一次即可。uv数据需要根据用户id来标识唯一来统计，集合中的数据需要去重，那么<code>set</code>是一个最容易想到的数据结构。现在的问题是，大型网站，可能这是一个爆款商品的秒杀页面，用户访问量非常大，假如有上千万的uv估计，那么占用的空间就非常大，而我仅仅只是想要一个<code>set</code>的<code>size</code>，岂不是杀鸡用了宰牛刀了？而且，uv数据一定要精确吗？uv数据存在一些误差可不可以？有没有更好的解决方案？</p><p>uv数据当然可以存在误差，更好的解决方案当然有。那就是redis的<code>HyperLogLog</code>。</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>本文主角<code>HyperLogLog</code>，redis的一种数据结构，可能不被大多数人知道，但却是非常有用的数据。</p><h3 id="HyperLogLog是什么"><a href="#HyperLogLog是什么" class="headerlink" title="HyperLogLog是什么"></a>HyperLogLog是什么</h3><p>Redis 在 <code>2.8.9</code> 版本添加了HyperLogLog结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>可见，专业的人做专业的事，HyperLogLog在做基数统计方面是一流的。</p><h3 id="HyperLogLog怎么玩"><a href="#HyperLogLog怎么玩" class="headerlink" title="HyperLogLog怎么玩"></a>HyperLogLog怎么玩</h3><h4 id="HyperLogLog的三个指令"><a href="#HyperLogLog的三个指令" class="headerlink" title="HyperLogLog的三个指令:"></a><code>HyperLogLog</code>的三个指令:</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>PFADD key element [element …]</td><td>添加指定元素到 HyperLogLog 中。</td></tr><tr><td>PFCOUNT key [key …]</td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td>PFMERGE destkey sourcekey [sourcekey …]</td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><p>以计算uv为例，假如统计网站首页uv人数，路径<code>/index</code>，我们使用<code>pfadd</code>增加计数，<code>pfcount</code>统计人数。使用方式类似于<code>set</code>集合的<code>sadd</code>和<code>scard</code>。</p><pre><code>127.0.0.1:6379[1]&gt; pfadd /index user_1(integer) 1127.0.0.1:6379[1]&gt; pfadd /index user_2(integer) 1127.0.0.1:6379[1]&gt; pfcount /index(integer) 2127.0.0.1:6379[1]&gt; pfadd /index user_3(integer) 1127.0.0.1:6379[1]&gt; pfcount /index(integer) 3127.0.0.1:6379[1]&gt; pfadd /index user_4(integer) 1127.0.0.1:6379[1]&gt; pfcount /index(integer) 4127.0.0.1:6379[1]&gt; pfadd /index user_1(integer) 0127.0.0.1:6379[1]&gt; pfcount /index(integer) 4127.0.0.1:6379[1]&gt; pfadd /index user_5 user_6 user_7(integer) 1127.0.0.1:6379[1]&gt; pfcount /index(integer) 7</code></pre><p>目前看数值都是正确的，我们用程序加大user数据看看精确度怎么样。</p><p>此处用Python实现吧，你懂的，毕竟人生苦短。</p><pre><code># coding: utf-8import redisdef start_test():    r = redis.Redis(host=&#39;localhost&#39;, port=6379, decode_responses=True)    client = redis.StrictRedis()    for i in range(100000):        client.pfadd(&quot;/index&quot;, &quot;user%d&quot; % i)    print(&quot;用户真实人数:&quot;, 100000, &quot;,统计uv数:&quot; , client.pfcount(&quot;/index&quot;))if __name__ == &#39;__main__&#39;:    start_test();</code></pre><p>输出结果:</p><pre><code>用户真实人数: 100000 ,统计uv数: 99723</code></pre><p>可见正确率有<code>99.723%</code>，误差可以接受的范围</p><h3 id="HyperLogLog的底层原理"><a href="#HyperLogLog的底层原理" class="headerlink" title="HyperLogLog的底层原理"></a>HyperLogLog的底层原理</h3><p>建议阅读文章：<a href="https://blog.csdn.net/firenet1/article/details/77247649" target="_blank" rel="noopener">神奇的HyperLogLog算法</a></p><p>其底层的实现原理还是比较复杂，感兴趣的童鞋可以多多了解。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在统计不是很要求精确的统计计数时，可以考虑使用redis的<code>HyperLogLog</code>数据结构。它的占用内存非常小，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。当数值非常大时，它的优势就越发明显。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前几天，我司大牛分享redis知识点，讲到redis数据结构的时候，抛出一个问题：如果要统计网站uv，你准备怎么实现？&lt;/p&gt;
&lt;p&gt;和大多数普通开发人员一样，想到的第一个想法是存到set集合里。可是这样真的好吗？&lt;/p&gt;
&lt;p&gt;后来找到了更好的方式，redis“冷门”数据结构:&lt;code&gt;HyperLogLog&lt;/code&gt;。（说是“冷门”，可能只是我不知道罢了:D）&lt;/p&gt;
    
    </summary>
    
      <category term="redis" scheme="https://www.chenruiwen.cn/categories/redis/"/>
    
    
      <category term="redis" scheme="https://www.chenruiwen.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Java SE1.6中的Synchronized</title>
    <link href="https://www.chenruiwen.cn/java-concurrency/java-concurrency-se-16-synchronized/"/>
    <id>https://www.chenruiwen.cn/java-concurrency/java-concurrency-se-16-synchronized/</id>
    <published>2018-07-29T08:40:24.000Z</published>
    <updated>2018-07-29T09:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftquomgo3sj20m80ciq4e.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>多线程并发，你最先想到的加锁使用方式是什么？我想几乎百分百会想到这个关键字:<code>Synchronized</code>。</p><p>关于<code>Synchronized</code>的底层原理，可能大部分java程序猿都没有太多的了解。本文将洞悉<code>Synchronized</code>那些小细节。</p><p>本文摘自 <a href="https://www.infoq.com/" target="_blank" rel="noopener">infoq</a> 上阿里巴巴的技术专家<a href="https://www.infoq.com/cn/profile/%E6%96%B9%E8%85%BE%E9%A3%9E" target="_blank" rel="noopener">方腾飞</a>老师的文章。</p><p>原文地址：<a href="https://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener">聊聊并发（二）Java SE1.6中的Synchronized</a></p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在多线程并发编程中Synchronized一直是元老级角色，很多人都会称呼它为重量级锁，但是随着Java SE1.6对Synchronized进行了各种优化之后，有些情况下它并不那么重了，本文详细介绍了Java SE1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。</p><h2 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h2><table><thead><tr><th>术语</th><th>英文</th><th>说明 </th></tr></thead><tbody><tr><td>CAS</td><td>Compare and Swap</td><td>比较并设置。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令cmpxchg实现。比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</td></tr></tbody></table><h2 id="同步的基础"><a href="#同步的基础" class="headerlink" title="同步的基础"></a>同步的基础</h2><p>Java中的每一个对象都可以作为锁。</p><ul><li>对于同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前对象的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁存在哪里呢？锁里面会存储什么信息呢？</p><h2 id="同步的原理"><a href="#同步的原理" class="headerlink" title="同步的原理"></a>同步的原理</h2><p>JVM规范规定JVM基于进入和退出<code>Monitor</code>对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。<code>monitorenter</code>指令是在编译后插入到同步代码块的开始位置，而<code>monitorexit</code>是插入到方法结束处和异常处， JVM要保证每个<code>monitorenter</code>必须有对应的<code>monitorexit</code>与之配对。任何对象都有一个 <code>monitor</code> 与之关联，当且一个<code>monitor</code> 被持有后，它将处于锁定状态。线程执行到 <code>monitorenter</code> 指令时，将会尝试获取对象所对应的 <code>monitor</code> 的所有权，即尝试获得对象的锁。</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word（字宽）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。</p><table><thead><tr><th>长度</th><th>内容</th><th>说明 </th></tr></thead><tbody><tr><td>32/64bit</td><td>Mark Word</td><td>存储对象的hashCode或锁信息等。</td></tr><tr><td>32/64bit</td><td>Class Metadata Address</td><td>存储到对象类型数据的指针</td></tr><tr><td>32/64bit</td><td>Array length</td><td>数组的长度（如果当前对象是数组）</td></tr></tbody></table><p>Java对象头里的<code>Mark Word</code>里默认存储对象的<code>HashCode</code>，分代年龄和锁标记位。32位JVM的<code>Mark Word</code>的默认存储结构如下：</p><table>    <tr>        <th></th>        <th>25 bit</th>        <th>4bit</th>        <th>1bit是否是偏向锁</th>        <th>2bit锁标志位</th>    </tr>    <tr>        <th>无锁状态</th>        <th>对象的hashCode</th>        <th>对象分代年龄</th>        <th>0</th>        <th>01</th>    </tr></table><p>在运行期间<code>Mark Word</code>里存储的数据会随着锁标志位的变化而变化。<code>Mark Word</code>可能变化为存储以下4种数据：</p><table>    <tr>        <th rowspan="2">锁状态</th>        <th colspan="2">25 bit</th>        <th rowspan="2">4bit</th>        <th>1bit</th>        <th>2bit</th>    </tr>    <tr>        <th>23bit</th>        <th>2bit</th>        <th>是否是偏向锁</th>        <th>锁标志位</th>    </tr>    <tr>        <th>轻量级锁</th>        <th colspan="4">指向栈中锁记录的指针</th>        <th>00</th>    </tr>    <tr>        <th>重量级锁</th>        <th colspan="4">指向互斥量（重量级锁）的指针</th>        <th>10</th>    </tr>    <tr>        <th>GC标记</th>        <th colspan="4">空</th>        <th>11</th>    </tr>    <tr>        <th>偏向锁</th>        <th>线程ID</th>        <th>Epoch</th>        <th>对象分代年龄</th>        <th>1</th>        <th>01</th>    </tr></table><p>在64位虚拟机下，<code>Mark Word</code>是64bit大小的，其存储结构如下： </p><table>    <tr>        <th rowspan="2">锁状态</th>        <th>25 bit</th>        <th>31bit</th>        <th>1bit</th>        <th>4bit</th>        <th>1bit</th>        <th>2bit</th>    </tr>    <tr>        <th></th>        <th></th>        <th>cms_free</th>        <th>分代年龄</th>        <th>偏向锁</th>        <th>锁标志位</th>    </tr>    <tr>        <th>无锁</th>        <th>unused</th>        <th>hashCode</th>        <th></th>        <th></th>        <th>0</th>        <th>01</th>    </tr>    <tr>        <th>偏向锁</th>        <th colspan="2">ThreadID(54bit) Epoch(2bit)</th>        <th></th>        <th></th>        <th>1</th>        <th>01</th>    </tr></table><h3 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h3><p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，<code>无锁状态</code>，<code>偏向锁状态</code>，<code>轻量级锁状态</code>和<code>重量级锁状态</code>，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率，下文会详细分析。</p><p><img src="https://ws1.sinaimg.cn/large/87faef88ly1ftqrb6oxy3j20ol03w74r.jpg" alt=""></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p>偏向锁的撤销：偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p><p><img src="https://ws1.sinaimg.cn/large/87faef88ly1ftqrib054vj20o10qxjx1.jpg" alt=""></p><p>关闭偏向锁：偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟<code>-XX:BiasedLockingStartupDelay=0</code>。如果你确定自己应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁<code>-XX:-UseBiasedLocking=false</code>，那么默认会进入轻量级锁状态。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁加锁：线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为<code>Displaced Mark Word</code>。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p><p>轻量级锁解锁：轻量级解锁时，会使用原子的CAS操作来将<code>Displaced Mark Word</code>替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p><p><img src="https://ws1.sinaimg.cn/large/87faef88ly1ftqroqob22j20o10ncgs6.jpg" alt=""></p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><h2 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h2><table>    <tr>        <th>锁</th>        <th>优点</th>        <th>缺点</th>        <th>适用场景</th>    </tr>    <tr>        <th>偏向锁</th>        <th>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</th>        <th>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</th>        <th>适用于只有一个线程访问同步块场景。</th>    </tr>    <tr>        <th>轻量级锁</th>        <th>竞争的线程不会阻塞，提高了程序的响应速度。</th>        <th>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</th>        <th>追求响应时间。<br>同步块执行速度非常快。</th>    </tr>    <tr>        <th>重量级锁</th>        <th>线程竞争不使用自旋，不会消耗CPU。</th>        <th>线程阻塞，响应时间缓慢。</th>        <th>追求吞吐量。<br>同步块执行速度较长。</th>    </tr></table><h2 id="参考源码"><a href="#参考源码" class="headerlink" title="参考源码"></a>参考源码</h2><p>本文一些内容参考了<a href="https://hg.openjdk.java.net/jdk/jdk/file/2ce72467c4e8/src/hotspot/share" target="_blank" rel="noopener">HotSpot</a>源码 。对象头源码<code>markOop.hpp</code>。偏向锁源码<code>biasedLocking.cpp</code>。以及其他源码<code>ObjectMonitor.cpp</code>和<code>BasicLock.cpp</code>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf" target="_blank" rel="noopener">偏向锁</a></li><li><a href="https://pdffinder.net/Java-Overview-and-Java-SE-6-What&#39;s-New.html" target="_blank" rel="noopener">java-overview-and-java-se6</a> Synchronization Optimization章节</li><li>Dave Dice <a href="https://home.comcast.net/~pjbishop/Dave/MustangSync.pdf" target="_blank" rel="noopener"> “Synchronization in Java SE 6”</a></li><li><a href="https://java.sun.com/performance/reference/whitepapers/6_performance.html#2.1.3" target="_blank" rel="noopener">Java SE 6 Performance White Paper </a> 2.1章节</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/index.html" target="_blank" rel="noopener">JVM规范（Java SE 7）</a></li><li><a href="https://docs.oracle.com/javase/specs/jls/se7/html/" target="_blank" rel="noopener">Java语言规范（JAVA SE7）</a></li><li><a href="https://book.douban.com/subject/6522893/" target="_blank" rel="noopener">周志明的《深入理解Java虚拟机》</a></li><li><a href="https://kenwublog.com/theory-of-java-biased-locking" target="_blank" rel="noopener">Java偏向锁实现原理</a></li><li><a href="https://wikis.oracle.com/display/HotSpotInternals/Synchronization" target="_blank" rel="noopener">hotspot Synchronization</a></li></ul><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>java中锁的四种状态:无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。各有千秋，并且锁会随着竞争情况逐渐升级，且不会降级，好处是提高获得锁和释放锁的效率。</p><p>关于四种锁的使用，还是要分场景和尽量多的测试性能。</p><p>关于<code>synchronized</code>，早起的版本效率很低，从java6开始有了较多的优化。如果生成环境的jdk版本较低,低于1.5，建议尽量少使用，同步尽量使用<code>ReentrantLock</code>。如果jdk版本比较高，java8以后还是可以考虑<code>synchronized</code>的，效率并不差。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>最后，还是非常感谢本文的原创作者:</p><p><strong>方腾飞</strong>，阿里巴巴资深软件开发工程师，致力于高性能网络和并发编程，目前在公司从事询盘管理和长连接服务器OpenComet的开发工作。</p><ul><li>博客地址：<a href="https://ifeve.com" target="_blank" rel="noopener">https://ifeve.com</a> </li><li>微博地址：<a href="https://weibo.com/kirals" target="_blank" rel="noopener">https://weibo.com/kirals</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftquomgo3sj20m80ciq4e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;多线程并发，你最先想到的加锁使用方式是什么？我想几乎百分百会想到这个关键字:&lt;code&gt;Synchronized&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;Synchronized&lt;/code&gt;的底层原理，可能大部分java程序猿都没有太多的了解。本文将洞悉&lt;code&gt;Synchronized&lt;/code&gt;那些小细节。&lt;/p&gt;
&lt;p&gt;本文摘自 &lt;a href=&quot;https://www.infoq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;infoq&lt;/a&gt; 上阿里巴巴的技术专家&lt;a href=&quot;https://www.infoq.com/cn/profile/%E6%96%B9%E8%85%BE%E9%A3%9E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;方腾飞&lt;/a&gt;老师的文章。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.infoq.com/cn/articles/java-se-16-synchronized&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;聊聊并发（二）Java SE1.6中的Synchronized&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java-concurrency" scheme="https://www.chenruiwen.cn/categories/java-concurrency/"/>
    
    
      <category term="java" scheme="https://www.chenruiwen.cn/tags/java/"/>
    
      <category term="转载摘抄" scheme="https://www.chenruiwen.cn/tags/%E8%BD%AC%E8%BD%BD%E6%91%98%E6%8A%84/"/>
    
      <category term="java concurrency" scheme="https://www.chenruiwen.cn/tags/java-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot优雅使用redis集中式缓存</title>
    <link href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-cache-redis/"/>
    <id>https://www.chenruiwen.cn/spring-boot/spring-boot-use-cache-redis/</id>
    <published>2018-07-25T12:26:10.000Z</published>
    <updated>2018-07-25T12:40:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/87faef88ly1ftmdpcaqwwj20dw08cq2w.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章<a href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-cache-guava/">spring-boot优雅的使用缓存</a>介绍了使用spring3开始的cache功能，并使用<code>guava</code>实现完成一次示例。但是在分布式环境下，进程内的本地缓存是独立的，在一些场景并不使用。</p><p>在现在互联网企业中广泛使用了一些中间件比如<code>memcache</code>,<code>redis</code>等来实现分布式环境下的集中式缓存。本文将介绍spring-boot下集成redis做缓存的实现细节。</p><a id="more"></a><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p><a href="https://redis.io/" target="_blank" rel="noopener">redis</a>是开源免费的、高性能key-value数据库。它的特点主要有：</p><ul><li>高性能，基于内存内的数据结构，读写性能都很好</li><li>支持持久化，数据支持写进磁盘</li><li>数据结构有五种形式，string,list，set，zset，hash，各有特点，使用场景广泛。</li><li>高可用，支持集群</li><li>支持发布/订阅</li></ul><p>现如今大多公司使用<code>redis</code>，大有替代<code>memcache</code>的意思(具体根据业务场景选型)。</p><h2 id="集成redis"><a href="#集成redis" class="headerlink" title="集成redis"></a>集成redis</h2><p>依旧三步完成redis缓存：</p><ul><li>maven依赖</li><li>配置redis和缓存</li><li>代码使用及测试</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p><code>1.4.x</code>版本的spring-boot可依赖如下:</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>但是从<code>1.5.x</code>开始已经被废弃，请依赖如下:</p><pre><code>&lt;!-- redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置文件application-yml添加redis相关配置，以及缓存开启为redis"><a href="#配置文件application-yml添加redis相关配置，以及缓存开启为redis" class="headerlink" title="配置文件application.yml添加redis相关配置，以及缓存开启为redis."></a>配置文件<code>application.yml</code>添加<code>redis</code>相关配置，以及缓存开启为<code>redis</code>.</h3><pre><code>spring:# redis  redis:    database: 2    host: 127.0.0.1    port: 6379    password:    pool:      max-active: 8      max-wait: -1      max-idle: 8      min-idle: 0    timeout: 0# cache  cache:    type: redis</code></pre><h3 id="代码使用及单元测试"><a href="#代码使用及单元测试" class="headerlink" title="代码使用及单元测试"></a>代码使用及单元测试</h3><h4 id="redis的配置类"><a href="#redis的配置类" class="headerlink" title="redis的配置类"></a>redis的配置类</h4><p>在<code>spring-boot-autoconfigure</code>包中的<code>RedisAutoConfiguration</code>类中有自动装配了<code>RedisConnectionFactory</code>,<code>RedisTemplate</code>,无需多配置即可完成直接调用即可。</p><p>但是此处我们想要定制<code>RedisTemplate</code>,因为默认的<code>RedisTemplate</code>的<code>keySerializer</code>和<code>valueSerializer</code>都是默认的<code>JdkSerializationRedisSerializer</code>。由于业务的需要(强迫症+颜控)，我们希望<code>key</code>是字符串类型，<code>value</code>是json格式。如下修改<code>RedisTemplate</code>的序列化格式即可:</p><pre><code class="java">@Beanpublic RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {    RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();    redisTemplate.setConnectionFactory(redisConnectionFactory);    // 使用Jackson2JsonRedisSerialize 替换默认序列化    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);    ObjectMapper objectMapper = new ObjectMapper();    objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);    objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);    // 设置value的序列化规则和 key的序列化规则    redisTemplate.setKeySerializer(new StringRedisSerializer());    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);    redisTemplate.afterPropertiesSet();    return redisTemplate;}</code></pre><h4 id="cache配置使用redis"><a href="#cache配置使用redis" class="headerlink" title="cache配置使用redis"></a>cache配置使用redis</h4><p>当<code>application.yml</code>指定为<code>spring.cache.type=redis</code>时，即已经会自动加载<code>spring-boot-autoconfigure</code>包中的<code>RedisCacheConfiguration</code>,从源码中可以看到它自动装配了<code>RedisCacheManager</code>，原则上无需配置直接使用即可。</p><p>但是此处默认的<code>RedisCacheManager</code>不没有设置过期时间，即不过期。这显然不合理。因此需要自定义<code>RedisCacheManager</code>。</p><p>有两种方式自定义<code>RedisCacheManager</code>:</p><ul><li>直接装配<code>RedisCacheManager</code></li><li>装配<code>CacheManagerCustomizer</code></li></ul><p>方式一. 直接手动装配<code>RedisCacheManager</code>方式如下:</p><pre><code class="java">@Beanpublic CacheManager redisCacheManager(RedisTemplate redisTemplate) {    RedisCacheManager redisCacheManager = new RedisCacheManager(redisTemplate);    redisCacheManager.setDefaultExpiration(60L); // 默认缓存 1 分钟    redisCacheManager.setUsePrefix(true);    Map&lt;String, Long&gt; expires = new ConcurrentHashMap&lt;String, Long&gt;(2);    expires.put(&quot;userCache&quot;, 90L); // 指定 cacheName 缓存时间    redisCacheManager.setExpires(expires);    return redisCacheManager;}</code></pre><p>方式二. spring boot添加了可扩展<code>RedisCacheManager</code>的方式，即<code>CacheManagerCustomizer</code>接口。可通过装配<code>CacheManagerCustomizer</code>的实现，实现其<code>customize(T cacheManager)</code>方法即可实现自定义：</p><pre><code class="java">@Beanpublic CacheManagerCustomizer redisCacheManagerCustomizer() {    return (CacheManagerCustomizer&lt;RedisCacheManager&gt;) cacheManager -&gt; {        cacheManager.setDefaultExpiration(60L);// 默认过期时间，单位秒        Map&lt;String, Long&gt; expires = new ConcurrentHashMap&lt;&gt;(2);        expires.put(&quot;userCache&quot;, 2000L); // 指定 cacheName 缓存时间        cacheManager.setExpires(expires);    };}</code></pre><h4 id="测试redis操作"><a href="#测试redis操作" class="headerlink" title="测试redis操作"></a>测试redis操作</h4><p>首先测试通过<code>redisTemplate</code>来操作redis。测试用例:</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class RedisTemplateTest {    @Autowired    private StringRedisTemplate redisTemplate;    @Test    public void test() {        redisTemplate.opsForValue().set(&quot;key1&quot;, &quot;value1&quot;);        String value1 = redisTemplate.opsForValue().get(&quot;key1&quot;);        Assert.assertEquals(&quot;value1&quot;, value1);    }}</code></pre><p>调用正常结束，查看redis库中有此缓存。</p><h4 id="测试redis缓存"><a href="#测试redis缓存" class="headerlink" title="测试redis缓存"></a>测试redis缓存</h4><p>比如我们有个User服务，代码如下:</p><pre><code class="java">@Service@CacheConfig(cacheNames = &quot;userCache&quot;)public class SbpUserServiceImpl implements SbpUserService {    @Resource    private SbpUserMapper sbpUserMapper;    @Override    @CachePut(key = &quot;&#39;id:&#39;+ #p0.id&quot;)    public SbpUser insert(SbpUser user) {        sbpUserMapper.insert(user);        return user;    }    @Override    @CachePut(key = &quot;&#39;id:&#39;+ #p0.id&quot;)    public SbpUser update(SbpUser user) {        sbpUserMapper.updateByPrimaryKey(user);        return user;    }    @Override    @CacheEvict(allEntries = true, beforeInvocation = true)// 清空 userCache 缓存    public int insertList(List&lt;SbpUser&gt; list) {        return sbpUserMapper.insertList(list);    }    @Override    public Page&lt;SbpUser&gt; getListPageInfo(int pageNo, int pageSize) {        // 开启分页        Page&lt;SbpUser&gt; page = PageHelper.startPage(pageNo, pageSize);        sbpUserMapper.getAll();        return page;    }    @Override    @CacheEvict(key = &quot;&#39;id:&#39;+#id&quot;, beforeInvocation = true)    public boolean deleteById(Long id) {        return sbpUserMapper.deleteByPrimaryKey(id) &gt; 0;    }    @Override    @Cacheable(key = &quot;&#39;id:&#39;+ #id&quot;)    public SbpUser getObjectById(Long id) {        return sbpUserMapper.selectByPrimaryKey(id);    }}</code></pre><p>说明:</p><ul><li><code>@CacheConfig(cacheNames = &quot;userCache&quot;)</code>注解表示<code>SbpUserServiceImpl</code>服务下的所有缓存的前缀加上了”userCache”。注意前提是<code>RedisCacheManager</code>配置的<code>usePrefix</code>为<code>true</code>时才生效。</li><li><code>@CachePut</code>注解使得数据更新时放入缓存，此处在<code>insert</code>和<code>update</code>方法时都使用了此注解更新缓存。</li><li><code>@CacheEvict</code>注解用在<code>delete</code>方法上，并配置了删除时清空”userCache”里的缓存。</li><li><code>@Cacheable</code>设置了查询缓存。</li></ul><p>单元测试用例:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)@Slf4jpublic class SbpUserServiceTest {    @Autowired    private SbpUserService sbpUserService;    @Autowired    private RedisTemplate redisTemplate;    @Test    public void testRedisCache() {        long now = System.currentTimeMillis();        SbpUser user1 = SbpUser.builder().id(666L).mobile(&quot;11100006666&quot;)                .nickName(&quot;老A&quot;).password(&quot;111111&quot;)                .createAt(now).updateAt(now).build();        sbpUserService.insert(user1);        log.info(&quot;~~~~~~~~~~~~~insert data~~~~~~~~~~~~~~~~~~~~~~&quot;);        log.info(&quot;=============first select start===============&quot;);        SbpUser user2 = sbpUserService.getObjectById(666L);        log.info(&quot;=============first select end=================,user:{}&quot;, user2);        user2.setNickName(&quot;老B&quot;);        sbpUserService.update(user2);        log.info(&quot;~~~~~~~~~~~~~update data~~~~~~~~~~~~~~~~~~~~~~&quot;);        log.info(&quot;=============second select start===============&quot;);        SbpUser user3 = sbpUserService.getObjectById(666L);        log.info(&quot;=============second select end=================,user:{}&quot;, user3);        sbpUserService.deleteById(666L);        log.info(&quot;~~~~~~~~~~~~~delete data~~~~~~~~~~~~~~~~~~~~~~&quot;);        log.info(&quot;=============third select start===============&quot;);        SbpUser user4 = sbpUserService.getObjectById(666L);        log.info(&quot;=============third select end=================,user:{}&quot;, user4);        assert 666L == sbpUserService.insert(SbpUser.builder().id(666L).mobile(&quot;11100006666&quot;)                .nickName(&quot;老A&quot;).password(&quot;111111&quot;)                .createAt(now).updateAt(now).build()).getId();        redisTemplate.delete(&quot;userCache:id:666&quot;); // 手动删除redis缓存        log.info(&quot;~~~~~~~~~~~~~insert data and delete cache~~~~~~~~~~~~~~~~~~~~~~&quot;);        log.info(&quot;=============fourth select start===============&quot;);        SbpUser user5 = sbpUserService.getObjectById(666L);        log.info(&quot;=============fourth select end=================,user:{}&quot;, user5);    }}</code></pre><p>控制台输出:</p><pre><code>JDBC Connection [com.mysql.jdbc.JDBC4Connection@759f45f1] will not be managed by Spring==&gt;  Preparing: insert into sbp_user (id, nick_name, password, mobile, create_at, update_at ) values (?, ?, ?, ?, ?, ? ) ==&gt; Parameters: 666(Long), 老A(String), 111111(String), 11100006666(String), 1532439901401(Long), 1532439901401(Long)&lt;==    Updates: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@552ffa44]2018-07-24 21:45:02.196 [main] INFO  com.crw.service.SbpUserServiceTest - ~~~~~~~~~~~~~insert data~~~~~~~~~~~~~~~~~~~~~~2018-07-24 21:45:02.199 [main] INFO  com.crw.service.SbpUserServiceTest - =============first select start===============2018-07-24 21:45:02.280 [main] INFO  com.crw.service.SbpUserServiceTest - =============first select end=================,user:SbpUser(id=666, nickName=老A, password=111111, mobile=11100006666, createAt=1532439901401, updateAt=1532439901401)Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@578198d9] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.jdbc.JDBC4Connection@759f45f1] will not be managed by Spring==&gt;  Preparing: update sbp_user set nick_name = ?, password = ?, mobile = ?, create_at = ?, update_at = ? where id = ? ==&gt; Parameters: 老B(String), 111111(String), 11100006666(String), 1532439901401(Long), 1532439901401(Long), 666(Long)&lt;==    Updates: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@578198d9]2018-07-24 21:45:02.286 [main] INFO  com.crw.service.SbpUserServiceTest - ~~~~~~~~~~~~~update data~~~~~~~~~~~~~~~~~~~~~~2018-07-24 21:45:02.287 [main] INFO  com.crw.service.SbpUserServiceTest - =============second select start===============2018-07-24 21:45:02.289 [main] INFO  com.crw.service.SbpUserServiceTest - =============second select end=================,user:SbpUser(id=666, nickName=老B, password=111111, mobile=11100006666, createAt=1532439901401, updateAt=1532439901401)Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3ff53704] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.jdbc.JDBC4Connection@759f45f1] will not be managed by Spring==&gt;  Preparing: delete from sbp_user where id = ? ==&gt; Parameters: 666(Long)&lt;==    Updates: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3ff53704]2018-07-24 21:45:02.298 [main] INFO  com.crw.service.SbpUserServiceTest - ~~~~~~~~~~~~~delete data~~~~~~~~~~~~~~~~~~~~~~2018-07-24 21:45:02.298 [main] INFO  com.crw.service.SbpUserServiceTest - =============third select start===============Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@31b289da] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.jdbc.JDBC4Connection@759f45f1] will not be managed by Spring==&gt;  Preparing: select id, nick_name, password, mobile, create_at, update_at from sbp_user where id = ? ==&gt; Parameters: 666(Long)&lt;==      Total: 0Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@31b289da]2018-07-24 21:45:02.326 [main] INFO  com.crw.service.SbpUserServiceTest - =============third select end=================,user:nullCreating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@58a7ca42] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.jdbc.JDBC4Connection@759f45f1] will not be managed by Spring==&gt;  Preparing: insert into sbp_user (id, nick_name, password, mobile, create_at, update_at ) values (?, ?, ?, ?, ?, ? ) ==&gt; Parameters: 666(Long), 老A(String), 111111(String), 11100006666(String), 1532439901401(Long), 1532439901401(Long)&lt;==    Updates: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@58a7ca42]2018-07-24 21:45:02.332 [main] INFO  com.crw.service.SbpUserServiceTest - ~~~~~~~~~~~~~insert data and delete cache~~~~~~~~~~~~~~~~~~~~~~2018-07-24 21:45:02.332 [main] INFO  com.crw.service.SbpUserServiceTest - =============fourth select start===============Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@16890f00] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.jdbc.JDBC4Connection@759f45f1] will not be managed by Spring==&gt;  Preparing: select id, nick_name, password, mobile, create_at, update_at from sbp_user where id = ? ==&gt; Parameters: 666(Long)&lt;==    Columns: id, nick_name, password, mobile, create_at, update_at&lt;==        Row: 666, 老A, 111111, 11100006666, 1532439901401, 1532439901401&lt;==      Total: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@16890f00]2018-07-24 21:45:02.338 [main] INFO  com.crw.service.SbpUserServiceTest - =============fourth select end=================,user:SbpUser(id=666, nickName=老A, password=111111, mobile=11100006666, createAt=1532439901401, updateAt=1532439901401)2018-07-24 21:45:02.343 [Thread-4] INFO  org.springframework.web.context.support.GenericWebApplicationContext - Closing org.springframework.web.context.support.GenericWebApplicationContext@1556f2dd: startup date [Tue Jul 24 21:44:55 CST 2018]; root of context hierarchyDisconnected from the target VM, address: &#39;127.0.0.1:51531&#39;, transport: &#39;socket&#39;Process finished with exit code 0</code></pre><p>输出结果分析：</p><ol><li>第一次查询在插入数据之后，并没有打印查询sql表明是从缓存查询。即<code>insert</code>操作的<code>@CachePut</code>注解其效果。</li><li>第二次查询在修改数据之后，也没有打印查询sql表明从缓存查询。继续观察输出的<code>user</code>对象，nickName已经从“老A”变为“老B”了。即<code>update</code>操作的<code>@CachePut</code>注解其效果。</li><li>第三次查询在删除数据之后，打印sql说明未从缓存查询。继续观察输出的<code>user</code>对象为null,说明<code>delete</code>操作的<code>@CacheEvict</code>注解其效果。</li><li>第四次查询在插入数据并删除缓存的情况下，打印sql了说明从数据库查询。再连接redis可以看到：<img src="https://ws1.sinaimg.cn/large/87faef88ly1ftlbyqd2wjj20vk0d841c.jpg" alt="">图上，redis已有缓存，说明<code>select</code>操作也会增加redis缓存。并且输出格式正如<code>RedisTemplate</code>配置的那样，<code>key</code>为字符串,<code>value</code>为json格式。同时设置的缓存时间为2000秒。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/87faef88ly1ftmdpcaqwwj20dw08cq2w.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章&lt;a href=&quot;https://www.chenruiwen.cn/spring-boot/spring-boot-use-cache-guava/&quot;&gt;spring-boot优雅的使用缓存&lt;/a&gt;介绍了使用spring3开始的cache功能，
并使用&lt;code&gt;guava&lt;/code&gt;实现完成一次示例。但是在分布式环境下，进程内的本地缓存是独立的，在一些场景并不使用。&lt;/p&gt;
&lt;p&gt;在现在互联网企业中广泛使用了一些中间件比如&lt;code&gt;memcache&lt;/code&gt;,&lt;code&gt;redis&lt;/code&gt;等来实现分布式环境下的集中式缓存。
本文将介绍spring-boot下集成redis做缓存的实现细节。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="cache" scheme="https://www.chenruiwen.cn/tags/cache/"/>
    
      <category term="redis" scheme="https://www.chenruiwen.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot优雅的使用缓存</title>
    <link href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-cache-guava/"/>
    <id>https://www.chenruiwen.cn/spring-boot/spring-boot-use-cache-guava/</id>
    <published>2018-07-22T14:45:10.000Z</published>
    <updated>2018-07-23T08:50:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftj1n4e5e2j20iz075q2y.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果说如何优化你的网站或者应用，大部分同学第一的反应可能就是<code>缓存</code>。缓存不是万能的，但是当用户和访问量加大的情况下，缓存是提高应用吞吐量非常有效的手段。</p><p>本文主要介绍如果通过spring-boot使用本地缓存，以<code>guava cache</code>为例。其实从spring3开始就已经提供了基于注解的缓存支持，其原理还是基于<code>aop</code>的思想，降低了缓存代码对我们应用代码的侵入。</p><a id="more"></a><h2 id="spring-cache相关接口及注解"><a href="#spring-cache相关接口及注解" class="headerlink" title="spring cache相关接口及注解"></a>spring cache相关接口及注解</h2><p>从spring3开始，spring支持基于注解的缓存组件。其核心接口俩个，在<code>spring-context</code>包中:</p><ul><li>Cache</li><li>CacheManager</li></ul><p>spring中实现优雅使用缓存的方式还是基于注解的方式，其中常用的一些注解也是在<code>spring-context</code>包中。</p><p>接下来分别看下这些接口。</p><h3 id="Cache-接口"><a href="#Cache-接口" class="headerlink" title="Cache 接口"></a>Cache 接口</h3><p><code>Cache</code>接口，提供操作缓存的定义(比如放入、读取、清理等。</p><p>其中<code>Cache</code>接口Spring也提供了很多默认的实现，它们在<code>spring-context</code>包和<code>spring-context-support</code>包中:<img src="https://ww1.sinaimg.cn/large/87faef88ly1ftinmijpmuj21cw0pkjzh.jpg" alt=""></p><p><code>Cache</code>接口:</p><pre><code class="java">public interface Cache {    // cacheName，缓存的名字，默认实现中一般是CacheManager创建Cache的bean时传入cacheName    String getName();    // 获取实际使用的缓存，如：RedisTemplate、com.github.benmanes.caffeine.cache.Cache&lt;Object, Object&gt;。暂时没发现实际用处，可能只是提供获取原生缓存的bean，以便需要扩展一些缓存操作或统计之类的东西    Object getNativeCache();    // 通过key获取缓存值，注意返回的是ValueWrapper，为了兼容存储空值的情况，将返回值包装了一层，通过get方法获取实际值    ValueWrapper get(Object key);    // 通过key获取缓存值，返回的是实际值，即方法的返回值类型    &lt;T&gt; T get(Object key, Class&lt;T&gt; type);    // 通过key获取缓存值，可以使用valueLoader.call()来调使用@Cacheable注解的方法。当@Cacheable注解的sync属性配置为true时使用此方法。因此方法内需要保证回源到数据库的同步性。避免在缓存失效时大量请求回源到数据库    &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader);    // 将@Cacheable注解方法返回的数据放入缓存中    void put(Object key, Object value);    // 当缓存中不存在key时才放入缓存。返回值是当key存在时原有的数据    ValueWrapper putIfAbsent(Object key, Object value);    // 删除缓存    void evict(Object key);    // 删除缓存中的所有数据。需要注意的是，具体实现中只删除使用@Cacheable注解缓存的所有数据，不要影响应用内的其他缓存    void clear();    // 缓存返回值的包装    interface ValueWrapper {        // 返回实际缓存的对象        Object get();    }    // 当{@link #get(Object, Callable)}抛出异常时，会包装成此异常抛出    @SuppressWarnings(&quot;serial&quot;)    class ValueRetrievalException extends RuntimeException {        private final Object key;        public ValueRetrievalException(Object key, Callable&lt;?&gt; loader, Throwable ex) {            super(String.format(&quot;Value for key &#39;%s&#39; could not be loaded using &#39;%s&#39;&quot;, key, loader), ex);            this.key = key;        }        public Object getKey() {            return this.key;        }    }}</code></pre><h3 id="CacheManager-接口"><a href="#CacheManager-接口" class="headerlink" title="CacheManager 接口"></a>CacheManager 接口</h3><p>主要负责缓存<code>Cache</code>接口的管理，提供了根据<code>cacheName</code>获取缓存的接口以及获取所有<code>cacheName</code>的接口。</p><pre><code class="java">public interface CacheManager {    // 通过cacheName创建Cache的实现bean，具体实现中需要存储已创建的Cache实现bean，避免重复创建，也避免内存缓存对象（如Caffeine）重新创建后原来缓存内容丢失的情况    Cache getCache(String name);    // 返回所有的cacheName    Collection&lt;String&gt; getCacheNames();}</code></pre><h3 id="cache-相关注解"><a href="#cache-相关注解" class="headerlink" title="cache 相关注解"></a>cache 相关注解</h3><h4 id="EnableCaching"><a href="#EnableCaching" class="headerlink" title="@EnableCaching"></a>@EnableCaching</h4><p>启用Cache注解支持的总开关。</p><h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>应用到写数据的方法上，如新增/修改方法，调用方法时会自动把相应的数据放入缓存。</p><pre><code class="java">Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut {    // cacheNames，CacheManager就是通过这个名称创建对应的Cache实现bean    @AliasFor(&quot;cacheNames&quot;)    String[] value() default {};    // 含义与`cacheNames`别名一样，等价于value()    @AliasFor(&quot;value&quot;)    String[] cacheNames() default {};    // 缓存的key，支持SpEL表达式。默认是使用所有参数及其计算的hashCode包装后的对象（SimpleKey）    String key() default &quot;&quot;;    // 缓存key生成器，spring4开始默认实现是SimpleKeyGenerator    String keyGenerator() default &quot;&quot;;    // 指定使用的cacheManager    String cacheManager() default &quot;&quot;;    // 缓存解析器    String cacheResolver() default &quot;&quot;;    // 缓存的条件，支持SpEL表达式，当达到满足的条件时才缓存数据。在调用方法前后都会判断    String condition() default &quot;&quot;;    // 满足条件时不更新缓存，支持SpEL表达式，只在调用方法后判断    String unless() default &quot;&quot;;}</code></pre><h4 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h4><p>应用到移除数据的方法上，如删除方法，调用方法时会从缓存中移除相应的数据。</p><p>大部分定义可参考上面<code>@CachePut</code>注解，新增了2个属性:</p><pre><code class="java">@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict {    // 此处省略大部分与CachePut相同的属性...    // 是否要清除所有缓存的数据，为false时调用的是Cache.evict(key)方法；为true时调用的是Cache.clear()方法    boolean allEntries() default false;    // 是否在调用方法之前清除缓存    boolean beforeInvocation() default false;}</code></pre><h4 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h4><p>应用到读取数据的方法上，即可缓存的方法，如查找方法：先从缓存中读取，如果没有再调用方法获取数据，然后把数据添加到缓存中。</p><p>大部分定义可参考上面<code>@CachePut</code>注解，新增了1个属性:</p><pre><code class="java">@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable {    // 此处省略大部分与CachePut相同的属性...    // 回源到实际方法获取数据时，是否要保持同步，如果为false，调用的是Cache.get(key)方法；如果为true，调用的是Cache.get(key, Callable)方法    boolean sync() default false;}</code></pre><h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><p>提供了注解的组合模式，可以在此注解中配置多个Cache注解。</p><pre><code class="java">@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching {    // @Cacheable 数组，可以配置多个Cacheable注解，实现同时查询多个缓存    Cacheable[] cacheable() default {};    // @CachePut 数组，可以配置多个CachePut注解，实现同时存放多个缓存    CachePut[] put() default {};    // @CacheEvict 数组，可以配置多个CacheEvict注解，实现同时删除多个缓存    CacheEvict[] evict() default {};}</code></pre><h2 id="guava-cache"><a href="#guava-cache" class="headerlink" title="guava cache"></a>guava cache</h2><p><code>guava</code>是Google提供的开源的java核心工具类库。其中包含很多好用的工具类，我们这里主要使用<code>guava</code>中的<code>cache</code>包。</p><p><em>为什么要使用guava的cache而不是简单的使用ConcurrentMap呢？或者说这二者的区别在哪？</em></p><p>答：Guava Cache与ConcurrentMap很相似，它们之间的一个根本区别在于缓存可以回收存储的元素。</p><p>guava提供了不同方式的缓存回收策略：</p><ul><li>基于容量的回收</li><li>定时回收</li><li>基于引用的回收</li></ul><h2 id="在spring-boot中使用guava-cache"><a href="#在spring-boot中使用guava-cache" class="headerlink" title="在spring-boot中使用guava cache"></a>在spring-boot中使用guava cache</h2><p>三步完成在spring-boot中使用guava cache:</p><ul><li>maven依赖</li><li>配置缓存类型</li><li>代码中使用guava cache并单元测试</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>maven依赖特别少，由于<code>spring-boot-starter</code>默认并没有依赖上<code>spring-context-support</code>包，所以我们需要依赖上它。如下，引入<code>spring-boot-starter-cache</code>即可。以及引入本地缓存要用到的<code>guava</code>。</p><pre><code>&lt;!-- cache --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- guava --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="配置缓存类型"><a href="#配置缓存类型" class="headerlink" title="配置缓存类型"></a>配置缓存类型</h3><p>由于我们使用guava作为缓存，只需要指明缓存类型为 guava即可。</p><pre><code>spring:  cache:    type: guava</code></pre><h3 id="使用guava-cache"><a href="#使用guava-cache" class="headerlink" title="使用guava cache"></a>使用guava cache</h3><p>一. 配置 CacheManager，并开启缓存功能。</p><pre><code class="java">@EnableCaching@Configurationpublic class CacheConfig {    @Bean    public CacheManager cacheManager() {        GuavaCacheManager cacheManager = new GuavaCacheManager();        cacheManager.setCacheBuilder(CacheBuilder.newBuilder()                .expireAfterWrite(10, TimeUnit.SECONDS).maximumSize(1000));        return cacheManager;    }}</code></pre><p>如上，我配置了缓存写入后保持10秒</p><p>二. 使用注解优雅给接口加上缓存。在访问接口上加上注解。</p><pre><code class="java">@Service@CacheConfig(cacheNames = &quot;product&quot;)public class ProductServiceImpl implements ProductService {    @Resource    private ProductMapper productMapper;    @Override    @Cacheable    public Product getObjectById(Long id) {        return productMapper.selectByPrimaryKey(id);    }}</code></pre><p>三. 测试本地缓存。首先开启<code>mybatis</code>的sql输出打印，修改<code>application.yml</code>的配置，增加如下:</p><pre><code>mybatis:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>测试本地缓存是否起效，以及缓存时间是否其效果。</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)@Slf4jpublic class SbpProductServiceTest {    @Autowired    private ProductService productService;    @Test    @Rollback    public void getObjectById() throws InterruptedException {        Product product1 = productService.getObjectById(1L);        log.info(&quot;time:{} , first get product:{}&quot;, System.currentTimeMillis(), product1);        Product product2 = productService.getObjectById(1L);        log.info(&quot;time:{} , second get product:{}&quot;, System.currentTimeMillis(), product2);        Thread.sleep(15000);        Product product3 = productService.getObjectById(1L);        log.info(&quot;time:{} , third get product:{}&quot;, System.currentTimeMillis(), product3);    }}</code></pre><p>输出如下：</p><pre><code>==&gt;  Preparing: select id, code, type, full_name, alias_name, original_price, vip_price, storage, create_at, update_at from sbp_product where id = ? ==&gt; Parameters: 1(Long)&lt;==    Columns: id, code, type, full_name, alias_name, original_price, vip_price, storage, create_at, update_at&lt;==        Row: 1, BK100001, 1, java编程思想, thinking in java, 86.00, 75.00, 300, 1532260305712, 1532260305712&lt;==      Total: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@25791d40]2018-07-22 19:53:05.534 [main] INFO  com.crw.service.SbpProductServiceTest - time:1532260385532 , first get product:SbpProduct(id=1, code=BK100001, type=1, fullName=java编程思想, aliasName=thinking in java, originalPrice=86.00, vipPrice=75.00, storage=300, createAt=1532260305712, updateAt=1532260305712)2018-07-22 19:53:05.537 [main] INFO  com.crw.service.SbpProductServiceTest - time:1532260385537 , second get product:SbpProduct(id=1, code=BK100001, type=1, fullName=java编程思想, aliasName=thinking in java, originalPrice=86.00, vipPrice=75.00, storage=300, createAt=1532260305712, updateAt=1532260305712)Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6812c8cc] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.jdbc.JDBC4Connection@6075b369] will not be managed by Spring==&gt;  Preparing: select id, code, type, full_name, alias_name, original_price, vip_price, storage, create_at, update_at from sbp_product where id = ? ==&gt; Parameters: 1(Long)&lt;==    Columns: id, code, type, full_name, alias_name, original_price, vip_price, storage, create_at, update_at&lt;==        Row: 1, BK100001, 1, java编程思想, thinking in java, 86.00, 75.00, 300, 1532260305712, 1532260305712&lt;==      Total: 1Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6812c8cc]2018-07-22 19:53:20.547 [main] INFO  com.crw.service.SbpProductServiceTest - time:1532260400547 , third get product:SbpProduct(id=1, code=BK100001, type=1, fullName=java编程思想, aliasName=thinking in java, originalPrice=86.00, vipPrice=75.00, storage=300, createAt=1532260305712, updateAt=1532260305712)2018-07-22 19:53:20.553 [Thread-4] INFO  org.springframework.web.context.support.GenericWebApplicationContext - Closing org.springframework.web.context.support.GenericWebApplicationContext@6853425f: startup date [Sun Jul 22 19:53:01 CST 2018]; root of context hierarchy</code></pre><p>可以看到结果:</p><ol><li>第一次调用打印了sql，此时还没有缓存。</li><li>第二次调用没打印sql，此时有本地缓存了。</li><li>第三次调用又打印sql，此时本地缓存失效。</li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>再来回顾一下，本文介绍了：</p><ul><li>spring cache的使用，它是AOP理念的一个很好的应用</li><li>guava的使用。by the way,从Spring5开始变不再支持guava的实现了，从spring-boot 1.5.x版本你就可以看到<code>autoconfgure</code>包下的<code>GuavaCacheConfiguration</code>以及被注解为<code>@Deprecated</code>了。推荐更好的实现是<a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener">caffeine</a>。</li><li>spring-boot使用哦cache非常方便，三步完成。</li></ul><p>本文参考了：</p><ul><li><a href="http://jinnianshilongnian.iteye.com/blog/2001040" target="_blank" rel="noopener">Spring Cache抽象详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftj1n4e5e2j20iz075q2y.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果说如何优化你的网站或者应用，大部分同学第一的反应可能就是&lt;code&gt;缓存&lt;/code&gt;。缓存不是万能的，但是当用户和访问量加大的情况下，缓存是提高应用吞吐量非常有效的手段。&lt;/p&gt;
&lt;p&gt;本文主要介绍如果通过spring-boot使用本地缓存，以&lt;code&gt;guava cache&lt;/code&gt;为例。其实从spring3开始就已经提供了基于注解的缓存支持，其原理还是基于&lt;code&gt;aop&lt;/code&gt;的思想，降低了缓存代码对我们应用代码的侵入。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="cache" scheme="https://www.chenruiwen.cn/tags/cache/"/>
    
      <category term="guava" scheme="https://www.chenruiwen.cn/tags/guava/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成ActiveMQ</title>
    <link href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-activemq/"/>
    <id>https://www.chenruiwen.cn/spring-boot/spring-boot-use-activemq/</id>
    <published>2018-07-20T11:45:10.000Z</published>
    <updated>2018-07-21T14:44:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgrjn36onj20hj07vglv.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章<a href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-rabbitmq/">spring-boot集成RabbitMQ</a>介绍了spring-boot如何集成RabbitMQ。本篇文章是spring-boot集成MQ的姊妹篇，看看spring-boot如何集成常用的ActiveMQ.<a id="more"></a></p><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><h3 id="JMS是什么"><a href="#JMS是什么" class="headerlink" title="JMS是什么"></a>JMS是什么</h3><p>百度百科：</p><blockquote><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p></blockquote><p>简单的说，JMS是j2ee技术中的提供了访问消息中间件的规范。它的常见实现如ActiveMQ。</p><h3 id="JMS-API简介"><a href="#JMS-API简介" class="headerlink" title="JMS API简介"></a>JMS API简介</h3><p><code>JMS 规范</code>和 <code>javax.jms</code> 包定义一组可供 Java 应用程序用于执行消息传递操作的接口。以下列表概括了主要的 JMS 接口：</p><ul><li>Destination：</li></ul><p>Destination 对象是应用程序将消息发往的位置和/或应用程序从其接收消息的源。</p><ul><li>ConnectionFactory：</li></ul><p>ConnectionFactory 对象包括连接的一组配置属性。应用程序使用连接工厂来创建连接。</p><ul><li>Connection：</li></ul><p>Connection 对象包括应用程序与消息传递服务器的活动连接。应用程序使用连接来创建会话。</p><ul><li>Session：</li></ul><p>Session 对象是用于发送和接收消息的单个线程上下文。应用程序使用会话来创建消息、消息生产者和消息使用者。会话是事务性或非事务性会话。</p><ul><li>Message：</li></ul><p>Message 对象包括应用程序发送或接收的消息。</p><ul><li>MessageProducer：</li></ul><p>应用程序使用消息生产者将消息发送到目标。</p><ul><li>MessageConsumer：</li></ul><p>应用程序使用消息使用者来接收已发送到目标的消息。</p><p>JMS对象及其关系:<img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgomuzm3pj20qo0gf3yu.jpg" alt=""></p><h2 id="ActiveMQ介绍"><a href="#ActiveMQ介绍" class="headerlink" title="ActiveMQ介绍"></a>ActiveMQ介绍</h2><p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。</p><p>特性：</p><ul><li>支持多种语言和协议。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP。</li><li>完全支持JMS1.1和J2EE 1.4规范 （持久化，XA消息，事务)</li><li>对Spring的支持，ActiveMQ可以很容易内嵌到使用Spring的系统里面去</li><li>支持多种传送协议：in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li><li>设计上保证了高性能的集群，客户端-服务器，点对点</li></ul><h2 id="ActiveMQ安装"><a href="#ActiveMQ安装" class="headerlink" title="ActiveMQ安装"></a>ActiveMQ安装</h2><p>通过国外地址下载通常比较慢，所以我们一般通过国内的镜像地址下载。</p><p>一些常用的apache其下的国内镜像地址：</p><ul><li><a href="https://mirrors.hust.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.hust.edu.cn/apache/</a> </li><li><a href="https://mirrors.shu.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.shu.edu.cn/apache/</a> </li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/</a> </li></ul><p>通过<a href="https://mirror.bit.edu.cn/apache/" target="_blank" rel="noopener">国内镜像地址</a>下载</p><pre><code>wget http://mirror.bit.edu.cn/apache/activemq/5.14.5/apache-activemq-5.14.5-bin.tar.gz</code></pre><p>解压：</p><pre><code>tar xf apache-activemq-5.14.5-bin.tar.gz</code></pre><p>启动：</p><pre><code>cd apache-activemq-5.14.5\bin\</code></pre><p>注意：如果一台机器启动RabbitMQ以及ActiveMQ,要注意端口冲突问题。修改ActiveMQ端口,找到<code>..\apache-activemq-5.x.x\conf\</code>目录下的<code>activemq.xml</code>,修改<code>&lt;transportConnectors&gt;</code>标签下的<code>uri</code>属性，比如：</p><pre><code>&lt;transportConnectors&gt;    &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;amqp&quot; uri=&quot;amqp://0.0.0.0:5673?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;stomp&quot; uri=&quot;stomp://0.0.0.0:61613?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;mqtt&quot; uri=&quot;mqtt://0.0.0.0:1883?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;    &lt;transportConnector name=&quot;ws&quot; uri=&quot;ws://0.0.0.0:61614?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;&lt;/transportConnectors&gt;</code></pre><p>如何查看RabbitMQ的端口号？打开web控制台查看即可。</p><h2 id="集成置ActiveMQ"><a href="#集成置ActiveMQ" class="headerlink" title="集成置ActiveMQ"></a>集成置ActiveMQ</h2><p>使用过程与<code>RabbitMQ</code>类似，三步完成：</p><ul><li>maven依赖</li><li>配置ActiveMQ</li><li>编写代码及单元自测</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><pre><code>&lt;!-- activemq --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置ActiveMQ"><a href="#配置ActiveMQ" class="headerlink" title="配置ActiveMQ"></a>配置ActiveMQ</h3><p>在<code>application.yml</code>里添加几行即可:</p><pre><code>spring:  activemq:    broker-url: tcp://127.0.0.1:61616   #activeMQ地址    user: admin                         #用户名    password: admin                     #密码    in-memory: true                     #是否启用内存模式（也就是不安装MQ，项目启动时同时也启动一个MQ实例    pool:      enabled: false                    #是否替换默认的connectionFactory    packages:      trust-all: true                   #信任所有的包</code></pre><h3 id="编写代码及单元自测"><a href="#编写代码及单元自测" class="headerlink" title="编写代码及单元自测"></a>编写代码及单元自测</h3><p>一. 配置一个<code>hello</code>队列：</p><pre><code class="java">@Configurationpublic class MessageQueueConfig {    @Bean    public javax.jms.Queue helloQueueByActiveMQ() {        return new ActiveMQQueue(&quot;hello&quot;);    }}</code></pre><p>二. 消息推送端，向<code>hello</code>队列发送一条消息:</p><pre><code class="java">@Component@Slf4jpublic class HelloActiveMQSender {    @Autowired    private JmsMessagingTemplate jmsMessagingTemplate;    public void send(String content) {        log.info(&quot;ActiveMQ send : {}&quot;, content);        this.jmsMessagingTemplate.convertAndSend(&quot;hello&quot;, content);    }}</code></pre><p>三. 消息消费端，消费一条<code>hello</code>队列里的消息:</p><pre><code class="java">@Slf4j@Component@EnableJmspublic class HelloActiveMQConsumer {    @JmsListener(destination = &quot;hello&quot;)    public void process(String hello) {        log.info(&quot;ActiveMQ receiver : {}&quot;, hello);    }}</code></pre><p>四. 单元测试发送一条消息:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class HelloActiveMQSenderTest {    @Autowired    private HelloActiveMQSender sender;    @Test    public void sendHello() {        sender.send(&quot;Hello &quot; + new Date());    }}</code></pre><p>输出结果，可以确认消息发送并且被消费了：</p><pre><code>2018-07-17 16:56:16.320 [main] INFO  com.crw.mq.HelloActiveMQSender - ActiveMQ send : Hello Tue Jul 17 16:56:16 CST 20182018-07-17 16:56:16.355 [DefaultMessageListenerContainer-1] INFO  com.crw.mq.HelloActiveMQConsumer - ActiveMQ receiver : Hello Tue Jul 17 16:56:16 CST 2018</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgrjn36onj20hj07vglv.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章&lt;a href=&quot;https://www.chenruiwen.cn/spring-boot/spring-boot-use-rabbitmq/&quot;&gt;spring-boot集成RabbitMQ&lt;/a&gt;介绍了spring-boot如何集成RabbitMQ。本篇文章是spring-boot集成MQ的姊妹篇，看看spring-boot如何集成常用的ActiveMQ.
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="ActiveMQ" scheme="https://www.chenruiwen.cn/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成RabbitMQ</title>
    <link href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-rabbitmq/"/>
    <id>https://www.chenruiwen.cn/spring-boot/spring-boot-use-rabbitmq/</id>
    <published>2018-07-19T09:22:10.000Z</published>
    <updated>2018-07-21T12:29:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgrlo2wfzj20ji0atmx4.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>消息队列是日常开发中非常常用的工具，当调用方不需要关心执行结果时，你可以使用它来解耦。本文简单介绍下spring-boot中快速使用RabbitMQ完成队列的发送与消费。<a id="more"></a></p><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><h3 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="AMQP协议"></a>AMQP协议</h3><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。</p><h3 id="消息代理"><a href="#消息代理" class="headerlink" title="消息代理"></a>消息代理</h3><p>消息代理（message brokers）从发布者（publishers）亦称生产者（producers）那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者（consumers）。</p><p>由于AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理 可以存在于不同的设备上。</p><h3 id="AMQP协议模型"><a href="#AMQP协议模型" class="headerlink" title="AMQP协议模型"></a>AMQP协议模型</h3><p>这里推荐直接查看 <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">AMQP 0-9-1 模型解析</a>。</p><h3 id="RabbitMQ与AMQP的关系"><a href="#RabbitMQ与AMQP的关系" class="headerlink" title="RabbitMQ与AMQP的关系"></a>RabbitMQ与AMQP的关系</h3><p><code>RabbitMQ</code>采用<code>Erlang</code>语言开发。是<code>AMQP</code>协议的一个实现。</p><h2 id="安装rabbitMQ"><a href="#安装rabbitMQ" class="headerlink" title="安装rabbitMQ"></a>安装rabbitMQ</h2><p>根据<a href="https://www.rabbitmq.com/install-debian.html" target="_blank" rel="noopener">RabbitMQ文档 Installing on Debian and Ubuntu</a>进行安装。</p><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>一. 下载并安装Erlang。官网下载页：<code>http://www.erlang.org/downloads</code>。</p><p>二. 下载并安装RabbitMQ。官网下载页：<code>https://www.rabbitmq.com/download.html</code>。安装完成后会自动注册到服务中启动。</p><h3 id="Mac-OS-X安装"><a href="#Mac-OS-X安装" class="headerlink" title="Mac OS X安装"></a>Mac OS X安装</h3><p>一. 安装Erlang，执行命令：<code>brew install erlang</code>。</p><p>二. 安装RabbitMQ，执行命令：<code>brew install rabbitmq</code>。</p><h3 id="Ubuntu安装"><a href="#Ubuntu安装" class="headerlink" title="Ubuntu安装"></a>Ubuntu安装</h3><p>一. 安装Erlang，执行命令：<code>apt-get install erlang erlang-nox</code>。</p><p>二. 在系统中加入RabbitMQ apt 仓库:</p><pre><code>echo &#39;deb http://www.rabbitmq.com/debian/ testing main&#39; | sudo tee /etc/apt/sources.list.d/rabbitmq.list</code></pre><p>三. 添加signing key，执行命令:</p><pre><code>wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -。</code></pre><p>四. 更新APT仓库的package list，执行命令:<code>apt-get update</code></p><p>五. 安装Rabbit Server，执行命令：<code>apt-get install rabbitmq-server</code>。</p><h3 id="web控制台"><a href="#web控制台" class="headerlink" title="web控制台"></a>web控制台</h3><p>RabbitMQ内置提供了Web管理插件。</p><ul><li>开启RabbitMQ web管理  <ul><li>Windows系统：进入插件目录:<code>D:\rabbitmq\rabbitmq_server-3.7.7\sbin</code>，运行命令：<pre><code>rabbitmq-plugins.bat enable rabbitmq_management</code></pre></li><li>Linux和Mac系统: 运行命令：<pre><code>rabbitmq-plugins enable rabbitmq_management。</code></pre></li></ul></li><li>通过浏览器访问web管理界面：<code>http://localhost:15672/</code>，默认登录用户:<code>guest</code>,密码:<code>guest</code>。</li></ul><h2 id="spring-boot中使用RabbitMQ"><a href="#spring-boot中使用RabbitMQ" class="headerlink" title="spring-boot中使用RabbitMQ"></a>spring-boot中使用RabbitMQ</h2><p>三步完成集成:</p><ul><li>maven依赖</li><li>配置RabbitMQ</li><li>代码使用及测试</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>仅需添加</p><pre><code>&lt;!-- amqp,用于支持RabbitMQ --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置rabbitMQ"><a href="#配置rabbitMQ" class="headerlink" title="配置rabbitMQ"></a>配置rabbitMQ</h3><p>配置非常简单，在<code>application.yml</code>添加rabbitMQ相关:</p><pre><code class="java"># rabbitMQspring:  rabbitmq:    host: 127.0.0.1    port: 5672    username: guest    password: guest</code></pre><h3 id="代码中使用及测试"><a href="#代码中使用及测试" class="headerlink" title="代码中使用及测试"></a>代码中使用及测试</h3><p>一. 在配置类中创建一个<code>hello</code>队列：</p><pre><code class="java">@Configurationpublic class MessageQueueConfig {    @Bean    public org.springframework.amqp.core.Queue helloQueueByRabbitMQ() {        return new org.springframework.amqp.core.Queue(&quot;hello&quot;);    }}</code></pre><p>二. 消息推送端，向<code>hello</code>队列发送一条消息:</p><pre><code class="java">@Component@Slf4jpublic class HelloRabbitMQSender {    @Autowired    private AmqpTemplate rabbitTemplate;    public void send(String content) {        log.info(&quot;RabbitMQ send : {}&quot;, content);        this.rabbitTemplate.convertAndSend(&quot;hello&quot;, content);    }}</code></pre><p>三. 消息消费端，消费一条<code>hello</code>队列里的消息:</p><pre><code class="java">@Component@RabbitListener(queues = &quot;hello&quot;)@Slf4jpublic class HelloRabbitMQConsumer {    @RabbitHandler    public void process(String hello) {        log.info(&quot;RabbitMQ receiver : {}&quot;, hello);    }}</code></pre><p>四. 单元测试发送一条消息:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class HelloRabbitMQSenderTest {    @Autowired    private HelloRabbitMQSender sender;    @Test    public void sendHello() {        sender.send(&quot;Hello &quot; + new Date());    }}</code></pre><p>输出结果，可以确认消息发送并且被消费了：</p><pre><code>2018-07-16 14:23:09.844 [main] INFO  com.crw.mq.HelloRabbitMQSender - RabbitMQ send : Hello Mon Jul 16 14:23:09 CST 20182018-07-16 14:23:09.872 [SimpleAsyncTaskExecutor-1] INFO  com.crw.mq.HelloRabbitMQConsumer - RabbitMQ receiver : Hello Mon Jul 16 14:23:09 CST 2018</code></pre><p> 这里仅仅简单介绍了使用RabbitMQ基于队列完成简单的点对点的使用，这也是在web开发中最常用的方式(易于系统解耦、消峰)。更多的使用还是参考官方文档。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgrlo2wfzj20ji0atmx4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;消息队列是日常开发中非常常用的工具，当调用方不需要关心执行结果时，你可以使用它来解耦。
本文简单介绍下spring-boot中快速使用RabbitMQ完成队列的发送与消费。
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="RabbitMQ" scheme="https://www.chenruiwen.cn/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>mybatis集成分页插件pageHelper</title>
    <link href="https://www.chenruiwen.cn/spring-boot/mybatis-plugins-pagehelper/"/>
    <id>https://www.chenruiwen.cn/spring-boot/mybatis-plugins-pagehelper/</id>
    <published>2018-07-14T11:32:24.000Z</published>
    <updated>2018-07-21T14:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>web开发少不了分页，本文将简单介绍使用基于<code>spring-boot</code> + <code>mybatis</code> + <code>pageHelper</code>技术实现数据库分页。</p><p>本文算是对上一篇<a href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-mybatis/">spring-boot集成mybatis</a>的一个补充。</p><a id="more"></a><h2 id="pageHelper简介"><a href="#pageHelper简介" class="headerlink" title="pageHelper简介"></a>pageHelper简介</h2><p>使用<code>MyBatis</code>作为数据访问层进行对sql语句分页的最好用的插件。</p><p>建议去<a href="https://pagehelper.github.io/" target="_blank" rel="noopener">pageHelper官网</a>看一看。</p><p>特点：</p><ul><li>物理分页：支持常见的12种数据库。Oracle,MySql,MariaDB,SQLite,DB2,PostgreSQL,SqlServer等。</li><li>支持多种分页方式：支持常见的RowBounds(PageRowBounds)，PageHelper.startPage 方法调用，Mapper 接口参数调用。</li><li>QueryInterceptor 规范：使用 QueryInterceptor 规范，开发插件更轻松。</li></ul><h2 id="集成pageHelper"><a href="#集成pageHelper" class="headerlink" title="集成pageHelper"></a>集成pageHelper</h2><p>三步完成集成：</p><ul><li>maven依赖</li><li>配置pageHelper</li><li>代码使用及测试</li></ul><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>此处依赖在集成了mybatis的基础上增加:</p><pre><code>&lt;!-- pagehelper --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="配置pageHelper"><a href="#配置pageHelper" class="headerlink" title="配置pageHelper"></a>配置pageHelper</h3><p>在<code>application.yml</code>里增加:</p><pre><code># 分页配置pagehelper:  helper-dialect: mysql  reasonable: &quot;true&quot;  support-methods-arguments: &quot;true&quot;  params: count=countSql</code></pre><h3 id="代码使用及测试"><a href="#代码使用及测试" class="headerlink" title="代码使用及测试"></a>代码使用及测试</h3><p>根据<a href="https://pagehelper.github.io/docs/howtouse/#3-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">官网之如何在代码中使用</a>中的推荐，我们使用静态方法<code>PageHelper.startPage</code>来实现分页。</p><p>首先是SbpUserMapper接口增加方法：</p><pre><code class="java">public interface SbpUserMapper {    List&lt;SbpUser&gt; getAll();}</code></pre><p>对应的SbpUserMapper.xml增加sql:</p><pre><code>&lt;select id=&quot;getAll&quot; resultMap=&quot;BaseResultMap&quot;&gt;    SELECT * FROM sbp_user&lt;/select&gt;</code></pre><p>代码使用，传参当前页为1，每页条数显示5条:</p><pre><code>@Test@Rollbackpublic void pageByPageHelper() throws Exception {    PageHelper.startPage(1, 5);    List&lt;SbpUser&gt; users = sbpUserMapper.getAll();    Page&lt;SbpUser&gt; page = (Page&lt;SbpUser&gt;) users;    System.out.println(&quot;total count :&quot; + page.getTotal());    System.out.println(&quot;pages :&quot; + page.getPages());    System.out.println(&quot;data :&quot; + page.getResult());}</code></pre><p>输出:</p><pre><code>total count :21pages :5data :Page{count=true, pageNum=1, pageSize=5, startRow=0, endRow=5, total=21, pages=5, reasonable=true, pageSizeZero=false}</code></pre><p>还有更多的用法请参考官方文档。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>pageHelper还是非常好用的，简单，集成方便，是和mybatis搭配的分页插件首选。除此之外，大家一定要会自行写分页接口，除此之外还要 知其然，知其所以然。看其源码实现与设计理念，得到的不仅仅是分页。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;web开发少不了分页，本文将简单介绍使用基于&lt;code&gt;spring-boot&lt;/code&gt; + &lt;code&gt;mybatis&lt;/code&gt; + &lt;code&gt;pageHelper&lt;/code&gt;技术实现数据库分页。&lt;/p&gt;
&lt;p&gt;本文算是对上一篇&lt;a href=&quot;https://www.chenruiwen.cn/spring-boot/spring-boot-use-mybatis/&quot;&gt;spring-boot集成mybatis&lt;/a&gt;的一个补充。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="mybatis" scheme="https://www.chenruiwen.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成Log4j2</title>
    <link href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-log4j2/"/>
    <id>https://www.chenruiwen.cn/spring-boot/spring-boot-use-log4j2/</id>
    <published>2018-07-13T02:10:10.000Z</published>
    <updated>2018-07-21T12:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在企业级项目里，日志框架种类杂乱不一，尤其是接手一些有些年头的老项目时，各种各样的日志框架依赖和使用让人看的头大。</p><p>如何解决各种各样日志框架的大一统呢？神器<code>Slf4j</code>。</p><p>spring-boot如何利用<code>Slf4j</code>集成其他日志框架？本文将以<code>Log4j2</code>为例。</p><a id="more"></a><h2 id="Slf4j简单介绍"><a href="#Slf4j简单介绍" class="headerlink" title="Slf4j简单介绍"></a>Slf4j简单介绍</h2><p>去<a href="https://www.slf4j.org/" target="_blank" rel="noopener">Slf4j官网</a>瞧一瞧:</p><blockquote><p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.</p></blockquote><p>Slf4j:Simple Logging Facade for Java.<br>它并不是一个类似java.util.logging, logback, log4j等的日志框架实现，而是作为一个门面服务于这些各种日志框架。如同字面含义，类似外观设计模式，提供了一组简单统一的API接口，隐藏了各种日志不一致的复杂性。</p><h2 id="日志框架选型"><a href="#日志框架选型" class="headerlink" title="日志框架选型"></a>日志框架选型</h2><p>几种日志框架简单对比:</p><ul><li><code>log4j</code>:元老级日志框架。它定义的Logger、Appender、Level等概念如今已经被广泛使用，里程碑式的日志框架</li><li><code>java.util.logging</code>:简称<code>j.u.l</code>。java1.4版本引入，功能不如<code>log4j</code>，性能和可用性有限。</li><li><code>logback</code>：<code>log4j</code>升级版。它比<code>log4j</code>增加了不少功能，比如：原生实现了<code>Slf4J</code>,支持XML、Groovy方式配置等，主要是性能比<code>log4j</code>提升不少。</li><li><code>log4j2</code>:同样是<code>log4j</code>升级版。也比<code>log4j</code>添加不少功能，比如多线程下的异步日志等。性能也提升不少。</li></ul><p>至于<code>logback</code>和<code>log4j2</code>性能比对，可以参考网上博文：</p><ul><li><a href="https://blog.csdn.net/yjh1271845364/article/details/70888262" target="_blank" rel="noopener">logback log4j log4j2 性能实测</a></li><li><a href="https://www.jianshu.com/p/570b406bddcd" target="_blank" rel="noopener">看log4j2如何秒杀一切日志组件</a></li></ul><p>根据官方推荐是<code>Slf4j</code>+<code>logback</code>，此处我使用<code>Slf4j2</code>+<code>log4j2</code>来集成日志框架。</p><h2 id="集成Log4j2"><a href="#集成Log4j2" class="headerlink" title="集成Log4j2"></a>集成Log4j2</h2><p>三步完成Log4j2的集成:</p><ol><li>maven依赖</li><li>配置日志文件</li><li>测试日志</li></ol><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>pom.xml：</p><pre><code>&lt;!-- 需要排除logback --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- log4j2 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="配置日志文件"><a href="#配置日志文件" class="headerlink" title="配置日志文件"></a>配置日志文件</h3><p>classpath下添加<code>log4j2.xml</code>:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;OFF&quot;&gt;    &lt;properties&gt;        &lt;property name=&quot;LOG_HOME&quot;&gt;../logs/&lt;/property&gt;        &lt;property name=&quot;STDOUT_FILE_NAME&quot;&gt;stdout&lt;/property&gt;    &lt;/properties&gt;    &lt;appenders&gt;        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;            &lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n&quot;/&gt;        &lt;/Console&gt;        &lt;RollingRandomAccessFile name=&quot;stdout-log&quot;                                 fileName=&quot;${LOG_HOME}/${STDOUT_FILE_NAME}.log&quot;                                 filePattern=&quot;${LOG_HOME}/$${date:yyyy-MM}/${STDOUT_FILE_NAME}-%d{yyyy-MM-dd}-%i.log.gz&quot;&gt;            &lt;PatternLayout                    pattern=&quot;%date{yyyy-MM-dd HH:mm:ss.SSS} %level [%thread][%file:%line] - %msg%n&quot;/&gt;            &lt;Policies&gt;                &lt;TimeBasedTriggeringPolicy/&gt;                &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt;            &lt;/Policies&gt;            &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt;        &lt;/RollingRandomAccessFile&gt;    &lt;/appenders&gt;    &lt;loggers&gt;        &lt;root level=&quot;error&quot;&gt;            &lt;AppenderRef ref=&quot;stdout-log&quot;/&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/root&gt;        &lt;logger name=&quot;com.crw&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;            &lt;AppenderRef ref=&quot;stdout-log&quot;/&gt;            &lt;AppenderRef ref=&quot;Console&quot;/&gt;        &lt;/logger&gt;    &lt;/loggers&gt;&lt;/configuration&gt;</code></pre><p>修改应用日志文件路径，<code>application.yml</code>:</p><pre><code>logging.config: classpath:log4j2.xml</code></pre><h3 id="测试日志"><a href="#测试日志" class="headerlink" title="测试日志"></a>测试日志</h3><p>增加一个EchoController:</p><pre><code class="java">@RestController@Slf4jpublic class EchoController {    @GetMapping(&quot;/echo/hello&quot;)    public String echo(String msg) {        log.debug(&quot;DEBUG ----&gt; echo:{}&quot;, msg);        log.info(&quot;INFO  ----&gt; echo:{}&quot;, msg);        log.warn(&quot;WARN  ----&gt; echo:{}&quot;, msg);        log.error(&quot;ERROR  ----&gt; echo:{}&quot;, msg);        return &quot;hello, &quot; + msg;    }}</code></pre><p>调用接口地址：</p><pre><code>curl http://127.0.0.1:8080/echo/hello?msg=world  </code></pre><p>页面输出：</p><pre><code>hello, world</code></pre><p>stdout.log文件输出：</p><pre><code>2018-07-12 22:56:04.023 INFO [http-nio-8080-exec-3][EchoController.java:17] - INFO  ----&gt; echo:world2018-07-12 22:56:04.024 WARN [http-nio-8080-exec-3][EchoController.java:18] - WARN  ----&gt; echo:world2018-07-12 22:56:04.024 ERROR [http-nio-8080-exec-3][EchoController.java:19] - ERROR  ----&gt; echo:world</code></pre><p>debug级别的日志并未输出和打印在控制台，info级别以上日志打印并输出控制台。可见日志测试成功。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文简单介绍了日志框架的种类已经统一日志API框架<code>Slf4j</code>,除此之外，apache下也有与<code>Slf4j</code>同一职能的框架<code>commons-logging</code>。之后可自行研究一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在企业级项目里，日志框架种类杂乱不一，尤其是接手一些有些年头的老项目时，各种各样的日志框架依赖和使用让人看的头大。&lt;/p&gt;
&lt;p&gt;如何解决各种各样日志框架的大一统呢？神器&lt;code&gt;Slf4j&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;spring-boot如何利用&lt;code&gt;Slf4j&lt;/code&gt;集成其他日志框架？本文将以&lt;code&gt;Log4j2&lt;/code&gt;为例。&lt;/p&gt;
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="log4j" scheme="https://www.chenruiwen.cn/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot集成mybatis</title>
    <link href="https://www.chenruiwen.cn/spring-boot/spring-boot-use-mybatis/"/>
    <id>https://www.chenruiwen.cn/spring-boot/spring-boot-use-mybatis/</id>
    <published>2018-07-12T14:05:24.000Z</published>
    <updated>2018-07-21T12:29:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你是一个j2ee开发工程师，你一定不能不会spring，你一定不能不了解spring-boot，你一定不能不知道最火的orm框架Mybatis。</p><p>本文使用spring-boot集成mybatis，体会下spring-boot + mybatis实现效率开发数据层代码。<a id="more"></a></p><h2 id="一分钟创建工程"><a href="#一分钟创建工程" class="headerlink" title="一分钟创建工程"></a>一分钟创建工程</h2><p>通过idea创建spring-boot项目，<code>File</code>-&gt;<code>New</code>-&gt;<code>Project...</code>:<img src="https://ww1.sinaimg.cn/large/87faef88ly1ft6c5enpelj218w0p6whs.jpg" alt="">点击<code>Next</code>配置你的项目的基础信息，再点击<code>Next</code>，勾选需要的依赖:<img src="https://ww1.sinaimg.cn/large/87faef88ly1ft6c8dos77j21bq0si79c.jpg" alt="">创建完毕。耗时不到半分钟。</p><p>对于非idea使用的用户，可以直接登录<a href="https://start.spring.io" target="_blank" rel="noopener">https://start.spring.io</a>,用同样的方式打包你的程序即可。</p><h2 id="mybatis自动生成代码"><a href="#mybatis自动生成代码" class="headerlink" title="mybatis自动生成代码"></a>mybatis自动生成代码</h2><p>通过mybatis-generator技术来自动生成数据库层相关代码。</p><p>大致分为三步：</p><ol><li>创建表结构。</li><li>配置 generatorConfig.xml</li><li>依赖 mybatis-generator-maven-plugin 并运行创建</li></ol><h3 id="创建表结构"><a href="#创建表结构" class="headerlink" title="创建表结构"></a>创建表结构</h3><p>创建一个简单的用户表：</p><pre><code>CREATE TABLE `sbp_user` (  `id` bigint(20) NOT NULL AUTO_INCREMENT,  `nick_name` varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;昵称&#39;,  `password` varchar(50) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;密码&#39;,  `mobile` varchar(15) DEFAULT NULL COMMENT &#39;手机号码&#39;,  `create_at` bigint(20) NOT NULL,  `update_at` bigint(20) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=100 DEFAULT CHARSET=utf8;</code></pre><h3 id="配置-generatorConfig-xml"><a href="#配置-generatorConfig-xml" class="headerlink" title="配置 generatorConfig.xml"></a>配置 generatorConfig.xml</h3><p>以下配置文件都放置在classpath下：</p><p>generator.properties文件：</p><pre><code>## jdbcjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://10.0.0.20:3306/spring-boot-practice?useUnicode=true&amp;amp;characterEncoding=utf-8jdbc.username=rootjdbc.password=root## modelmodel.targetPackage=com.crw.model## DAOdao.targetPackage=com.crw.mapperdao.type=XMLMAPPER## table.name=product_honortable.name=sbp_user</code></pre><p>generatorConfig.xml文件:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;properties resource=&quot;generator.properties&quot;&gt;&lt;/properties&gt;    &lt;context id=&quot;mysql&quot; defaultModelType=&quot;flat&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;        &lt;commentGenerator&gt;            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;        &lt;/commentGenerator&gt;        &lt;jdbcConnection driverClass=&quot;${jdbc.driverClassName}&quot;                        connectionURL=&quot;${jdbc.url}&quot;                        userId=&quot;${jdbc.username}&quot;                        password=&quot;${jdbc.password}&quot;/&gt;        &lt;javaTypeResolver&gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;        &lt;/javaTypeResolver&gt;        &lt;javaModelGenerator targetPackage=&quot;${model.targetPackage}&quot; targetProject=&quot;src/main/java&quot;&gt;            &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;        &lt;/javaModelGenerator&gt;        &lt;sqlMapGenerator targetPackage=&quot;mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;        &lt;/sqlMapGenerator&gt;        &lt;javaClientGenerator targetPackage=&quot;${dao.targetPackage}&quot; targetProject=&quot;src/main/java&quot; type=&quot;${dao.type}&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;&quot;/&gt;            &lt;property name=&quot;exampleMethodVisibility&quot; value=&quot;false&quot;/&gt;            &lt;property name=&quot;methodNameCalculator&quot; value=&quot;&quot;/&gt;            &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;        &lt;/javaClientGenerator&gt;        &lt;table tableName=&quot;${table.name}&quot; schema=&quot;wealth&quot;               enableUpdateByExample=&quot;true&quot;&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>附录：mybatis generator 配置详解，参考资料：<a href="http://www.jianshu.com/p/e09d2370b796" target="_blank" rel="noopener">http://www.jianshu.com/p/e09d2370b796</a></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;!-- 配置生成器 --&gt;&lt;generatorConfiguration&gt;&lt;!-- 可以用于加载配置项或者配置文件，在整个配置文件中就可以使用${propertyKey}的方式来引用配置项    resource：配置资源加载地址，使用resource，MBG从classpath开始找，比如com/myproject/generatorConfig.properties            url：配置资源加载地质，使用URL的方式，比如file:///C:/myfolder/generatorConfig.properties.    注意，两个属性只能选址一个;    另外，如果使用了mybatis-generator-maven-plugin，那么在pom.xml中定义的properties都可以直接在generatorConfig.xml中使用&lt;properties resource=&quot;&quot; url=&quot;&quot; /&gt; --&gt; &lt;!-- 在MBG工作的时候，需要额外加载的依赖包     location属性指明加载jar/zip包的全路径&lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt;  --&gt;&lt;!--     context:生成一组对象的环境     id:必选，上下文id，用于在生成错误时提示    defaultModelType:指定生成对象的样式        1，conditional：类似hierarchical；        2，flat：所有内容（主键，blob）等全部生成在一个对象中；        3，hierarchical：主键生成一个XXKey对象(key class)，Blob等单独生成一个对象，其他简单属性在一个对象中(record class)    targetRuntime:        1，MyBatis3：默认的值，生成基于MyBatis3.x以上版本的内容，包括XXXBySample；        2，MyBatis3Simple：类似MyBatis3，只是不生成XXXBySample；    introspectedColumnImpl：类全限定名，用于扩展MBG--&gt;&lt;context id=&quot;mysql&quot; defaultModelType=&quot;hierarchical&quot; targetRuntime=&quot;MyBatis3Simple&quot; &gt;    &lt;!-- 自动识别数据库关键字，默认false，如果设置为true，根据SqlReservedWords中定义的关键字列表；        一般保留默认值，遇到数据库关键字（Java关键字），使用columnOverride覆盖     --&gt;    &lt;property name=&quot;autoDelimitKeywords&quot; value=&quot;false&quot;/&gt;    &lt;!-- 生成的Java文件的编码 --&gt;    &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot;/&gt;    &lt;!-- 格式化java代码 --&gt;    &lt;property name=&quot;javaFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultJavaFormatter&quot;/&gt;    &lt;!-- 格式化XML代码 --&gt;    &lt;property name=&quot;xmlFormatter&quot; value=&quot;org.mybatis.generator.api.dom.DefaultXmlFormatter&quot;/&gt;    &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号； --&gt;    &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;    &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;    &lt;!-- 必须要有的，使用这个配置链接数据库        @TODO:是否可以扩展     --&gt;    &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql:///pss&quot; userId=&quot;root&quot; password=&quot;admin&quot;&gt;        &lt;!-- 这里面可以设置property属性，每一个property属性都设置到配置的Driver上 --&gt;    &lt;/jdbcConnection&gt;    &lt;!-- java类型处理器         用于处理DB中的类型到Java中的类型，默认使用JavaTypeResolverDefaultImpl；        注意一点，默认会先尝试使用Integer，Long，Short等来对应DECIMAL和 NUMERIC数据类型；     --&gt;    &lt;javaTypeResolver type=&quot;org.mybatis.generator.internal.types.JavaTypeResolverDefaultImpl&quot;&gt;        &lt;!--             true：使用BigDecimal对应DECIMAL和 NUMERIC数据类型            false：默认,                scale&gt;0;length&gt;18：使用BigDecimal;                scale=0;length[10,18]：使用Long；                scale=0;length[5,9]：使用Integer；                scale=0;length&lt;5：使用Short；         --&gt;        &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;    &lt;/javaTypeResolver&gt;    &lt;!-- java模型创建器，是必须要的元素        负责：1，key类（见context的defaultModelType）；2，java类；3，查询类        targetPackage：生成的类要放的包，真实的包受enableSubPackages属性控制；        targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录     --&gt;    &lt;javaModelGenerator targetPackage=&quot;com._520it.mybatis.domain&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;!--  for MyBatis3/MyBatis3Simple            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；         --&gt;        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;!-- for MyBatis3 / MyBatis3Simple            是否创建一个不可变的类，如果为true，            那么MBG会创建一个没有setter方法的类，取而代之的是类似constructorBased的类         --&gt;        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;        &lt;!-- 设置一个根对象，            如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项            注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括：                1，属性名相同，类型相同，有相同的getter/setter方法；         --&gt;        &lt;property name=&quot;rootClass&quot; value=&quot;com._520it.mybatis.domain.BaseDomain&quot;/&gt;        &lt;!-- 设置是否在getter方法中，对String类型字段调用trim()方法 --&gt;        &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;    &lt;/javaModelGenerator&gt;    &lt;!-- 生成SQL map的XML文件生成器，        注意，在Mybatis3之后，我们可以使用mapper.xml文件+Mapper接口（或者不用mapper接口），            或者只使用Mapper接口+Annotation，所以，如果 javaClientGenerator配置中配置了需要生成XML的话，这个元素就必须配置        targetPackage/targetProject:同javaModelGenerator     --&gt;    &lt;sqlMapGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; targetProject=&quot;src/main/resources&quot;&gt;        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;    &lt;/sqlMapGenerator&gt;    &lt;!-- 对于mybatis来说，即生成Mapper接口，注意，如果没有配置该元素，那么默认不会生成Mapper接口         targetPackage/targetProject:同javaModelGenerator        type：选择怎么生成mapper接口（在MyBatis3/MyBatis3Simple下）：            1，ANNOTATEDMAPPER：会生成使用Mapper接口+Annotation的方式创建（SQL生成在annotation中），不会生成对应的XML；            2，MIXEDMAPPER：使用混合配置，会生成Mapper接口，并适当添加合适的Annotation，但是XML会生成在XML中；            3，XMLMAPPER：会生成Mapper接口，接口完全依赖XML；        注意，如果context是MyBatis3Simple：只支持ANNOTATEDMAPPER和XMLMAPPER    --&gt;    &lt;javaClientGenerator targetPackage=&quot;com._520it.mybatis.mapper&quot; type=&quot;ANNOTATEDMAPPER&quot; targetProject=&quot;src/main/java&quot;&gt;        &lt;!-- 在targetPackage的基础上，根据数据库的schema再生成一层package，最终生成的类放在这个package下，默认为false --&gt;        &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;        &lt;!-- 可以为所有生成的接口添加一个父接口，但是MBG只负责生成，不负责检查        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;         --&gt;    &lt;/javaClientGenerator&gt;    &lt;!-- 选择一个table来生成相关文件，可以有一个或多个table，必须要有table元素        选择的table会生成一下文件：        1，SQL map文件        2，生成一个主键类；        3，除了BLOB和主键的其他字段的类；        4，包含BLOB的类；        5，一个用户生成动态查询的条件类（selectByExample, deleteByExample），可选；        6，Mapper接口（可选）        tableName（必要）：要生成对象的表名；        注意：大小写敏感问题。正常情况下，MBG会自动的去识别数据库标识符的大小写敏感度，在一般情况下，MBG会            根据设置的schema，catalog或tablename去查询数据表，按照下面的流程：            1，如果schema，catalog或tablename中有空格，那么设置的是什么格式，就精确的使用指定的大小写格式去查询；            2，否则，如果数据库的标识符使用大写的，那么MBG自动把表名变成大写再查找；            3，否则，如果数据库的标识符使用小写的，那么MBG自动把表名变成小写再查找；            4，否则，使用指定的大小写格式查询；        另外的，如果在创建表的时候，使用的&quot;&quot;把数据库对象规定大小写，就算数据库标识符是使用的大写，在这种情况下也会使用给定的大小写来创建表名；        这个时候，请设置delimitIdentifiers=&quot;true&quot;即可保留大小写格式；        可选：        1，schema：数据库的schema；        2，catalog：数据库的catalog；        3，alias：为数据表设置的别名，如果设置了alias，那么生成的所有的SELECT SQL语句中，列名会变成：alias_actualColumnName        4，domainObjectName：生成的domain类的名字，如果不设置，直接使用表名作为domain类的名字；可以设置为somepck.domainName，那么会自动把domainName类再放到somepck包里面；        5，enableInsert（默认true）：指定是否生成insert语句；        6，enableSelectByPrimaryKey（默认true）：指定是否生成按照主键查询对象的语句（就是getById或get）；        7，enableSelectByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询语句；        8，enableUpdateByPrimaryKey（默认true）：指定是否生成按照主键修改对象的语句（即update)；        9，enableDeleteByPrimaryKey（默认true）：指定是否生成按照主键删除对象的语句（即delete）；        10，enableDeleteByExample（默认true）：MyBatis3Simple为false，指定是否生成动态删除语句；        11，enableCountByExample（默认true）：MyBatis3Simple为false，指定是否生成动态查询总条数语句（用于分页的总条数查询）；        12，enableUpdateByExample（默认true）：MyBatis3Simple为false，指定是否生成动态修改语句（只修改对象中不为空的属性）；        13，modelType：参考context元素的defaultModelType，相当于覆盖；        14，delimitIdentifiers：参考tableName的解释，注意，默认的delimitIdentifiers是双引号，如果类似MYSQL这样的数据库，使用的是`（反引号，那么还需要设置context的beginningDelimiter和endingDelimiter属性）        15，delimitAllColumns：设置是否所有生成的SQL中的列名都使用标识符引起来。默认为false，delimitIdentifiers参考context的属性        注意，table里面很多参数都是对javaModelGenerator，context等元素的默认属性的一个复写；     --&gt;    &lt;table tableName=&quot;userinfo&quot; &gt;        &lt;!-- 参考 javaModelGenerator 的 constructorBased属性--&gt;        &lt;property name=&quot;constructorBased&quot; value=&quot;false&quot;/&gt;        &lt;!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； --&gt;        &lt;property name=&quot;ignoreQualifiersAtRuntime&quot; value=&quot;false&quot;/&gt;        &lt;!-- 参考 javaModelGenerator 的 immutable 属性 --&gt;        &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;        &lt;!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 --&gt;        &lt;property name=&quot;modelOnly&quot; value=&quot;false&quot;/&gt;        &lt;!-- 参考 javaModelGenerator 的 rootClass 属性         &lt;property name=&quot;rootClass&quot; value=&quot;&quot;/&gt;         --&gt;        &lt;!-- 参考javaClientGenerator 的  rootInterface 属性        &lt;property name=&quot;rootInterface&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 如果设置了runtimeCatalog，那么在生成的SQL中，使用该指定的catalog，而不是table元素上的catalog         &lt;property name=&quot;runtimeCatalog&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 如果设置了runtimeSchema，那么在生成的SQL中，使用该指定的schema，而不是table元素上的schema         &lt;property name=&quot;runtimeSchema&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 如果设置了runtimeTableName，那么在生成的SQL中，使用该指定的tablename，而不是table元素上的tablename         &lt;property name=&quot;runtimeTableName&quot; value=&quot;&quot;/&gt;        --&gt;        &lt;!-- 注意，该属性只针对MyBatis3Simple有用；            如果选择的runtime是MyBatis3Simple，那么会生成一个SelectAll方法，如果指定了selectAllOrderByClause，那么会在该SQL中添加指定的这个order条件；         --&gt;        &lt;property name=&quot;selectAllOrderByClause&quot; value=&quot;age desc,username asc&quot;/&gt;        &lt;!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate --&gt;        &lt;property name=&quot;useActualColumnNames&quot; value=&quot;false&quot;/&gt;        &lt;!-- generatedKey用于生成生成主键的方法，            如果设置了该元素，MBG会在生成的&lt;insert&gt;元素中生成一条正确的&lt;selectKey&gt;元素，该元素可选            column:主键的列名；            sqlStatement：要生成的selectKey语句，有以下可选项：                Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                DB2       :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL()                DB2_MF    :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1                Derby      :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL()                HSQLDB      :相当于selectKey的SQL为：CALL IDENTITY()                Informix  :相当于selectKey的SQL为：select dbinfo(&#39;sqlca.sqlerrd1&#39;) from systables where tabid=1                MySql      :相当于selectKey的SQL为：SELECT LAST_INSERT_ID()                SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY()                SYBASE      :相当于selectKey的SQL为：SELECT @@IDENTITY                JDBC      :相当于在生成的insert元素上添加useGeneratedKeys=&quot;true&quot;和keyProperty属性        &lt;generatedKey column=&quot;&quot; sqlStatement=&quot;&quot;/&gt;         --&gt;        &lt;!--             该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候，            比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等；            那么就可以设置searchString为&quot;^CUST_&quot;，并使用空白替换，那么生成的Customer对象中的属性名称就不是            custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email；            注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的，            如果使用了columnOverride元素，该属性无效；        &lt;columnRenamingRule searchString=&quot;&quot; replaceString=&quot;&quot;/&gt;         --&gt;         &lt;!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；             column:要重新设置的列名；             注意，一个table元素中可以有多个columnOverride元素哈~          --&gt;         &lt;columnOverride column=&quot;username&quot;&gt;             &lt;!-- 使用property属性来指定列要生成的属性名称 --&gt;             &lt;property name=&quot;property&quot; value=&quot;userName&quot;/&gt;             &lt;!-- javaType用于指定生成的domain的属性类型，使用类型的全限定名             &lt;property name=&quot;javaType&quot; value=&quot;&quot;/&gt;              --&gt;             &lt;!-- jdbcType用于指定该列的JDBC类型              &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;              --&gt;             &lt;!-- typeHandler 用于指定该列使用到的TypeHandler，如果要指定，配置类型处理器的全限定名                 注意，mybatis中，不会生成到mybatis-config.xml中的typeHandler                 只会生成类似：where id = #{id,jdbcType=BIGINT,typeHandler=com._520it.mybatis.MyTypeHandler}的参数描述             &lt;property name=&quot;jdbcType&quot; value=&quot;&quot;/&gt;             --&gt;             &lt;!-- 参考table元素的delimitAllColumns配置，默认为false             &lt;property name=&quot;delimitedColumnName&quot; value=&quot;&quot;/&gt;              --&gt;         &lt;/columnOverride&gt;         &lt;!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现              column:指定要忽略的列的名字；             delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false             注意，一个table元素中可以有多个ignoreColumn元素         &lt;ignoreColumn column=&quot;deptId&quot; delimitedColumnName=&quot;&quot;/&gt;         --&gt;    &lt;/table&gt;&lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><h3 id="通过mybatis-generator-maven-plugin插件生产代码"><a href="#通过mybatis-generator-maven-plugin插件生产代码" class="headerlink" title="通过mybatis-generator-maven-plugin插件生产代码"></a>通过mybatis-generator-maven-plugin插件生产代码</h3><p>配置maven依赖：</p><pre><code>&lt;build&gt;    &lt;plugins&gt;        ...        &lt;!-- mybatis generator--&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.4&lt;/version&gt;            &lt;configuration&gt;                &lt;verbose&gt;true&lt;/verbose&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;            &lt;/configuration&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;5.1.41&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;</code></pre><p>运行命令：</p><pre><code>mvn mybatis-generator:generate</code></pre><p>即可生成相应的代码至相应的配置目录。</p><h2 id="集成mybatis"><a href="#集成mybatis" class="headerlink" title="集成mybatis"></a>集成mybatis</h2><p>三步完成集成：</p><ol><li>添加maven依赖</li><li>配置数据源和Mybatis</li><li>单元测试</li></ol><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><p>依赖spring-boot相关以及jdbc相关：</p><pre><code>&lt;dependencies&gt;    &lt;!-- spring-boot相关 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;!-- mybatis --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.3.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.41&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.0.18&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h3 id="配置数据源和Mybatis"><a href="#配置数据源和Mybatis" class="headerlink" title="配置数据源和Mybatis"></a>配置数据源和Mybatis</h3><p>配置spring-boot的<code>application.yml</code>(如果喜欢用<code>application.properties</code>)的改成相应的格式即可。</p><p>如下创建连接池和mybatis配置：</p><pre><code># jdbc-DruidDataSource连接池配置sbp.datasource:  type: com.alibaba.druid.pool.DruidDataSource  driver-class-name: com.mysql.jdbc.Driver  url: jdbc:mysql://127.0.0.1:3306/spring-boot-practice?useUnicode=true&amp;amp;characterEncoding=utf8mb4&amp;amp;useSSL=false&amp;amp;autoReconnect=true  username: root  password: root# mybatismybatis:  mapperLocations: classpath:mapper/*.xml  configuration.mapUnderscoreToCamelCase: true</code></pre><p>创建DataSource,映射配置文件内容，扫描mapper接口：</p><pre><code class="java">@Configuration@MapperScan(basePackages = &quot;com.crw.mapper&quot;)public class DataSourceConfig {    @Bean    @ConfigurationProperties(prefix = &quot;sbp.datasource&quot;)    public DataSource datasource() {        return new DruidDataSource();    }}</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>测试mybatis是否正常:</p><pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = App.class)public class SbpUserMapperTest {    @Autowired    private SbpUserMapper sbpUserMapper;    @Test    @Rollback    public void insert() throws Exception {        long now = System.currentTimeMillis();        int id = sbpUserMapper.insert(new SbpUser(1L, &quot;张三&quot;, &quot;111111&quot;, &quot;11100001001&quot;, now, now));        Assert.assertEquals(id, 1L);    }    @Test    @Rollback    public void selectByPrimaryKey() throws Exception {        SbpUser user = sbpUserMapper.selectByPrimaryKey(1L);        Assert.assertEquals(&quot;张三&quot;, user.getNickName());    }    @Test    @Rollback    public void update() throws Exception {        long now = System.currentTimeMillis();        sbpUserMapper.updateByPrimaryKey(new SbpUser(1L, &quot;张三改&quot;, &quot;111111&quot;, &quot;11100001001&quot;, now, now));        SbpUser user = sbpUserMapper.selectByPrimaryKey(1L);        Assert.assertEquals(&quot;张三改&quot;, user.getNickName());    }    @Test    @Rollback    public void selectByExample() throws Exception {        SbpUserExample example = new SbpUserExample();        SbpUserExample.Criteria criteria = example.createCriteria();        criteria.andMobileEqualTo(&quot;11100001001&quot;);        List&lt;SbpUser&gt; users = sbpUserMapper.selectByExample(example);        Assert.assertEquals(users.size(), 1);    }}</code></pre><p>运行之后正常CRUD，完成spring-boot与Mybatis的集成。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本篇文章从创建spring-boot项目开始介绍了集成mybatis的过程。可以见到spring-boot是多么的高效：</p><ul><li>一分钟(半分钟)创建spring-boot项目</li><li>三步完成myybatis代码自动生成</li><li>三步配置集成mybatis</li></ul><p>前后大概10分钟时间绰绰有余了。效率是不是不差于世界上最好的PHP呢？(:D)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果你是一个j2ee开发工程师，你一定不能不会spring，你一定不能不了解spring-boot，你一定不能不知道最火的orm框架Mybatis。&lt;/p&gt;
&lt;p&gt;本文使用spring-boot集成mybatis，体会下spring-boot + mybatis实现效率开发数据层代码。
    
    </summary>
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/categories/spring-boot/"/>
    
    
      <category term="spring-boot" scheme="https://www.chenruiwen.cn/tags/spring-boot/"/>
    
      <category term="mybatis" scheme="https://www.chenruiwen.cn/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>java并发修行之基础篇：线程安全</title>
    <link href="https://www.chenruiwen.cn/java-concurrency/java-concurrency-base-threadsafe/"/>
    <id>https://www.chenruiwen.cn/java-concurrency/java-concurrency-base-threadsafe/</id>
    <published>2018-07-09T14:16:24.000Z</published>
    <updated>2018-07-21T14:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在互联网应用广泛的今天，软件并发已经成为目前软件开发的必备基础。java作为一门成熟的语言，其拥有着极其高效的并发机制，是目前大中型企业的常用开发语言。想要开发大规模应用，java并发已成为java程序猿们的必备基础技能。</p><p>从今天开始，开启java并发修行之路。</p><a id="more"></a><h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2><p>线程的安全性总是难以定义的。在阅读<a href="https://item.jd.com/10922250.html" target="_blank" rel="noopener">《java并发编程实战》</a>的过程中觉得说的很好：</p><blockquote><p>在线程安全性的定义中，最核心的概念就是正确性。</p></blockquote><p>何为正确性？</p><blockquote><p>某个类的行为与其规范完全一致。</p></blockquote><p>通常我们并不规定类的规范，于是我们通俗对正确性的理解是，单线程的类的行为是按照我们“所见”来运行的，我们确保其可信，“所见即所知”。</p><p>于是给出线程安全性的定义：</p><blockquote><p>当多个线程访问某个类时，这个类始终都能表现出正确的行为。</p></blockquote><p>某个对象保证多线程环境下共享、可修改的状态的正确性，那么即是线程安全。</p><p>换个角度分析：</p><ul><li>当某个类单线程条件都不是正确的，那么其肯定不是线程安全的。</li><li>无状态对象一定线程安全</li><li>状态不共享或不可修改，即不存在线程安全问题。</li></ul><h2 id="如何做到线程安全"><a href="#如何做到线程安全" class="headerlink" title="如何做到线程安全"></a>如何做到线程安全</h2><p>线程安全要保证：</p><ol><li>原子性。保证一组相关操作在竞态条件下保证结果可靠。</li><li>可见性。当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li>有序性。避免指令重排序。</li></ol><p>解释一下上面三个安全特性：</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>关键词：<code>一组相关操作</code>、<code>竞态条件</code>。</p><p>先解释<code>竞态条件</code>：</p><blockquote><p>当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。</p></blockquote><p>简单的说，其本质就是基于了一个错误的状态去判断或执行计算。</p><p>上代码举例。比如一个多线程累加并打印偶数的程序。</p><h4 id="程序A："><a href="#程序A：" class="headerlink" title="程序A："></a>程序A：</h4><p>典型的竞态条件无处理:</p><pre><code class="java">public class EchoEvenNumService implements Runnable {    private int num;    @Override    public void run() {        if (num % 2 == 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.print(num + &quot;\t&quot;);        }        num++;    }}</code></pre><p>运行main程序:</p><pre><code class="java">public static void main(String[] args) {    EchoEvenNumService service = new EchoEvenNumService();    for (int i = 0; i &lt; 100; i++) {        new Thread(service).start();    }}</code></pre><p>结果是可想而知的，奇数偶数都有：</p><pre><code>0    1    1    2    4    3    2    1    1    9    9    10    9    9    9    9    10    9    18    18    18    20    21    22    20    20    19 ...</code></pre><h4 id="程序B"><a href="#程序B" class="headerlink" title="程序B"></a>程序B</h4><p>有些同学会觉得，num改成线程安全的类型(<code>AtomicInteger</code>)就可以了，可是事实是这样吗？修改程序A:</p><pre><code class="java">public class EchoEvenNumService implements Runnable {    private AtomicInteger num = new AtomicInteger(0);    @Override    public void run() {        if (num.get() % 2 == 0) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.print(num.get() + &quot;\t&quot;);        }        num.incrementAndGet();    }}</code></pre><p>运行main方法后，你会发现还是奇数偶数都有：</p><pre><code>0    0    2    3    4    5    5    5    5    7    9    6    6    13    14    14    14    15    18    14    17    20    20    17    21    25    25    26    28    28    29    30 ...</code></pre><p>这么写是因为没有理解<code>一组相关操作</code>。在上面的程序中，实际上需要做到三个操作：1.num.get() % 2 == 0判断。2.打印偶数。3.num递增。</p><p>即时上面三个操作各做各的做到了原子性，但是整体并不是原子性，程序依旧会错误。</p><h4 id="程序C"><a href="#程序C" class="headerlink" title="程序C"></a>程序C</h4><p>做到整体的原子性，加锁同步。修改程序A：</p><pre><code class="java">public class EchoEvenNumService implements Runnable {    private int num;    private ReentrantLock lock = new ReentrantLock();    @Override    public void run() {        try {            lock.lock();            if (num % 2 == 0) {                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.print(num + &quot;\t&quot;);            }            num++;        } finally {            lock.unlock();        }    }}</code></pre><p>运行main方法后，程序终于保证了正确性:</p><pre><code>0    2    4    6    8    10    12    14    16    18    20    22    24    26    28    30    32    34    36    38    40    42    44    46    48    50    52    54    56    58    60    62    64    66    68    70    72    74    76    78    80    82    84    86    88    90    92    94    96    98    </code></pre><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>保证共享变量有效。这里需要简单提一下Java的内存模型:<img src="https://ww1.sinaimg.cn/large/87faef88ly1ft3q0csqw0j20jn0fudgv.jpg" alt=""></p><p>看图说话:  </p><ul><li>主内存(Main Memory),存储所有变量。</li><li>工作内存(Working Memory),保存了该线程使用到的变量的主存副本拷贝。</li><li>线程、工作内存、主存三者关系：线程对变量的所有操作(读写等)都必须在工作内存中进行，而不能之间读写主内存中的变量。</li></ul><p>如此可见，如果程序没有保证可见性，会使一部分线程读取到的是工作内存中的值(并不一定准确)，导致程序不正确执行。</p><p>如何保证可见性？手段：加锁，volatile修饰。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>解释下“重排序”现象：</p><blockquote><p>在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。</p></blockquote><p>比如赋值两个变量:</p><pre><code class="java">private int a;private int b;</code></pre><p>线程A对a,b进行赋值,代码中的逻辑是这样的:</p><pre><code class="java">a = 1;b = 2;</code></pre><p>线程A在运行时，对a变量赋值发现a变量在主存中被其他线程加锁不能访问，线程A并不会等待锁释放，它会去尝试获取b变量，当b变量没有被占用时，线程A的执行过程就会变成这样:</p><pre><code class="java">b = 2;a = 1;</code></pre><p>这就是JVM内部优化导致的“指令重排序”。</p><p>重排序可能导致一些重要的状态值的读取顺序改变导致程序异常甚至会死循环发生OOM。</p><p>比如如下程序：</p><pre><code class="java">public class NoVisibility {    private static boolean ready;    private static int number;    private static class ReaderThread extends Thread {        public void run() {            while (!ready)                Thread.yield();            System.out.println(number);        }    }    public static void main(String[] args) {        new ReaderThread().start();        number = 42;        ready = true;    }}</code></pre><p>这个程序的诡异之处在于，ReaderThread可能永远看不到ready值，更诡异的是ReaderThread的输出可能是0，ReaderThread只读到了ready的值但没有读到number值。这一切“归功于”神奇的“重排序”。</p><p>解决方式:同步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文java并发修行的第一篇，重在基础。本文简单讲解了线程安全的“定义”，以及线程安全的一些基础概念。核心在于线程并发处理共享变量时的三点保证：<code>原子性</code>，<code>可见性</code>，<code>有序性</code>。细细体会之，后续准备从源码层面详细对这三点进行分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在互联网应用广泛的今天，软件并发已经成为目前软件开发的必备基础。java作为一门成熟的语言，其拥有着极其高效的并发机制，是目前大中型企业的常用开发语言。想要开发大规模应用，java并发已成为java程序猿们的必备基础技能。&lt;/p&gt;
&lt;p&gt;从今天开始，开启java并发修行之路。&lt;/p&gt;
    
    </summary>
    
      <category term="java-concurrency" scheme="https://www.chenruiwen.cn/categories/java-concurrency/"/>
    
    
      <category term="java" scheme="https://www.chenruiwen.cn/tags/java/"/>
    
      <category term="java concurrency" scheme="https://www.chenruiwen.cn/tags/java-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>从一份配置清单详解Nginx服务器配置</title>
    <link href="https://www.chenruiwen.cn/nginx/explain-nginx-server-config/"/>
    <id>https://www.chenruiwen.cn/nginx/explain-nginx-server-config/</id>
    <published>2018-07-03T23:46:12.000Z</published>
    <updated>2018-07-21T12:26:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Nginx是现在企业上用的比较多的高性能的HTTP和反向代理服务器。入门Nginx一定少不了学习它的配置文件。本文将比较详细的介绍一下Nginx的各个配置项。</p><p>本文转载自<a href="https://my.oschina.net/hansonwang99" target="_blank" rel="noopener">CodeSheep</a>的技术博文。</p><p>原文地址:<a href="https://my.oschina.net/hansonwang99/blog/1835408" target="_blank" rel="noopener">https://my.oschina.net/hansonwang99/blog/1835408</a></p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在前面<a href="https://www.jianshu.com/p/dc61f1789f47" target="_blank" rel="noopener">《Nginx服务器开箱体验》</a> 一文中我们从开箱到体验，感受了一下Nginx服务器的魅力。Nginx是轻量级的高性能Web服务器，提供了诸如HTTP代理和反向代理、负载均衡、缓存等一系列重要特性，因而在实践之中使用广泛，笔者也在学习和实践之中。</p><p>在本文中，我们继续延续前文，从前文给出的一份示例配置清单开始，详解一下Nginx服务器的各种配置指令的作用和用法。</p><p>看到了下文中的包含了 <strong>“小猪佩琪色”</strong> 的配图了吗，嘿嘿，我们开始吧！</p><h2 id="Nginx配置文件的整体结构"><a href="#Nginx配置文件的整体结构" class="headerlink" title="Nginx配置文件的整体结构"></a>Nginx配置文件的整体结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/9824247-6f7a9706b9f3982b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>从图中可以看出主要包含以下几大部分内容：</p><h4 id="1-全局块"><a href="#1-全局块" class="headerlink" title="1. 全局块"></a>1. 全局块</h4><p>该部分配置主要影响Nginx全局，通常包括下面几个部分：</p><ul><li>配置运行Nginx服务器用户（组）</li><li>worker process数</li><li>Nginx进程PID存放路径</li><li>错误日志的存放路径</li><li>配置文件的引入</li></ul><h4 id="2-events块"><a href="#2-events块" class="headerlink" title="2. events块"></a>2. events块</h4><p>该部分配置主要影响Nginx服务器与用户的网络连接，主要包括：</p><ul><li>设置网络连接的序列化</li><li>是否允许同时接收多个网络连接</li><li>事件驱动模型的选择</li><li>最大连接数的配置</li></ul><h4 id="3-http块"><a href="#3-http块" class="headerlink" title="3. http块"></a>3. http块</h4><ul><li>定义MIMI-Type</li><li>自定义服务日志</li><li>允许sendfile方式传输文件</li><li>连接超时时间</li><li>单连接请求数上限</li></ul><h4 id="4-server块"><a href="#4-server块" class="headerlink" title="4. server块"></a>4. server块</h4><ul><li>配置网络监听</li><li>于名称的虚拟主机配置</li><li>基于IP的虚拟主机配置</li></ul><h4 id="5-location块"><a href="#5-location块" class="headerlink" title="5. location块"></a>5. location块</h4><ul><li>location配置</li><li>请求根目录配置</li><li>更改location的URI</li><li>网站默认首页配置</li></ul><h2 id="一份配置清单例析"><a href="#一份配置清单例析" class="headerlink" title="一份配置清单例析"></a>一份配置清单例析</h2><p>笔者按照文章：<a href="https://www.jianshu.com/p/dc61f1789f47" target="_blank" rel="noopener">《Nginx服务器开箱体验》</a> 中的实验，给出了一份简要的清单配置举例：<img src="https://upload-images.jianshu.io/upload_images/9824247-2d04bfc0dfe6fa6e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>配置代码如下：</p><pre><code class="java">user  nobody  nobody;worker_processes  3;error_log  logs/error.log;pid  logs/nginx.pid;events {    use epoll;    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  logs/access.log  main;    sendfile  on;    keepalive_timeout  65;    server {        listen       8088;        server_name  codesheep;        access_log  /codesheep/webserver/server1/log/access.log;        error_page  404  /404.html;        location /server1/location1 {            root   /codesheep/webserver;            index  index.server2-location1.htm;        }        location /server1/location2 {        root   /codesheep/webserver;            index  index.server2-location2.htm;        }    }    server {        listen       8089;        server_name  192.168.31.177;        access_log  /codesheep/webserver/server2/log/access.log;        error_page  404  /404.html;        location /server2/location1 {            root   /codesheep/webserver;            index  index.server2-location1.htm;        }        location /srv2/loc2 {            alias   /codesheep/webserver/server2/location2/;            index  index.server2-location2.htm;        }        location = /404.html {            root /codesheep/webserver/;            index 404.html;        }    }}</code></pre><p>接下来就来详细剖析以下配置文件中各个指令的含义⬇️</p><h2 id="配置文件指令"><a href="#配置文件指令" class="headerlink" title="配置文件指令"></a>配置文件指令</h2><h4 id="配置运行Nginx服务器用户（组）"><a href="#配置运行Nginx服务器用户（组）" class="headerlink" title="配置运行Nginx服务器用户（组）"></a>配置运行Nginx服务器用户（组）</h4><p>指令格式:<code>user user [group];</code></p><ul><li>user：指定可以运行Nginx服务器的用户</li><li>group：可选项，可以运行Nginx服务器的用户组</li></ul><p>如果user指令不配置或者配置为 user nobody nobody ，则默认所有用户都可以启动Nginx进程</p><h4 id="worker-process数配置"><a href="#worker-process数配置" class="headerlink" title="worker process数配置"></a>worker process数配置</h4><p>Nginx服务器实现并发处理服务的关键，指令格式：<code>worker_processes number | auto;</code></p><ul><li>number：Nginx进程最多可以产生的worker process数</li><li>auto：Nginx进程将自动检测</li></ul><p>按照上文中的配置清单的实验，我们给worker_processes配置的数目是：3，启动Nginx服务器后，我们可以后台看一下主机上的Nginx进程情况：</p><pre><code>ps -aux | grep nginx</code></pre><p>很明显，理解 worker_processes 这个指令的含义就很容易了<img src="https://upload-images.jianshu.io/upload_images/9824247-b39d1a874d9bb50a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="Nginx进程PID存放路径"><a href="#Nginx进程PID存放路径" class="headerlink" title="Nginx进程PID存放路径"></a>Nginx进程PID存放路径</h4><p>Nginx进程是作为系统守护进程在运行，需要在某文件中保存当前运行程序的主进程号，Nginx支持该保存文件路径的自定义</p><p>指令格式：<code>pid file;</code></p><ul><li>file：指定存放路径和文件名称</li><li>如果不指定默认置于路径 logs/nginx.pid</li></ul><h4 id="错误日志的存放路径"><a href="#错误日志的存放路径" class="headerlink" title="错误日志的存放路径"></a>错误日志的存放路径</h4><p>指定格式：<code>error_log file | stderr;</code></p><ul><li>file：日志输出到某个文件file</li><li>stderr：日志输出到标准错误输出</li></ul><h4 id="配置文件的引入"><a href="#配置文件的引入" class="headerlink" title="配置文件的引入"></a>配置文件的引入</h4><p>指令格式：<code>include file;</code></p><ul><li>该指令主要用于将其他的Nginx配置或者第三方模块的配置引用到当前的主配置文件中</li></ul><h4 id="设置网络连接的序列化"><a href="#设置网络连接的序列化" class="headerlink" title="设置网络连接的序列化"></a>设置网络连接的序列化</h4><p>指令格式：<code>accept_mutex on | off;</code></p><ul><li>该指令默认为on状态，表示会对多个Nginx进程接收连接进行序列化，防止多个进程对连接的争抢。</li></ul><p>说到该指令，首先得阐述一下什么是所谓的 “惊群问题”，可以参考 WIKI百科的解释。就Nginx的场景来解释的话大致的意思就是：当一个新网络连接来到时，多个worker进程会被同时唤醒，但仅仅只有一个进程可以真正获得连接并处理之。如果每次唤醒的进程数目过多的话，其实是会影响一部分性能的。</p><p>所以在这里，如果accept_mutex on，那么多个worker将是以串行方式来处理，其中有一个worker会被唤醒；反之若accept_mutex off，那么所有的worker都会被唤醒，不过只有一个worker能获取新连接，其它的worker会重新进入休眠状态</p><p>这个值的开关与否其实是要和具体场景挂钩的。</p><h4 id="是否允许同时接收多个网络连接"><a href="#是否允许同时接收多个网络连接" class="headerlink" title="是否允许同时接收多个网络连接"></a>是否允许同时接收多个网络连接</h4><p>指令格式：<code>multi_accept on | off;</code></p><ul><li>该指令默认为off状态，意指每个worker process 一次只能接收一个新到达的网络连接。若想让每个Nginx的worker process都有能力同时接收多个网络连接，则需要开启此配置</li></ul><h4 id="事件驱动模型的选择"><a href="#事件驱动模型的选择" class="headerlink" title="事件驱动模型的选择"></a>事件驱动模型的选择</h4><p>指令格式：<code>use model;</code></p><p>model模型可选择项包括：select、poll、kqueue、epoll、rtsig等……</p><h4 id="最大连接数的配置"><a href="#最大连接数的配置" class="headerlink" title="最大连接数的配置"></a>最大连接数的配置</h4><p>指令格式：<code>worker_connections number;</code></p><ul><li>number默认值为512，表示允许每一个worker process可以同时开启的最大连接数</li></ul><h4 id="定义MIME-Type"><a href="#定义MIME-Type" class="headerlink" title="定义MIME-Type"></a>定义MIME-Type</h4><p>指令格式：</p><pre><code>include mime.types;default_type mime-type;</code></pre><ul><li><p>MIME-Type指的是网络资源的媒体类型，也即前端请求的资源类型</p></li><li><p>include指令将mime.types文件包含进来</p></li></ul><p><code>cat mime.types</code> 来查看mime.types文件内容，我们发现其就是一个types结构，里面包含了各种浏览器能够识别的MIME类型以及对应类型的文件后缀名字，如下所示：<img src="https://upload-images.jianshu.io/upload_images/9824247-641526cfc902854c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="自定义服务日志"><a href="#自定义服务日志" class="headerlink" title="自定义服务日志"></a>自定义服务日志</h4><p>指令格式：<code>access_log path [format];</code></p><ul><li><p>path：自定义服务日志的路径 + 名称</p></li><li><p>format：可选项，自定义服务日志的字符串格式。其也可以使用 log_format 定义的格式</p></li></ul><h4 id="允许sendfile方式传输文件"><a href="#允许sendfile方式传输文件" class="headerlink" title="允许sendfile方式传输文件"></a>允许sendfile方式传输文件</h4><p>指令格式：</p><pre><code>sendfile on | off;sendfile_max_chunk size;</code></pre><ul><li>前者用于开启或关闭使用sendfile()传输文件，默认off</li><li>后者指令若size&gt;0，则Nginx进程的每个worker process每次调用sendfile()传输的数据了最大不能超出此值；若size=0则表示不限制。默认值为0</li></ul><h4 id="连接超时时间配置"><a href="#连接超时时间配置" class="headerlink" title="连接超时时间配置"></a>连接超时时间配置</h4><p>指令格式：<code>keepalive_timeout timeout [header_timeout];</code></p><ul><li><p>timeout 表示server端对连接的保持时间，默认75秒</p></li><li><p>header_timeout 为可选项，表示在应答报文头部的 Keep-Alive 域设置超时时间：“Keep-Alive : timeout = header_timeout”</p></li></ul><h4 id="单连接请求数上限"><a href="#单连接请求数上限" class="headerlink" title="单连接请求数上限"></a>单连接请求数上限</h4><p>指令格式：<code>keepalive_requests number;</code></p><ul><li>该指令用于限制用户通过某一个连接向Nginx服务器发起请求的次数</li></ul><h4 id="配置网络监听"><a href="#配置网络监听" class="headerlink" title="配置网络监听"></a>配置网络监听</h4><p>指令格式：</p><ul><li><p>第一种：配置监听的IP地址：<code>listen IP[:PORT];</code></p></li><li><p>第二种：配置监听的端口：<code>listen PORT;</code></p></li></ul><h4 id="基于名称和IP的虚拟主机配置"><a href="#基于名称和IP的虚拟主机配置" class="headerlink" title="基于名称和IP的虚拟主机配置"></a>基于名称和IP的虚拟主机配置</h4><p>指令格式：<code>server_name name1 name2 ...</code></p><p>name可以有多个并列名称，而且此处的name支持正则表达式书写实际举例：</p><pre><code>server_name ~^www\d+\.myserver\.com$</code></pre><p>此时表示该虚拟主机可以接收类似域名 www1.myserver.com 等的请求而拒绝 <a href="http://www.myserver.com" target="_blank" rel="noopener">www.myserver.com</a> 的域名请求，所以说用正则表达式可以实现更精准的控制。</p><p>至于基于IP的虚拟主机配置比较简单，不再太赘述：</p><p>指令格式：<code>server_name IP地址</code></p><h4 id="location配置"><a href="#location配置" class="headerlink" title="location配置"></a>location配置</h4><p>指令格式为：<code>location [ = | ~ | ~* | ^~ ] uri {...}</code></p><p>这里的uri分为标准uri和正则uri，两者的唯一区别是uri中是否包含正则表达式uri前面的方括号中的内容是可选项，解释如下：</p><ul><li><p>“=”：用于标准uri前，要求请求字符串与uri严格匹配，一旦匹配成功则停止</p></li><li><p>“~”：用于正则uri前，并且区分大小写</p></li><li><p>“~*”：用于正则uri前，但不区分大小写</p></li><li><p>“^~”：用于标准uri前，要求Nginx找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配</p></li></ul><h4 id="请求根目录配置"><a href="#请求根目录配置" class="headerlink" title="请求根目录配置"></a>请求根目录配置</h4><p>指令格式：<code>root path;</code></p><ul><li>path：Nginx接收到请求以后查找资源的根目录路径当然，还可以通过alias指令来更改location接收到的URI请求路径，指令为：</li></ul><h4 id="设置网站的默认首页"><a href="#设置网站的默认首页" class="headerlink" title="设置网站的默认首页"></a>设置网站的默认首页</h4><p>指令格式：<code>index file ......</code></p><ul><li>file可以包含多个用空格隔开的文件名，首先找到哪个页面，就使用哪个页面响应请求</li></ul><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>非常感谢<a href="https://my.oschina.net/hansonwang99" target="_blank" rel="noopener">CodeSheep</a>的的分享！</p><p>通过本文并结合官方文档，并加以加以使用，多多去体验Nginx的神奇吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Nginx是现在企业上用的比较多的高性能的HTTP和反向代理服务器。入门Nginx一定少不了学习它的配置文件。本文将比较详细的介绍一下Nginx的各个配置项。&lt;/p&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://my.oschina.net/hansonwang99&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CodeSheep&lt;/a&gt;的技术博文。&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://my.oschina.net/hansonwang99/blog/1835408&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://my.oschina.net/hansonwang99/blog/1835408&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="nginx" scheme="https://www.chenruiwen.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://www.chenruiwen.cn/tags/nginx/"/>
    
      <category term="转载摘抄" scheme="https://www.chenruiwen.cn/tags/%E8%BD%AC%E8%BD%BD%E6%91%98%E6%8A%84/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展机制实现(三)之扩展点特性</title>
    <link href="https://www.chenruiwen.cn/dubbo/dubbo-spi-extension-feature/"/>
    <id>https://www.chenruiwen.cn/dubbo/dubbo-spi-extension-feature/</id>
    <published>2018-06-25T14:22:22.000Z</published>
    <updated>2018-07-22T00:57:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgrfhmr62j20jk0bfjrz.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇简单分析了Dubbo的扩展点机制的实现，以及其与java spi的区别与改进。</p><p>本篇文章准备从扩展点特性的角度分析一下源码。</p><a id="more"></a><h2 id="扩展点自动装配"><a href="#扩展点自动装配" class="headerlink" title="扩展点自动装配"></a>扩展点自动装配</h2><blockquote><p>加载扩展点时，自动注入依赖的扩展点。加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，ExtensionLoader 在会自动注入依赖的扩展点。ExtensionLoader 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 ExtensionLoader 会执行扩展点的拼装操作。</p></blockquote><p>上一篇提到了Dubbo的ExtensionLoader提供了三种获取扩展点实现类的方式，其中的一种是根据名字获取扩展点实现:</p><pre><code class="java">public T getExtension(String name) {    if (name == null || name.length() == 0)        throw new IllegalArgumentException(&quot;Extension name == null&quot;);    if (&quot;true&quot;.equals(name)) { // 判断是否是获取默认实现        return getDefaultExtension();    }    Holder&lt;Object&gt; holder = cachedInstances.get(name); // 从缓存中取    if (holder == null) {        cachedInstances.putIfAbsent(name, new Holder&lt;Object&gt;());        holder = cachedInstances.get(name);    }    Object instance = holder.get();    if (instance == null) {        synchronized (holder) {            instance = holder.get();            if (instance == null) {                instance = createExtension(name); // 创建缓存实例                holder.set(instance);            }        }    }    return (T) instance;}</code></pre><p>还是用到了缓存，先是判断是否取默认实例，再是从缓存取和设置缓存。接下来看一下创建扩展点的方法<code>createExtension(name)</code>:</p><pre><code class="java">private T createExtension(String name) {    Class&lt;?&gt; clazz = getExtensionClasses().get(name); // 加载当前Extension的所有实现, 并从中获取指定name的Extension    if (clazz == null) {        throw findException(name);    }    try {        T instance = (T) EXTENSION_INSTANCES.get(clazz); // 从Extension实例缓存中获取实例        if (instance == null) {            EXTENSION_INSTANCES.putIfAbsent(clazz, (T) clazz.newInstance());            instance = (T) EXTENSION_INSTANCES.get(clazz);        }        injectExtension(instance); // 注入扩展点信息        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;        if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {            for (Class&lt;?&gt; wrapperClass : wrapperClasses) {                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));            }        }        return instance;    } catch (Throwable t) {        throw new IllegalStateException(&quot;Extension instance(name: &quot; + name + &quot;, class: &quot; +                type + &quot;)  could not be instantiated: &quot; + t.getMessage(), t);    }}</code></pre><p>如上代码所示，<code>createExtension(name)</code>创建一个扩展点实例大致做了两件事：</p><ul><li>调用<code>getExtensionClasses()</code>加载了扩展点类，并通过名字获取到扩展点的Class类对象</li><li>创建扩展点的Class类对象的实例，并调用<code>injectExtension(instance)</code> 注入扩展点信息</li></ul><ol><li><code>getExtensionClasses()</code>暂且不说，比较重要的一个方法，在获取自适应扩展点的时候也会用到此方法。</li><li><code>injectExtension(instance)</code> 注入扩展点信息，这里便展示了扩展点自动装配的特性。<pre><code class="java">private T injectExtension(T instance) { try {     if (objectFactory != null) {         for (Method method : instance.getClass().getMethods()) {             // 处理所有set方法             if (method.getName().startsWith(&quot;set&quot;)                     &amp;&amp; method.getParameterTypes().length == 1                     &amp;&amp; Modifier.isPublic(method.getModifiers())) {                 Class&lt;?&gt; pt = method.getParameterTypes()[0];                 try {                     // 获取setter对应的property名称                     String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;                     // 根据参数类型和属性名称，从 ExtensionFactory 里获取扩展点                     Object object = objectFactory.getExtension(pt, property);                     if (object != null) { // 如果不为空，则 setter 方法的参数是扩展点类型，那么进行注入                         method.invoke(instance, object);                     }                 } catch (Exception e) {                     logger.error(&quot;fail to inject via method &quot; + method.getName()                             + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);                 }             }         }     } } catch (Exception e) {     logger.error(e.getMessage(), e); } return instance;}</code></pre>这里可以看到，扩展点自动注入就是根据<code>setter</code>方法对应的参数类型和property名称从<code>ExtensionFactory</code>中查询，如果有返回扩展点实例，那么就进行注入操作。</li></ol><h2 id="扩展点自适应"><a href="#扩展点自适应" class="headerlink" title="扩展点自适应"></a>扩展点自适应</h2><p>Dubbo扩展点有一个非常重要的概念：<code>Adaptive</code>.</p><blockquote><p><code>ExtensionLoader</code> 注入的依赖扩展点是一个 <code>Adaptive</code> 实例，直到扩展点方法执行时才决定调用是一个扩展点实现。</p><p>Dubbo 使用 URL 对象（包含了Key-Value）传递配置信息。</p><p>扩展点方法调用会有URL参数（或是参数有URL成员）</p><p>这样依赖的扩展点也可以从URL拿到配置信息，所有的扩展点自己定好配置的Key后，配置信息从URL上从最外层传入。URL在配置传递上即是一条总线。</p></blockquote><p>来看看Dubbo获取自适应扩展点的方法:<code>getAdaptiveExtension()</code>:</p><pre><code class="java">public T getAdaptiveExtension() {    Object instance = cachedAdaptiveInstance.get(); // 从缓存中获取自适应实例    if (instance == null) {        if (createAdaptiveInstanceError == null) {            synchronized (cachedAdaptiveInstance) {                instance = cachedAdaptiveInstance.get();                if (instance == null) {                    try {                        instance = createAdaptiveExtension(); // 创建自适应实例并缓存                        cachedAdaptiveInstance.set(instance);                    } catch (Throwable t) {                        createAdaptiveInstanceError = t;                        throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + t.toString(), t);                    }                }            }        } else {            throw new IllegalStateException(&quot;fail to create adaptive instance: &quot; + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);        }    }    return (T) instance;}</code></pre><p>又是缓存，看看如何创建一个自适应扩展点:<code>createAdaptiveExtension()</code></p><pre><code class="java">private T createAdaptiveExtension() {    try {        return injectExtension((T) getAdaptiveExtensionClass().newInstance());    } catch (Exception e) {        throw new IllegalStateException(&quot;Can not create adaptive extension &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);    }}</code></pre><p><code>injectExtension(instance)</code>方法上面说明过了，是对扩展点自动装配。主要看<code>getAdaptiveExtensionClass()</code>方法：</p><pre><code class="java">private Class&lt;?&gt; getAdaptiveExtensionClass() {    getExtensionClasses(); // 加载当前Extension的所有实现    if (cachedAdaptiveClass != null) {        return cachedAdaptiveClass;    }    return cachedAdaptiveClass = createAdaptiveExtensionClass(); // 动态创建自适应扩展类 Class 对象}</code></pre><p><code>getExtensionClasses()</code>是个很重要的方法，三种获取扩展点实现的方法都会用到这个方法，这个稍后说明一下。这里主要看<code>createAdaptiveExtensionClass()</code>:</p><pre><code class="java">private Class&lt;?&gt; createAdaptiveExtensionClass() {    String code = createAdaptiveExtensionClassCode(); // 自适应扩展类拼装代码    ClassLoader classLoader = findClassLoader();    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();    return compiler.compile(code, classLoader); // 动态编译}</code></pre><p>这里也是获取了<code>Compiler</code>接口的自适应扩展点<code>AdaptiveCompiler</code>的实现，由于实现里又<code>compiler = loader.getDefaultExtension()</code>获取了默认的扩展点，即<code>JavassistCompiler</code>的实例，来实现了动态编译。通过断点看一下通过 javassist 生成的实现类长啥样，以<code>Protocol</code>的自适应扩展点来看(debug打印后格式化并做了注释方便看):</p><pre><code class="java">package com.alibaba.dubbo.rpc;import com.alibaba.dubbo.common.extension.ExtensionLoader;public class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol {    public void destroy() {        throw new UnsupportedOperationException(&quot;method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);    }    public int getDefaultPort() {        throw new UnsupportedOperationException(&quot;method public abstract int com.alibaba.dubbo.rpc.Protocol.getDefaultPort() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!&quot;);    }    public com.alibaba.dubbo.rpc.Exporter export(com.alibaba.dubbo.rpc.Invoker arg0) throws com.alibaba.dubbo.rpc.RpcException {        if (arg0 == null)             throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument == null&quot;);        if (arg0.getUrl() == null)             throw new IllegalArgumentException(&quot;com.alibaba.dubbo.rpc.Invoker argument getUrl() == null&quot;);com.alibaba.dubbo.common.URL url = arg0.getUrl();        // 从url中获取扩展点名称,如果没有就赋值为默认的值        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );        if(extName == null)             throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);        // 通过名字获取扩展点实现        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);        return extension.export(arg0);    }    public com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) throws com.alibaba.dubbo.rpc.RpcException {        if (arg1 == null)             throw new IllegalArgumentException(&quot;url == null&quot;);        com.alibaba.dubbo.common.URL url = arg1;        // 从url中获取扩展点名称,如果没有就赋值为默认的值        String extName = ( url.getProtocol() == null ? &quot;dubbo&quot; : url.getProtocol() );        if(extName == null)             throw new IllegalStateException(&quot;Fail to get extension(com.alibaba.dubbo.rpc.Protocol) name from url(&quot; + url.toString() + &quot;) use keys([protocol])&quot;);        // 通过名字获取扩展点实现        com.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);        return extension.refer(arg0, arg1);    }}</code></pre><p>从上可以看到，确实正如Dubbo所描述的那样，通过url传递配置信息。</p><h2 id="扩展点自动包装"><a href="#扩展点自动包装" class="headerlink" title="扩展点自动包装"></a>扩展点自动包装</h2><p>在官方文档中有如下说明：</p><blockquote><p>自动包装扩展点的 Wrapper 类。<code>ExtensionLoader</code> 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。</p></blockquote><p>在源码里的体现，在加载扩展点文件 <code>loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</code> 里会根据构造器函数进行判断是否是 Wrapper类：</p><pre><code class="java">try {    clazz.getConstructor(type); // 判断是否 Wrapper 类型    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;    if (wrappers == null) {        cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();        wrappers = cachedWrapperClasses;    }    wrappers.add(clazz);} catch (NoSuchMethodException e) { // 非 Wrapper 类型    ...}</code></pre><p>其次在创建扩展点实例的时候也会根据是否是 Wrapper 类来创建相应的扩展点，这在<code>createExtension(String name)</code>中的体现:</p><pre><code class="java">Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; // 获取缓存的Wrapper类集合// 如果是包装类则创建包装类扩展点实例if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) {    for (Class&lt;?&gt; wrapperClass : wrapperClasses) {        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));    }}return instance;</code></pre><p>那么，为什么要使用 Wrapper 类呢？</p><blockquote><p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 <code>ExtensionLoader</code>返回扩展点时，包装在真正的扩展点实现外。即从 <code>ExtensionLoader</code> 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。</p><p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。</p><p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。</p></blockquote><p>从这里看 Dubbo 的<code>aop</code>实际上是装饰者设计模式 + 自适应特性的动态代理。</p><p>举个例子，在之前写Dubbo暴露过程的源码中对<code>Protocol</code>接口的调用过程进行了分析，在<code>ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</code>获取Protocol自适应扩展点的时序是<code>ProtocolListenerWrapper</code>-&gt;<code>ProtocolFilterWrapper</code>-&gt;<code>DubboProtocol</code>。<img src="https://ww1.sinaimg.cn/large/87faef88ly1fsl2mpd7q6j21cs0gm79z.jpg" alt=""></p><p>在真正暴露服务之前，对此进行了一些额外的扩展操作，通过这些层层包装使得各个类逻辑分明，代码维护性高。</p><h2 id="扩展点自动激活"><a href="#扩展点自动激活" class="headerlink" title="扩展点自动激活"></a>扩展点自动激活</h2><p>先看官方文档：</p><blockquote><p>对于集合类扩展点，比如：Filter, InvokerListener, ExportListener, TelnetHandler, StatusChecker 等，可以同时加载多个实现，此时，可以用自动激活来简化配置。</p></blockquote><p>Dubbo实现自动激活的核心关键词:<code>Activate</code>。</p><pre><code class="java">@Documented@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.METHOD})public @interface Activate {    /**     * 根据group匹配当前扩展点     *     * @return 匹配的group名称     */    String[] group() default {};    /**     * 当URL上的参数包含指定的keys时，激活当前的扩展点     * &lt;p&gt;     * 举个栗子, 当使用 &lt;code&gt;@Activate(&quot;cache, validation&quot;)&lt;/code&gt;, 当URL参数上包含&lt;code&gt;cache&lt;/code&gt; 或 &lt;code&gt;validation&lt;/code&gt; 时，当前扩展点才会被激活     * &lt;/p&gt;     *     * @return URL 参数上的key值     */    String[] value() default {};    /**     * 相对排序信息, 可选     *     * @return 应当放在当前扩展点之前的扩展点列表     */    String[] before() default {};    /**     * 相对排序信息, 可选     *     * @return 应当放在当前扩展点之前的扩展点列表     */    String[] after() default {};    /**     * 绝对排序信息, 可选     *     * @return 绝对排序信息     */    int order() default 0;}</code></pre><p>总之就是根据注解的 <code>value</code> 和 <code>group</code> 两个属性来决定是否激活。<br>比如<code>CacheFilter</code>：</p><pre><code class="java">@Activate(group = {Constants.CONSUMER, Constants.PROVIDER}, value = Constants.CACHE_KEY)public class CacheFilter implements Filter {}</code></pre><p>当满足条件:</p><ul><li>服务提供者 和 服务消费者 </li><li>url上的参数包含<code>cache</code> </li></ul><p>则激活 <code>CacheFilter</code></p><p><strong>那么，Dubbo如何使用 <code>Activate</code> 呢？</strong><br>没错，一定还记得那个方法:<code>getActivateExtension</code>。<code>getActivateExtension</code>有多个重写的方法，但实际最终会调用到如下：</p><pre><code class="java">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) {    List&lt;T&gt; exts = new ArrayList&lt;T&gt;();    List&lt;String&gt; names = values == null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);    if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {        getExtensionClasses(); // 此处缓存了 cachedActivates        for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) {            String name = entry.getKey(); // 获取 可激活的扩展点的spi扩展名            Activate activate = entry.getValue();            if (isMatchGroup(group, activate.group())) { // 如果group匹配                T ext = getExtension(name); // 根据扩展点名称获取扩展点实例                // name不在 values 指定的列，且没排除name，且url上有activate的value，则激活                if (!names.contains(name)                        &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)                        &amp;&amp; isActive(activate, url)) {                    exts.add(ext);                }            }        }        Collections.sort(exts, ActivateComparator.COMPARATOR); // 排序    }    List&lt;T&gt; usrs = new ArrayList&lt;T&gt;();    for (int i = 0; i &lt; names.size(); i++) { // 指定使用values的时候        String name = names.get(i);        // 所有未被排除的扩展名        if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)                &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {            if (Constants.DEFAULT_KEY.equals(name)) {                if (!usrs.isEmpty()) {                    exts.addAll(0, usrs);                    usrs.clear();                }            } else {                T ext = getExtension(name);                usrs.add(ext);            }        }    }    if (!usrs.isEmpty()) {        exts.addAll(usrs);    }    return exts;}</code></pre><p>关于<code>Activate</code>的使用场景：当需要提供一组需要指定条件的扩展点并使用的时候。比如在<code>ProtocolFilterWrapper</code>的<code>buildInvokerChain</code>里构建一组<code>Filter</code>时，Dubbo是这么处理的:</p><pre><code class="java">List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</code></pre><h2 id="扩展点的一些核心方法"><a href="#扩展点的一些核心方法" class="headerlink" title="扩展点的一些核心方法"></a>扩展点的一些核心方法</h2><p>在整个扩展点源码里，有一些核心的方法贯穿整个ExtensionLoader。</p><p>首先是之前常见得<code>getExtensionClasses()</code>这个方法里进行了：</p><ul><li>缓存扩展点Class</li><li>从指定文件路径加载扩展点文件</li><li>创建扩展点</li></ul><p><code>getExtensionClasses()</code>里的核心方法是<code>loadExtensionClasses</code>.</p><pre><code class="java">private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() {    final SPI defaultAnnotation = type.getAnnotation(SPI.class); // 先获取 @SPI 注解中的默认值    if (defaultAnnotation != null) {        // 如果 @SPI 注解存在 value 默认值, 赋值给 cachedDefaultName 属性        String value = defaultAnnotation.value();        if (value != null &amp;&amp; (value = value.trim()).length() &gt; 0) {            String[] names = NAME_SEPARATOR.split(value);            if (names.length &gt; 1) { // 每个扩展点实现只能配置一个名字                throw new IllegalStateException(&quot;more than 1 default extension name on extension &quot; + type.getName()                        + &quot;: &quot; + Arrays.toString(names));            }            if (names.length == 1) cachedDefaultName = names[0];        }    }    // 从配置路径中加载扩展实现类    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;();    loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);    loadFile(extensionClasses, DUBBO_DIRECTORY);    loadFile(extensionClasses, SERVICES_DIRECTORY);    return extensionClasses;}</code></pre><p>真正开始加载扩展点文件的方法:<code>loadFile</code>.下面，简单粗暴的贴源码：</p><pre><code class="java">private void loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) {    String fileName = dir + type.getName(); // 获取文件路径名    try {        Enumeration&lt;java.net.URL&gt; urls;        ClassLoader classLoader = findClassLoader(); // 获取了类加载器        if (classLoader != null) {            urls = classLoader.getResources(fileName);        } else {            urls = ClassLoader.getSystemResources(fileName);        }        if (urls != null) {            while (urls.hasMoreElements()) {                java.net.URL url = urls.nextElement();                try {                    BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), &quot;utf-8&quot;)); // 也是以utf-8方式读取配置文件                    try {                        String line = null;                        while ((line = reader.readLine()) != null) { // 解析每行数据                            final int ci = line.indexOf(&#39;#&#39;);                            if (ci &gt;= 0) line = line.substring(0, ci);                            line = line.trim();                            if (line.length() &gt; 0) { // 非注释内容                                try {                                    String name = null;                                    int i = line.indexOf(&#39;=&#39;);                                    if (i &gt; 0) {                                        name = line.substring(0, i).trim(); // 配置中的 key                                        line = line.substring(i + 1).trim(); // 配置中的 value                                    }                                    if (line.length() &gt; 0) {                                        Class&lt;?&gt; clazz = Class.forName(line, true, classLoader); // 获取class对象                                        if (!type.isAssignableFrom(clazz)) {                                            throw new IllegalStateException(&quot;Error when load extension class(interface: &quot; +                                                    type + &quot;, class line: &quot; + clazz.getName() + &quot;), class &quot;                                                    + clazz.getName() + &quot;is not subtype of interface.&quot;);                                        }                                        if (clazz.isAnnotationPresent(Adaptive.class)) { // 如果注解了@Adaptive                                            if (cachedAdaptiveClass == null) {                                                cachedAdaptiveClass = clazz; // 缓存 cachedAdaptiveClass                                            } else if (!cachedAdaptiveClass.equals(clazz)) { // 只允许一个 Adaptive 实现                                                throw new IllegalStateException(&quot;More than 1 adaptive class found: &quot;                                                        + cachedAdaptiveClass.getClass().getName()                                                        + &quot;, &quot; + clazz.getClass().getName());                                            }                                        } else {                                            try {                                                clazz.getConstructor(type); // 判断是否 Wrapper 类型                                                Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;                                                if (wrappers == null) {                                                    cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();                                                    wrappers = cachedWrapperClasses;                                                }                                                wrappers.add(clazz);                                            } catch (NoSuchMethodException e) { // 非 Wrapper 类型                                                clazz.getConstructor(); // 获取class对象的无参构造器                                                if (name == null || name.length() == 0) {                                                    name = findAnnotationName(clazz);                                                    if (name == null || name.length() == 0) {                                                        if (clazz.getSimpleName().length() &gt; type.getSimpleName().length()                                                                &amp;&amp; clazz.getSimpleName().endsWith(type.getSimpleName())) {                                                            name = clazz.getSimpleName().substring(0, clazz.getSimpleName().length() - type.getSimpleName().length()).toLowerCase();                                                        } else {                                                            throw new IllegalStateException(&quot;No such extension name for the class &quot; + clazz.getName() + &quot; in the config &quot; + url);                                                        }                                                    }                                                }                                                String[] names = NAME_SEPARATOR.split(name);                                                if (names != null &amp;&amp; names.length &gt; 0) {                                                    Activate activate = clazz.getAnnotation(Activate.class);                                                    if (activate != null) {                                                        cachedActivates.put(names[0], activate); // 缓存 cachedActivates                                                    }                                                    for (String n : names) {                                                        if (!cachedNames.containsKey(clazz)) {                                                            cachedNames.put(clazz, n); // 缓存 cachedNames ,每个class只对应一个名称                                                        }                                                        Class&lt;?&gt; c = extensionClasses.get(n);                                                        if (c == null) {                                                            extensionClasses.put(n, clazz); // 放入到extensionClasses中,多个 name 可能对应一个Class                                                        } else if (c != clazz) { // 重复抛异常                                                            throw new IllegalStateException(&quot;Duplicate extension &quot; + type.getName() + &quot; name &quot; + n + &quot; on &quot; + c.getName() + &quot; and &quot; + clazz.getName());                                                        }                                                    }                                                }                                            }                                        }                                    }                                } catch (Throwable t) {                                    IllegalStateException e = new IllegalStateException(&quot;Failed to load extension class(interface: &quot; + type + &quot;, class line: &quot; + line + &quot;) in &quot; + url + &quot;, cause: &quot; + t.getMessage(), t);                                    exceptions.put(line, e);                                }                            }                        } // end of while read lines                    } finally {                        reader.close();                    }                } catch (Throwable t) {                    logger.error(&quot;Exception when load extension class(interface: &quot; +                            type + &quot;, class file: &quot; + url + &quot;) in &quot; + url, t);                }            } // end of while urls        }    } catch (Throwable t) {        logger.error(&quot;Exception when load extension class(interface: &quot; +                type + &quot;, description file: &quot; + fileName + &quot;).&quot;, t);    }}</code></pre><p>文件加载完成后，几个实例被缓存了:</p><ul><li>cachedAdaptiveClass(自适应扩展点)</li><li>cachedWrapperClasses(扩展点包装类)</li><li>cachedActivates(扩展点激活类)</li><li>cachedNames(Class-&gt;name映射)</li></ul><p>在获取扩展点的三个方法中会常使用缓存了的数据，由此可见Dubbo在这里的缓存优化。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，扩展点机制大致介绍完毕，自己从源码中也体会了在扩展设计上原来还可以这么玩，收益匪浅了。</p><p>最后做个总结：</p><ul><li>从代码层面上对扩展点的四个特性进行了分析</li><li>三种获取扩展点的方式相互结合，分别体现了不同的扩展点特点</li><li>代码层面合理的设计模式(装饰器模式，动态代理)对代码分层解耦</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgrfhmr62j20jk0bfjrz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇简单分析了Dubbo的扩展点机制的实现，以及其与java spi的区别与改进。&lt;/p&gt;
&lt;p&gt;本篇文章准备从扩展点特性的角度分析一下源码。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="https://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA神器那些让人爱不释手的小技巧</title>
    <link href="https://www.chenruiwen.cn/Intellij-IDEA/Intellij-idea-skills-two/"/>
    <id>https://www.chenruiwen.cn/Intellij-IDEA/Intellij-idea-skills-two/</id>
    <published>2018-06-15T14:51:24.000Z</published>
    <updated>2018-07-21T14:33:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgqaxwnn9j20sf0jrdlq.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Intellij IDEA，一个开发者甚爱的IDE，用了这么多年，其中有些小Tips你真的了解吗？Intellij IDEA神器小技巧第二弹来了！</p><p>本文转载自<a href="https://blog.csdn.net/linsongbin1" target="_blank" rel="noopener">Sam哥哥聊技术</a>的技术博文。</p><p>原文地址:<a href="https://blog.csdn.net/linsongbin1/article/details/80560332" target="_blank" rel="noopener">https://blog.csdn.net/linsongbin1/article/details/80560332</a><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在2018年5月6日写了一篇介绍IntellIJ IDEA的文章,<a href="https://blog.csdn.net/linsongbin1/article/details/80211919" target="_blank" rel="noopener">Intellij IDEA神器居然还有这些小技巧</a>,主要是列出一些平时大家可能没用过或者没怎么用，但是又非常好用的IntellIJ IDEA小技巧。由于篇幅原因，只是列出了一小部分，那么接下来的这篇文章，会继续补充一些IntellIJ IDEA的小技巧。</p><h2 id="别轻易自定义快捷键"><a href="#别轻易自定义快捷键" class="headerlink" title="别轻易自定义快捷键"></a>别轻易自定义快捷键</h2><p>有蛮多操作，IntellIJ IDEA并没有给我们设置默认快捷键，需要使用者自己去定义快捷键。比如说：</p><ul><li>Rebuild Project</li><li>Compare With Branch</li></ul><p>为了能在IntellIJ IDEA里进行<code>无鼠标编程</code>，很多程序员都会自定义快捷键，但是有三个地方你可能需要注意一下。</p><ul><li>经常会出现快捷键与其他应用的快捷键冲突的情况；</li><li>自定义太多快捷键了，你也不太好记住；</li><li>使用其他同事的IDEA时(比如说帮忙定位问题)，你自定义的快捷键没法用。</li></ul><p>其实在IntellIJ IDEA里的每个操作，都可以看出一个<code>action</code>。我们可以使用<code>ctrl+shift+a</code>来输入我们要使用的操作。比如说，上面提到的<code>Rebuild Project</code>。你可以先使用<code>ctrl+shift+a</code>快捷键，然后输入<code>Rebuild Project</code>并回车,即可执行你要的操作。 </p><p><img src="https://img-blog.csdn.net/20180603210637881?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>对我自己来说，除了基础的快捷键，<code>ctrl+shift+a</code>是我用最频繁的快捷键了。</p><h2 id="使用ctrl-alt-h要小心"><a href="#使用ctrl-alt-h要小心" class="headerlink" title="使用ctrl+alt+h要小心"></a>使用ctrl+alt+h要小心</h2><p><code>ctrl+alt+h</code>非常好用,但是有个坑,当同一个方法里,调用某个方法多次的时候,比如说下面的代码：</p><pre><code class="java">public class TestService {    public void test1() {        System.out.println(&quot;aa&quot;);    }    public void test2() {        test1();    }    public void test3() {        test1();        //无数业务操作后,再次电影test1()方法        test1();    }}</code></pre><p>如果我们想知道有哪些地方调用<code>了test1()</code>方法，使用<code>ctrl+alt+h</code>无法正确列出来的。因为<code>ctrl+alt+h</code>只能告诉你调用的层次。 <img src="https://img-blog.csdn.net/20180603213636309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p><code>ctrl+alt+h</code>只是会在某个隐蔽的地方，告诉你，<code>test3()</code> 方法调用了 <code>test1()</code> 方法两次。这样就很容易坑到开发者，因为大部分人可能不太注意后面的调用次数，导致改bug的时候，以为全部都改了呢？</p><p>如果你想精确的列出到底哪些地方调用了<code>test1()</code> 方法，你需要使用<code>alt+f7</code>这个快捷键。<img src="https://img-blog.csdn.net/20180603214049285?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>尤其是我们在阅读极其复杂的业务代码时，使用<code>alt+f7</code>就非常合适。</p><p>当然<code>alt+f7</code>也可以作用在变量上，列出某个类里，哪些地方使用了该变量。</p><h2 id="ctrl-alt-h被问的最多的两个问题"><a href="#ctrl-alt-h被问的最多的两个问题" class="headerlink" title="ctrl+alt+h被问的最多的两个问题"></a>ctrl+alt+h被问的最多的两个问题</h2><p>经常有同事和网友问我。</p><blockquote><p>Sam哥，使用ctrl+alt+h怎么跳转到源代码，又如何重新回到ctrl+alt+h对应的视图里面。</p></blockquote><h4 id="调转到源代码"><a href="#调转到源代码" class="headerlink" title="调转到源代码"></a>调转到源代码</h4><p><img src="https://img-blog.csdn.net/20180603214902253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="">其实很简单，当你使用<code>ctrl+alt+h</code>后，使用向下或者向上箭头，选择某个调用，然后按下<code>f4</code>即可跳转到源代码。</p><h4 id="如何回到ctrl-alt-h视图"><a href="#如何回到ctrl-alt-h视图" class="headerlink" title="如何回到ctrl+alt+h视图"></a>如何回到ctrl+alt+h视图</h4><p>这个真心被问了好几百遍，其实很简单，当你使用<code>f4</code>跳转到源代码后，直接使用 <code>alt+8</code> 就可以跳回去了。就又可以继续看下一个调用的地方了。</p><h2 id="快速找到Controller方法"><a href="#快速找到Controller方法" class="headerlink" title="快速找到Controller方法"></a>快速找到Controller方法</h2><p>如果你的项目里有非常多的 controller，里面有非常多的 http 或者 resful 方法。如何快速找到这些方法呢？这个时候，<code>ctrl+alt+shift+n</code> 就可以派上用场了。</p><p>比如说，你依稀记得入账单相关的接口，都有个bill的url路径，那么使用 <code>ctrl+alt+shift+n</code> 后，直接输入/bill即可。</p><p><img src="https://img-blog.csdn.net/20180603215950916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>当你在成千上万的Controller里寻找方法时，这一招就可以大大提高效率。</p><h2 id="了解项目关键业务流程方法的利器-bookmark"><a href="#了解项目关键业务流程方法的利器-bookmark" class="headerlink" title="了解项目关键业务流程方法的利器-bookmark"></a>了解项目关键业务流程方法的利器-bookmark</h2><p>在一些创业公司里，很多核心的模块都是放置在同一个项目里的。比如说，订单相关的接口，支付相关的接口，商品相关的接口。这个时候，你可以将这些关键业务方法，使用 <code>bookmark</code> 统一放置到某个地方，方便你阅读。</p><p>那么如何使用快捷键来达到上面的效果呢？</p><pre><code class="java">public class TestService {    public void test1() {        System.out.println(&quot;aa&quot;);    }    public void test2() {        test1();    }    public void test3() {        test1();        test1();    }}</code></pre><p>比如像上面的方法，我想将test1()方法放置到bookmark里，可以通过如下操作来完成：  </p><ol><li>使用 <code>ctrl+f12</code> ,列出该类的所有方法，然后输入 <code>test1</code>，将光标定位在 <code>test1</code> 上； </li><li>按下 <code>f11</code> ,将 <code>test1()</code> 加入到 <code>bookmark</code>； </li><li>按下 <code>shift+f11</code>，将 <code>bookmark</code> 列表弹出来; </li><li>按下 <code>ctrl+enter</code> 修改 <code>bookmark</code> 名字。</li></ol><h2 id="只留下一个tab"><a href="#只留下一个tab" class="headerlink" title="只留下一个tab"></a>只留下一个tab</h2><p>这个是我目前正在用的，就是整个工程里面，只有一个代码 tab。也即是说，无论你打开多少个文件，都是在同一个tab里面显示。如果这样设置了，有些网友可能会问,我想看看我最近操作哪些类了，怎么看？ 可以直接使用 <code>ctrl+e</code> 来显示最近操作的文件。</p><p>我是比较推荐只是保留一个代码tab的，非常简洁。如果每打开一个文件，就是一个新的tab，很快你就会乱掉，而且还得关闭部分tab。</p><p>可以通过下面的方式来设置成用一个tab显示代码。按下 <code>ctrl+shif+a</code> ,然后输入<code>Editor Tabs</code>，然后回车进入编辑页面。</p><p><img src="https://img-blog.csdn.net/2018060409555189?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>然后在 <code>Placement</code> 那里,选择 <code>None</code></p><p><img src="https://img-blog.csdn.net/20180604095643156?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="如何阅读又长又臭的代码"><a href="#如何阅读又长又臭的代码" class="headerlink" title="如何阅读又长又臭的代码"></a>如何阅读又长又臭的代码</h2><p>由于历史原因，项目里总会存在那种无法理解的，又长又臭的业务代码。阅读这种代码，简直就是一种煎熬。但是 在IntellIJ IDEA 里，只要使用 5 个小技巧，便可大大提高阅读质量和速度。</p><h4 id="创建任意代码折叠块"><a href="#创建任意代码折叠块" class="headerlink" title="创建任意代码折叠块"></a>创建任意代码折叠块</h4><p><img src="https://img-blog.csdn.net/20180603222021678?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>像上面的for循环，我想直接将其折叠起来，因为代码太长的时候，使用折叠块，可以帮助你快速理清代码的主脉络。</p><p>可以将光标定位在for循环的左大括号里，然后使用 <code>ctrl+shift+.</code> 即可。 </p><p><img src="https://img-blog.csdn.net/20180603222256258?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>如果你想让这个折叠快消失，直接使用ctrl 加上一个+即可。</p><h4 id="大括号匹配"><a href="#大括号匹配" class="headerlink" title="大括号匹配"></a>大括号匹配</h4><p>这个也非常有用，因为代码太长，某个for循环，可能已经撑满整个屏幕了。这个时候，找到某个大括号对应的另外一边就很费劲。你可以将光标定位在某个大括号一边，然后使用 <code>ctrl+]</code> 或者 <code>ctrl+[</code> 来回定位即可。</p><h4 id="ctrl-shift-f7结合f3"><a href="#ctrl-shift-f7结合f3" class="headerlink" title="ctrl+shift+f7结合f3"></a>ctrl+shift+f7结合f3</h4><p><code>ctrl+shift+f7</code> 可以高亮某个变量，而且随着鼠标的移动，这个高亮是不会消失的(这个很重要)。然后使用f3找到下一个使用该变量的地方。</p><p><img src="https://img-blog.csdn.net/20180603223703369?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>在这个代码块里，你想看看 TestTemp 类的定义，那么将光标定位在 TestTemp 上，然后直接使用 <code>ctrl+shift+i</code>，就会弹出如下的窗口。 </p><p><img src="https://img-blog.csdn.net/20180603223758137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>按下 <code>esc</code>，可以关闭这个窗口。</p><h4 id="使用alt-f7"><a href="#使用alt-f7" class="headerlink" title="使用alt+f7"></a>使用alt+f7</h4><p>这个我在上面已经介绍过了。可以列出变量在哪些地方被使用了。</p><p>结合这5个技巧，相信可以大大提高长段代码的阅读效率。</p><h2 id="跳到父类接口"><a href="#跳到父类接口" class="headerlink" title="跳到父类接口"></a>跳到父类接口</h2><p>我们经常会定义一 个service 接口，比如说 UserService,然后使用一个 UserServiceImpl 类去实现 UserService 里面的接口。</p><pre><code>public interface UserService {    void test1();}public class UserServiceImpl implements UserService {    @Override    public void test1() {    }}</code></pre><p>那么在UserServiceImpl里的 test1() 方法上，如何跳转到 UserService 的 test1() ,直接使用 <code>ctrl+u</code> 即可。</p><h2 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h2><p>如果修改了部分代码，突然觉得不合适，使用 <code>ctrl+z</code> 回滚掉后。突然又觉得刚才的修改是可以的。那你可以使用 <code>ctr+shift+z</code> 再次恢复你刚才修改的内容。</p><h2 id="切换皮肤最快的方式"><a href="#切换皮肤最快的方式" class="headerlink" title="切换皮肤最快的方式"></a>切换皮肤最快的方式</h2><p>可以直接使用 <code>ctrl</code>,然后加上一个 <code>`</code> ,就可以立刻弹出如下界面： <img src="https://img-blog.csdn.net/2018060409462114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>选择 <code>Color Scheme</code>，然后回车，就可以弹出修改皮肤的窗口。 <img src="https://img-blog.csdn.net/20180604094730359?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpbnNvbmdiaW4x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>同样来自于 <a href="https://blog.csdn.net/linsongbin1" target="_blank" rel="noopener">Sam哥哥聊技术</a> 的分享，这里非常感谢！</p><p>此篇文章同样是收藏级别的文章，多学多用，才能使coding效率大大的提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgqaxwnn9j20sf0jrdlq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Intellij IDEA，一个开发者甚爱的IDE，用了这么多年，其中有些小Tips你真的了解吗？Intellij IDEA神器小技巧第二弹来了！&lt;/p&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://blog.csdn.net/linsongbin1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Sam哥哥聊技术&lt;/a&gt;的技术博文。&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://blog.csdn.net/linsongbin1/article/details/80560332&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/linsongbin1/article/details/80560332&lt;/a&gt;
    
    </summary>
    
      <category term="Intellij IDEA" scheme="https://www.chenruiwen.cn/categories/Intellij-IDEA/"/>
    
    
      <category term="转载摘抄" scheme="https://www.chenruiwen.cn/tags/%E8%BD%AC%E8%BD%BD%E6%91%98%E6%8A%84/"/>
    
      <category term="Intellij IDEA" scheme="https://www.chenruiwen.cn/tags/Intellij-IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展机制实现(二)之浅析ExtensionLoader</title>
    <link href="https://www.chenruiwen.cn/dubbo/dubbo-spi-extensionloader/"/>
    <id>https://www.chenruiwen.cn/dubbo/dubbo-spi-extensionloader/</id>
    <published>2018-06-11T14:47:08.000Z</published>
    <updated>2018-07-22T00:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgr9divhvj20go09cwf7.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的文章有介绍jdk SPI一些基本的使用和源码分析，既然dubbo也想使用SPI机制，为什么不直接使用jdk的SPI呢？</p><p>上篇文章开头也提到了：</p><blockquote><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p></blockquote><p>看看官方文档上Dubbo加强了哪些地方：<img src="https://ww1.sinaimg.cn/large/87faef88ly1frb9d0bvqmj216q0dcdk3.jpg" alt="">  </p><p>本文简单分析下Dubbo实现扩展点机制的ExtensionLoader类,分析其对比java的spi是怎么改进的。<a id="more"></a></p><h2 id="Dubbo扩展点约定"><a href="#Dubbo扩展点约定" class="headerlink" title="Dubbo扩展点约定"></a>Dubbo扩展点约定</h2><blockquote><p>在扩展类的 jar 包内 ，放置扩展点配置文件 META-INF/dubbo/接口全限定名，内容为：配置名=扩展实现类全限定名，多个实现类用换行符分隔。</p></blockquote><blockquote><p>注意：这里的配置文件是放在你自己的 jar 包内，不是 dubbo 本身的 jar 包内，Dubbo 会全 ClassPath 扫描所有 jar 包内同名的这个文件，然后进行合并 ↩</p></blockquote><h2 id="一个自定义扩展点小例子"><a href="#一个自定义扩展点小例子" class="headerlink" title="一个自定义扩展点小例子"></a>一个自定义扩展点小例子</h2><p>第一步：新建一个jar包，我这里是在原先的dubbo源码包里的dubbo-rpc模块新增了一个实现 [dubbo-rpc-myrpc]：</p><pre><code>&lt;parent&gt;    &lt;artifactId&gt;dubbo-rpc&lt;/artifactId&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/parent&gt;&lt;artifactId&gt;dubbo-rpc-myrpc&lt;/artifactId&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;${project.artifactId}&lt;/name&gt;&lt;description&gt;The my rpc module of dubbo project&lt;/description&gt;&lt;properties&gt;    &lt;skip_maven_deploy&gt;false&lt;/skip_maven_deploy&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-rpc-api&lt;/artifactId&gt;        &lt;version&gt;${project.parent.version}&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>第二步：以实现Protocol扩展为例，新建自定义实现:</p><pre><code class="java">/** * MyRpcProtocol */public class MyRpcProtocol extends AbstractProtocol implements Protocol {    public static final int DEFAULT_PORT = 0;    @Override    public int getDefaultPort() {        return DEFAULT_PORT;    }    @Override    public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException {        System.out.println(&quot;my rpc export...&quot;);        return null;    }    @Override    public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException {        System.out.println(&quot;my rpc refer...&quot;);        return null;    }}</code></pre><p>第三步：在jar包里定义扩展点：META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol </p><pre><code>myrpc=com.alibaba.dubbo.rpc.protocol.myrpc.MyRpcProtocol</code></pre><p>大工完成，是不是so easy…</p><p>第四步：测试。接下来测试一下，写一个提供者使用我们的自定义协议。<br>pom.xml里引用我们的自定义包</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;dubbo-rpc-myrpc&lt;/artifactId&gt;    &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>提供者xml里注册我们的协议:</p><pre><code>&lt;dubbo:protocol name=&quot;myrpc&quot; port=&quot;66666&quot;/&gt;</code></pre><p>然后启动服务:</p><pre><code class="java">public class Provider {    public static void main(String[] args) throws Exception {        //Prevent to get IPV6 address,this way only work in debug mode        //But you can pass use -Djava.net.preferIPv4Stack=true,then it work well whether in debug mode or not        System.setProperty(&quot;java.net.preferIPv4Stack&quot;, &quot;true&quot;);        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]{&quot;META-INF/spring/dubbo-demo-provider.xml&quot;});        context.start();        System.in.read(); // press any key to exit    }}</code></pre><p>可以看到控制台打印了:</p><pre><code>...[11/06/18 11:12:16:016 CST] main  INFO config.AbstractConfig:  [DUBBO] Export dubbo service com.alibaba.dubbo.demo.DemoService to local registry, dubbo version: 2.0.0, current host: 172.16.192.43[11/06/18 11:12:16:016 CST] main  INFO config.AbstractConfig:  [DUBBO] Export dubbo service com.alibaba.dubbo.demo.DemoService to url myrpc://172.16.192.43:66666/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider2&amp;bind.ip=172.16.192.43&amp;bind.port=66666&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=25280&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528686736167, dubbo version: 2.0.0, current host: 172.16.192.43[11/06/18 11:12:16:016 CST] main  INFO config.AbstractConfig:  [DUBBO] Register dubbo service com.alibaba.dubbo.demo.DemoService url myrpc://172.16.192.43:66666/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider2&amp;bind.ip=172.16.192.43&amp;bind.port=66666&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=25280&amp;qos.port=22222&amp;side=provider&amp;timestamp=1528686736167 to registry registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider2&amp;dubbo=2.0.0&amp;pid=25280&amp;qos.port=22222&amp;registry=zookeeper&amp;timestamp=1528686735588, dubbo version: 2.0.0, current host: 172.16.192.43my rpc export...Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: exporter == null    at com.alibaba.dubbo.rpc.listener.ListenerExporterWrapper.&lt;init&gt;(ListenerExporterWrapper.java:40)    at com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:59)...</code></pre><p>至此说明了我们的自定义扩展点可以使用。这样以后如果需要实现自定义的一些其他扩展点，使用起来也是非常easy.这里可以体现出Dubbo的设计理念:</p><ul><li><em>API 与 SPI 分离</em></li><li><em>微核插件式，平等对待第三方</em></li></ul><h2 id="ExtensionLoader中的缓存"><a href="#ExtensionLoader中的缓存" class="headerlink" title="ExtensionLoader中的缓存"></a>ExtensionLoader中的缓存</h2><p>Dubbo官方文档也说了，扩展点的实例化并非一次性全部加载的。所以它可能是懒加载的，用到哪个实例化哪个扩展点，其次官方文档也说了Dubbo的扩展点性能提升不少，说到性能提升下意识就是想到万能的缓存。来看看 Dubbo的扩展点加载器 ExtensionLoader是怎么实现的提高性能的。</p><p>ExtensionLoader各式各样的缓存：</p><pre><code class="java">public class ExtensionLoader&lt;T&gt; {    private static final ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = new ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();    private static final ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = new ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();    private final ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = new ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();    private final Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = new Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();    private final Map&lt;String, Activate&gt; cachedActivates = new ConcurrentHashMap&lt;String, Activate&gt;();    private final ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();    private final Holder&lt;Object&gt; cachedAdaptiveInstance = new Holder&lt;Object&gt;();    private volatile Class&lt;?&gt; cachedAdaptiveClass = null;    private String cachedDefaultName;    private volatile Throwable createAdaptiveInstanceError;    private Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;    private Map&lt;String, IllegalStateException&gt; exceptions = new ConcurrentHashMap&lt;String, IllegalStateException&gt;();    ...}</code></pre><p>ExtensionLoader并没有提供public的构造器，获取一个ExtensionLoader实例是通过私有静态方法 <em>getExtensionLoader(Class<t> type)</t></em> 法获取。</p><pre><code class="java">private ExtensionLoader(Class&lt;?&gt; type) {    this.type = type;    /**      * 这里会存在递归调用,ExtensionFactory的objectFactory为null,其他则为AdaptiveExtensionFactory     * AdaptiveExtensionFactory的factories中有SpiExtensionFactory,SpringExtensionFactory     * getAdaptiveExtension()来获取一个拓展装饰类对象     * objectFactory是一个 ExtensionFactory 对象，扩展点工厂类，暂且不分析     */    objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());}@SuppressWarnings(&quot;unchecked&quot;)public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) {    if (type == null) //拓展点类型非空判断        throw new IllegalArgumentException(&quot;Extension type == null&quot;);    if (!type.isInterface()) { // 拓展点类型只能是接口        throw new IllegalArgumentException(&quot;Extension type(&quot; + type + &quot;) is not interface!&quot;);    }    if (!withExtensionAnnotation(type)) { // 必须使用@spi注解,否则抛异常        throw new IllegalArgumentException(&quot;Extension type(&quot; + type +                &quot;) is not extension, because WITHOUT @&quot; + SPI.class.getSimpleName() + &quot; Annotation!&quot;);    }    // 使用了缓存，从缓存EXTENSION_LOADERS中获取,如果不存在则创建后加入缓存，每个扩展点有且仅有一个ExtensionLoader实例与之对应。    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);    if (loader == null) {        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);    }    return loader;}</code></pre><p>Dubbo处理缓存的一些值得学习的小细节：对线程安全方面的细节做得很好。</p><ol><li>比如缓存都使用 ConcurrentMap 而不使用 HashMap.</li><li><p>volatile关键字的使用。</p><pre><code class="java">private volatile Class&lt;?&gt; cachedAdaptiveClass = null;</code></pre><pre><code class="java">public class Holder&lt;T&gt; { private volatile T value; public void set(T value) {     this.value = value; public T get() {     return value; }}</code></pre></li></ol><h2 id="Dubbo如何改进获取spi的问题"><a href="#Dubbo如何改进获取spi的问题" class="headerlink" title="Dubbo如何改进获取spi的问题"></a>Dubbo如何改进获取spi的问题</h2><p>问题一：<em>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源</em>。</p><p>答：Dubbo的ExtensionLoader提供了三种获取扩展点实现类的方式：  </p><ul><li>public T getExtension(String name)<br>根据名称获取当前扩展的指定实现</li><li>public T getAdaptiveExtension()<br>获取当前扩展点的自适应实现</li><li>public List<t> getActivateExtension(URL url, String[] values, String group)<br>获取可激活的扩展点集合</t></li></ul><p>这三个地方准备在下一篇扩展点自适应自动激活的分析时一并讲解一下。这里可以看到Dubbo可以直接根据key就能获取到spi对象，而java的spi只能通过遍历然后根据if判断才能获取制定的spi对象。时间复杂度O(1) 比 O(n)快不少。而且用到了就加到缓存里，不用就不需要实例化，节约资源。</p><p>问题二：<em>如果扩展点加载失败，连扩展点的名称都拿不到了。会把真正失败的原因吃掉</em></p><p>答: Dubbo并不会这样，当拿不到扩展点的名字时，Dubbo会直接抛出异常：</p><pre><code class="java">public T getExtension(String name) {    if (name == null || name.length() == 0)        throw new IllegalArgumentException(&quot;Extension name == null&quot;);    ...}</code></pre><p>其次，Dubbo非常好的一点，增加了默认值的设置。比如：</p><pre><code class="java">@SPI(&quot;dubbo&quot;)public interface Protocol {}</code></pre><p>这样就默认提供了dubbo=xxx.xxx.XxxProtocol的s实现。如果使用默认的扩展点，可以这么做：</p><pre><code>Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getDefaultExtension();</code></pre><p>这里的protocol对象即是com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol</p><p>问题三：<em>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点</em></p><p>答：这个之后分析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>实现一个Dubbo自定义扩展点只需要三步。</li><li>Dubbo中的缓存设计在线程安全方面非常值得学习。</li><li>Dubbo是如何加强java的spi的，java的spi上哪些的不足被Dubbo巧妙实现了。</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文只是简单介绍了一下扩展点加载器ExtensionLoader。之后还有更多的源码分析它。我会从Dubbo官方文档上写的四个特性分析它并借鉴其中的一些理念。</p><p>下一篇就说说扩展点的四个特性：   <em>扩展点自动包装，扩展点自动装配，扩展点自适应，扩展点自动激活。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgr9divhvj20go09cwf7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前的文章有介绍jdk SPI一些基本的使用和源码分析，既然dubbo也想使用SPI机制，为什么不直接使用jdk的SPI呢？&lt;/p&gt;
&lt;p&gt;上篇文章开头也提到了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看看官方文档上Dubbo加强了哪些地方：
&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1frb9d0bvqmj216q0dcdk3.jpg&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;本文简单分析下Dubbo实现扩展点机制的ExtensionLoader类,分析其对比java的spi是怎么改进的。
    
    </summary>
    
      <category term="dubbo" scheme="https://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo扩展机制实现(一)之java SPI</title>
    <link href="https://www.chenruiwen.cn/dubbo/dubbo-spi-java/"/>
    <id>https://www.chenruiwen.cn/dubbo/dubbo-spi-java/</id>
    <published>2018-06-04T13:31:24.000Z</published>
    <updated>2018-07-22T00:56:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ww1.sinaimg.cn/large/87faef88ly1ftgqxq94j8j20h109kdfs.jpg" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的文章<a href="https://www.chenruiwen.cn/dubbo/dubbo-spi-java/">Dubbo暴露服务过程</a>中提出了问题：<em>@SPI</em>这些东西究竟是什么?<br>在<a href="https://dubbo.apache.org/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">Dubbo开发手册之扩展点加载</a>中有这么解释过：</p><blockquote><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p></blockquote><p>所以在分析Dubbo扩展机制前，先看看jdk的SPI。<a id="more"></a></p><h2 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ,是JDK内置的一种服务提供发现机制。在面向对象设计里，我们不会针对实现编程，模块间面向接口编程来防止强耦合。java spi机制实现了一种放在程序以外的方式去动态装配模块，这就是java的服务发现。类似于ioc的思想，将模块装配放在程序外，比如xml等方式。</p><p>Dubbo框架就是借鉴了这种机制，在jdk的基础上进行了改进。</p><h2 id="java-SPI机制约定"><a href="#java-SPI机制约定" class="headerlink" title="java SPI机制约定"></a>java SPI机制约定</h2><p>java的spi是通过<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">ServiceLoader</a>来加载，根据官方文档来看一下SPI机制的约定：</p><ul><li>Service实现类必须有一个无参构造器</li><li>在META-INF/services/目录中提供一个文件名称为Service接口全限定名的文件，文件内容为Service接口实现类全限定名，编码格式为UTF-8</li><li>使用java.util.ServiceLoader来动态加载Service接口的实现类。</li></ul><h2 id="SPI示例"><a href="#SPI示例" class="headerlink" title="SPI示例"></a>SPI示例</h2><p><a href="https://github.com/crrrrrw/java-spi-demo" target="_blank" rel="noopener">代码地址传送门</a><br>目录结构如下:<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr6nptfm2aj20ig0cqgml.jpg" alt=""><br>接口定义：</p><pre><code class="java">public interface HelloWorld {    void sayHello();}</code></pre><p>两个实现：</p><pre><code class="java">public class HelloWorldENimpl implements HelloWorld {    @Override    public void sayHello() {        System.out.println(&quot;hello,world!&quot;);    }}public class HelloWorldCNimpl implements HelloWorld {    @Override    public void sayHello() {        System.out.println(&quot;你好，世界！&quot;);    }}</code></pre><p>配置服务发现，在META-INF/service目录下创建文件：<em>com.crw.demo.spi.HelloWorld</em>，内容为接口实现类全名：</p><pre><code>com.crw.demo.spi.impl.HelloWorldENimplcom.crw.demo.spi.impl.HelloWorldCNimpl</code></pre><p>编写调用端：</p><pre><code class="java">public class Run {    public static void main(String[] args) {        ServiceLoader&lt;HelloWorld&gt; loads = ServiceLoader.load(HelloWorld.class);        for (HelloWorld load : loads) {            load.sayHello();        }    }}</code></pre><p>运行结果如下：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr6n9im7d1j20kq060aam.jpg" alt="">  </p><h2 id="ServiceLoader源码分析"><a href="#ServiceLoader源码分析" class="headerlink" title="ServiceLoader源码分析"></a>ServiceLoader源码分析</h2><p>从 <em>ServiceLoader.load(Class\&lt;S> service)</em> 方法点进去看一下</p><pre><code class="java">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); // 获取类加载器    return ServiceLoader.load(service, cl);}private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) {    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;    reload(); // 开始加载}public void reload() {    providers.clear(); // 清空提供者缓存    lookupIterator = new LazyIterator(service, loader); // 创建一个懒加载的提供者发现器}</code></pre><p>可以看到，实际上是交给了一个私有静态内部类处理new LazyIterator(service, loader); 通过名字就像是懒加载，所以我们看看什么时候类加载器会加载SPI实现服务。  </p><p>答案是遍历的时候。</p><p>ServiceLoader实现了iterator接口:</p><pre><code class="java">public Iterator&lt;S&gt; iterator() {    return new Iterator&lt;S&gt;() {        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders            = providers.entrySet().iterator();        public boolean hasNext() {            if (knownProviders.hasNext())                return true;            return lookupIterator.hasNext(); // 实际上是调用LazyIterator.hasNext()方法。        }        public S next() {            if (knownProviders.hasNext())                return knownProviders.next().getValue();            return lookupIterator.next(); // 实际上是调用LazyIterator.next()方法。        }        public void remove() {            throw new UnsupportedOperationException();        }    };}</code></pre><p>在客户端遍历的时候，首先调用了hasNext()方法，hasNext调用了LazyIterator.hasNext(),其实际上又调用了内部方法 <em>hasNextService()</em> :</p><pre><code class="java">private boolean hasNextService() {    if (nextName != null) { // 如果有服务提供者名称，直接返回        return true;    }    if (configs == null) {        try {            String fullName = PREFIX + service.getName(); // META-INF/services/xxx.xxx.xxx.XxxImpl            // 获取配置文件加载路径            if (loader == null)                configs = ClassLoader.getSystemResources(fullName);            else                configs = loader.getResources(fullName);        } catch (IOException x) {            fail(service, &quot;Error locating configuration files&quot;, x);        }    }    while ((pending == null) || !pending.hasNext()) {        if (!configs.hasMoreElements()) {            return false;        }        pending = parse(service, configs.nextElement()); //解析配置路径，用utf-8格式读取配置    }    nextName = pending.next(); // 服务提供者名称赋值    return true;}</code></pre><p>看一眼解析完的结构，在遍历的时候会读取配置，把服务提供者名称一次性获取：<br><img src="https://ww1.sinaimg.cn/large/87faef88ly1fr9re67q83j20vk0jugp9.jpg" alt="">  </p><p>接着，在客户端遍历的时候调用了next()方法，LazyIterator.next()方法里做了如下事情</p><pre><code class="java">private S nextService() {    if (!hasNextService()) // 如果配置里没有服务，则会抛异常        throw new NoSuchElementException();    String cn = nextName;    nextName = null;    Class&lt;?&gt; c = null;    try {        c = Class.forName(cn, false, loader); // 反射创建了配置文件里的实现类    } catch (ClassNotFoundException x) {        fail(service,             &quot;Provider &quot; + cn + &quot; not found&quot;);    }    if (!service.isAssignableFrom(c)) {        fail(service,             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);    }    try {        S p = service.cast(c.newInstance()); // 创建了一个实现类的实例        providers.put(cn, p); // 放入提供者缓存中        return p;    } catch (Throwable x) {        fail(service,             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,             x);    }    throw new Error();          // This cannot happen}</code></pre><p>返回了一个服务提供者实例，就这样完成了一次SPI调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要介绍了jdk SPI机制：</p><ul><li>java如何编写一个SPI服务的。</li><li>ServiceLoader源码如何实现SPI服务。  </li></ul><p>本篇主要是为了Dubbo实现spi而做了铺垫。在看ServiceLoader的源码时，主要还是利用了java的类加载器 ClassLoader ，这些之后会单独写一写。鉴于鄙人才疏学浅，以上文章如有不对的地方希望大家予以指出，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/87faef88ly1ftgqxq94j8j20h109kdfs.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的文章&lt;a href=&quot;https://www.chenruiwen.cn/dubbo/dubbo-spi-java/&quot;&gt;Dubbo暴露服务过程&lt;/a&gt;中提出了问题：&lt;em&gt;@SPI&lt;/em&gt;这些东西究竟是什么?&lt;br&gt;在&lt;a href=&quot;https://dubbo.apache.org/books/dubbo-dev-book/SPI.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo开发手册之扩展点加载&lt;/a&gt;中有这么解释过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以在分析Dubbo扩展机制前，先看看jdk的SPI。
    
    </summary>
    
      <category term="dubbo" scheme="https://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="java" scheme="https://www.chenruiwen.cn/tags/java/"/>
    
      <category term="dubbo" scheme="https://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
</feed>
