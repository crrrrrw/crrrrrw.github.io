<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈瑞文的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.chenruiwen.cn/"/>
  <updated>2018-06-05T13:38:03.000Z</updated>
  <id>http://www.chenruiwen.cn/</id>
  
  <author>
    <name>陈瑞文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dubbo扩展机制实现(一)之java SPI</title>
    <link href="http://www.chenruiwen.cn/2018/06/04/Dubbo%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0(%E4%B8%80)%E4%B9%8Bjava%20SPI/"/>
    <id>http://www.chenruiwen.cn/2018/06/04/Dubbo扩展机制实现(一)之java SPI/</id>
    <published>2018-06-04T13:31:24.000Z</published>
    <updated>2018-06-05T13:38:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前的文章<a href="http://www.chenruiwen.cn/2018/05/20/Dubbo%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B/">Dubbo暴露服务过程</a>中提出了问题：<em>@SPI</em>这些东西究竟是什么?<br>在<a href="http://dubbo.apache.org/books/dubbo-dev-book/SPI.html" target="_blank" rel="noopener">Dubbo开发手册之扩展点加载</a>中有这么解释过：</p><blockquote><p>Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。</p></blockquote><p>所以在分析Dubbo扩展机制前，先看看jdk的SPI。<br><a id="more"></a></p><h2 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h2><p>SPI 全称为 (Service Provider Interface) ,是JDK内置的一种服务提供发现机制。<br>在面向对象设计里，我们不会针对实现编程，模块间面向接口编程来防止强耦合。java spi机制实现了一种放在程序以外的方式去动态装配模块，这就是java的服务发现。类似于ioc的思想，将模块装配放在程序外，比如xml等方式。</p><p>Dubbo框架就是借鉴了这种机制，在jdk的基础上进行了改进。</p><h2 id="java-SPI机制约定"><a href="#java-SPI机制约定" class="headerlink" title="java SPI机制约定"></a>java SPI机制约定</h2><p>java的spi是通过<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">ServiceLoader</a>来加载，根据官方文档来看一下SPI机制的约定：</p><ul><li>Service实现类必须有一个无参构造器</li><li>在META-INF/services/目录中提供一个文件名称为Service接口全限定名的文件，文件内容为Service接口实现类全限定名，编码格式为UTF-8</li><li>使用java.util.ServiceLoader来动态加载Service接口的实现类。</li></ul><h2 id="SPI示例"><a href="#SPI示例" class="headerlink" title="SPI示例"></a>SPI示例</h2><p><a href="https://github.com/crrrrrw/java-spi-demo" target="_blank" rel="noopener">代码地址传送门</a><br>目录结构如下:<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr6nptfm2aj20ig0cqgml.jpg" alt=""><br>接口定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloWorld &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorldENimpl implements HelloWorld &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello,world!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HelloWorldCNimpl implements HelloWorld &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;你好，世界！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置服务发现，在META-INF/service目录下创建文件：<em>com.crw.demo.spi.HelloWorld</em>，内容为接口实现类全名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.crw.demo.spi.impl.HelloWorldENimpl</span><br><span class="line">com.crw.demo.spi.impl.HelloWorldCNimpl</span><br></pre></td></tr></table></figure></p><p>编写调用端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;HelloWorld&gt; loads = ServiceLoader.load(HelloWorld.class);</span><br><span class="line">        for (HelloWorld load : loads) &#123;</span><br><span class="line">            load.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr6n9im7d1j20kq060aam.jpg" alt="">  </p><h2 id="ServiceLoader源码分析"><a href="#ServiceLoader源码分析" class="headerlink" title="ServiceLoader源码分析"></a>ServiceLoader源码分析</h2><p>从 <em>ServiceLoader.load(Class\&lt;S> service)</em> 方法点进去看一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader(); // 获取类加载器</span><br><span class="line">    return ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;);</span><br><span class="line">    loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;</span><br><span class="line">    reload(); // 开始加载</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reload() &#123;</span><br><span class="line">    providers.clear(); // 清空提供者缓存</span><br><span class="line">    lookupIterator = new LazyIterator(service, loader); // 创建一个懒加载的提供者发现器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，实际上是交给了一个私有静态内部类处理new LazyIterator(service, loader); 通过名字就像是懒加载，所以我们看看什么时候类加载器会加载SPI实现服务。  </p><p>答案是遍历的时候。</p><p>ServiceLoader实现了iterator接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;S&gt; iterator() &#123;</span><br><span class="line">    return new Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">            = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            if (knownProviders.hasNext())</span><br><span class="line">                return true;</span><br><span class="line">            return lookupIterator.hasNext(); // 实际上是调用LazyIterator.hasNext()方法。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public S next() &#123;</span><br><span class="line">            if (knownProviders.hasNext())</span><br><span class="line">                return knownProviders.next().getValue();</span><br><span class="line">            return lookupIterator.next(); // 实际上是调用LazyIterator.next()方法。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            throw new UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在客户端遍历的时候，首先调用了hasNext()方法，hasNext调用了LazyIterator.hasNext(),其实际上又调用了内部方法 <em>hasNextService()</em> :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private boolean hasNextService() &#123;</span><br><span class="line">    if (nextName != null) &#123; // 如果有服务提供者名称，直接返回</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configs == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String fullName = PREFIX + service.getName(); // META-INF/services/xxx.xxx.xxx.XxxImpl</span><br><span class="line">            // 获取配置文件加载路径</span><br><span class="line">            if (loader == null)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            else</span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; catch (IOException x) &#123;</span><br><span class="line">            fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((pending == null) || !pending.hasNext()) &#123;</span><br><span class="line">        if (!configs.hasMoreElements()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement()); //解析配置路径，用utf-8格式读取配置</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next(); // 服务提供者名称赋值</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看一眼解析完的结构，在遍历的时候会读取配置，把服务提供者名称一次性获取：<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr9re67q83j20vk0jugp9.jpg" alt="">  </p><p>接着，在客户端遍历的时候调用了next()方法，<br>LazyIterator.next()方法里做了如下事情<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private S nextService() &#123;</span><br><span class="line">    if (!hasNextService()) // 如果配置里没有服务，则会抛异常</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = null;</span><br><span class="line">    Class&lt;?&gt; c = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        c = Class.forName(cn, false, loader); // 反射创建了配置文件里的实现类</span><br><span class="line">    &#125; catch (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             &quot;Provider &quot; + cn + &quot; not found&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        S p = service.cast(c.newInstance()); // 创建了一个实现类的实例</span><br><span class="line">        providers.put(cn, p); // 放入提供者缓存中</span><br><span class="line">        return p;</span><br><span class="line">    &#125; catch (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new Error();          // This cannot happen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回了一个服务提供者实例，就这样完成了一次SPI调用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要介绍了jdk SPI机制：</p><ul><li>java如何编写一个SPI服务的。</li><li>ServiceLoader源码如何实现SPI服务。  </li></ul><p>本篇主要是为了Dubbo实现spi而做了铺垫。在看ServiceLoader的源码时，主要还是利用了java的类加载器 ClassLoader ，这些之后会单独写一写。鉴于鄙人才疏学浅，以上文章如有不对的地方希望大家予以指出，共同进步。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在之前的文章&lt;a href=&quot;http://www.chenruiwen.cn/2018/05/20/Dubbo%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B/&quot;&gt;Dubbo暴露服务过程&lt;/a&gt;中提出了问题：&lt;em&gt;@SPI&lt;/em&gt;这些东西究竟是什么?&lt;br&gt;在&lt;a href=&quot;http://dubbo.apache.org/books/dubbo-dev-book/SPI.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo开发手册之扩展点加载&lt;/a&gt;中有这么解释过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo 的扩展点加载从 JDK 标准的 SPI (Service Provider Interface) 扩展点发现机制加强而来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以在分析Dubbo扩展机制前，先看看jdk的SPI。&lt;br&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询性能优化</title>
    <link href="http://www.chenruiwen.cn/2018/05/28/MySQL%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://www.chenruiwen.cn/2018/05/28/MySQL查询性能优化/</id>
    <published>2018-05-28T15:16:27.000Z</published>
    <updated>2018-06-04T15:17:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>查询优化的基本原则</li><li>了解MySQL执行过程</li><li>浅析MySQL优化器</li><li>MySQL语句优化小tips</li><li>理解MySQL如何查询，明白高效和低效的原因<a id="more"></a></li></ul><h2 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h2><p>分两步分析是否是低效的查询：  </p><ol><li><p><strong>是否向数据库请求了不需要的数据？</strong><br>比如查询了过多的行，查询过多的列(select * …)，以及重复的查询。</p></li><li><p><strong>Mysql是否在扫描额外的记录？</strong><br>三个指标衡量查询开销：</p><ul><li>响应时间</li><li>扫描行数</li><li>返回的行数</li></ul></li></ol><h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul><li>一个复杂查询or多个简单查询?</li><li>切分查询(比如在删改操作时，将全量语句改成批量执行)</li><li>分解关联查询(把一条复杂的关联查询分解为多条简单查询，可以让缓存效率更高，减少锁竞争) </li></ul><h2 id="一张图看Mysql执行过程"><a href="#一张图看Mysql执行过程" class="headerlink" title="一张图看Mysql执行过程"></a>一张图看Mysql执行过程</h2><p><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqmpuoqb43j20px0hyacw.jpg" alt=""></p><ol><li>客户端将查询发送到服务器；</li><li>服务器检查查询缓存，如果找到了，就从缓存中返回结果，否则进行下一步。</li><li>服务器解析，预处理和优化查询，生成执行计划。</li><li>执行引擎调用存储引擎API执行查询。</li><li>服务器将结果发送回客户端。</li></ol><h4 id="1-客户端服务端通信协议"><a href="#1-客户端服务端通信协议" class="headerlink" title="1.客户端服务端通信协议"></a>1.客户端服务端通信协议</h4><p>通信协议工作机制：“抛球”游戏。任意时刻，要么是客户端发送数据，要么是服务端发送数据。一旦一端发送数据(抛球),另一端只能完整的接受消息才能响应。</p><p>所以，我们需要限制发送信息的大小。<br>客户端：查询语句尽量少，否则可能会抛错误异常(“MySQL server has gone away”)。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看你的服务器所允许传送的最大数据</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'max_allowed_packet'</span></span><br></pre></td></tr></table></figure></p><p>服务端：当服务端开始响应客户端请求时，客户端必须完整接受整个返回结果。所以要限制查询条数，必要时查询语句用“LIMIT”限制。</p><p>通过  “SHOW [FULL] PROCESSLIST” 命令查询mysql连接时线程状态:<a href="https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html" target="_blank" rel="noopener">MySQL5.7通用线程状态</a></p><h4 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2.查询缓存"></a>2.查询缓存</h4><p>如果开启了缓存，MySql会检查查询缓存，进行大小写敏感的哈希查找。如果命中，判断权限没问题后会跳过所有其他阶段直接返回。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否开启查询</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'query_cache_type'</span>;</span><br></pre></td></tr></table></figure></p><h4 id="3-解析器"><a href="#3-解析器" class="headerlink" title="3.解析器"></a>3.解析器</h4><p>解析器通过关键字解析SQL，然后生成一颗对应的“解析树”，然后它使用MySQL语法规则验证和解析语句，比如关键字是否错误，顺序等。</p><h4 id="4-预处理"><a href="#4-预处理" class="headerlink" title="4.预处理"></a>4.预处理</h4><p>进一步检查解析树的合法性。比如检查数据表列是否存在，名字和别名等。最后，预处理器检查权限。</p><h4 id="5-查询优化器-重点"><a href="#5-查询优化器-重点" class="headerlink" title="5.查询优化器(重点)"></a>5.查询优化器(重点)</h4><p>优化器负责将预处理合格的语法树转化为执行计划。</p><p>MySQL使用基于成本的优化器，它将尝试预测一个查询使用某种执行计划的成本，并选择成本最小的一个。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询当前会话的当前查询成本</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">'Last_query_cost'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>Q:</strong> 那么，MySQL是如何预测成本的呢？<br><strong>A:</strong> MySQL根据一系列统计信息计算得来:每个表或页面个数，索引基数，索引和数据行的长度，索引分布情况等。评估成本不考虑缓存，假设读取任何数据需要一次磁盘I/O。</p><p><strong>可惜MySQL优化器并不是万能的</strong>，有诸多因素会导致MySQL选择错误的执行计划，比如统计信息可能不准确，成本估算和实际成有差距等。</p><p>更多的了解查询优化器是怎么处理查询语句的，查看<a href="http://www.chenruiwen.cn/2018/05/22/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8/">MySQL查询优化器</a></p><h4 id="6-查询执行引擎"><a href="#6-查询执行引擎" class="headerlink" title="6.查询执行引擎"></a>6.查询执行引擎</h4><p>MySQL根据解析优化阶段生成的执行计划给出的指令逐步执行。</p><h4 id="7-返回结果给客户端"><a href="#7-返回结果给客户端" class="headerlink" title="7.返回结果给客户端"></a>7.返回结果给客户端</h4><ul><li>查询结果返回给客户端，即时查询不需要返回结果集给客户端，也亏返回一些这个查询信息，比如影响的行数。  </li><li>如果查询可以被缓存，这一阶段也会存放结果入缓存。</li><li>MySQL结果集返回是一个增量、逐步返回的过程。一旦处理开始产生第一条结果时，MySQL就开始逐步返回结果集了。这样的好处是，服务器无须存储太多结果而消耗太多内存，二是客户端可以第一时间获得返回结果。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>当发现MySQL查询效率不高时，考虑两个因素：1.是否请求了不需要的数据？2.是否查询了额外的记录？</li><li>对待效率不高的语句，考虑语句适当拆分成多个简单的语句。</li><li>MySQL执行过程，看图</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;查询优化的基本原则&lt;/li&gt;
&lt;li&gt;了解MySQL执行过程&lt;/li&gt;
&lt;li&gt;浅析MySQL优化器&lt;/li&gt;
&lt;li&gt;MySQL语句优化小tips&lt;/li&gt;
&lt;li&gt;理解MySQL如何查询，明白高效和低效的原因
    
    </summary>
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询优化器</title>
    <link href="http://www.chenruiwen.cn/2018/05/22/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8/"/>
    <id>http://www.chenruiwen.cn/2018/05/22/MySQL查询优化器/</id>
    <published>2018-05-22T15:42:47.000Z</published>
    <updated>2018-06-02T15:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>了解查询优化器的优化策略</li><li>了解和查看查询优化器优化后的执行计划</li><li>了解优化器是怎么优化的</li><li>了解优化器在关联语句中的处理</li><li>了解一些查询优化器的提示<a id="more"></a></li></ul><h2 id="MySQL查询优化器的优化策略"><a href="#MySQL查询优化器的优化策略" class="headerlink" title="MySQL查询优化器的优化策略"></a>MySQL查询优化器的优化策略</h2><p>简单分为 <strong>静态优化</strong> 和 <strong>动态优化</strong>。</p><p>一、静态优化(“编译时优化”):</p><ul><li>可以直接对解析树进行分析并完成优化。  </li><li>优化器通过一些简单的代叔变换将WHERE条件转化为另一种等价形式。</li><li>静态优化不依赖特别的数值，比如WHERE条件里带一些常数等。</li><li>静态优化在第一次完成后一直有效，即使使用不同的参数值执行查询也不会发生变化。</li></ul><p>二、动态优化(“运行时优化”):</p><ul><li>动态优化和查询上下文有关或者其他因素有关，比如WHERE条件中的取值，索引中条目对应的数据行数等。</li><li>每次查询都需要重新评估。</li></ul><h2 id="MySQL能够处理的优化类型"><a href="#MySQL能够处理的优化类型" class="headerlink" title="MySQL能够处理的优化类型"></a>MySQL能够处理的优化类型</h2><p>先说一点，MySQL优化器使用了很多复杂的优化技巧把查询转化为执行计划。“不要试着比优化器更聪明”，通常都应让MySQL按照自己优化的方式执行语句，绝大多数情况优化器都是更优的。<br>你也可以通过EXPLAIN EXTENDED SELECT … … ; SHOW WARNINGS; 查看最终优化后的执行sql。<br>如何使用“EXPLAIN EXTENDED”可参考<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-extended.html" target="_blank" rel="noopener">官方文档上的Extended EXPLAIN Output Format</a></p><ol><li><font face="华文新魏" size="3">重新定义关联表顺序。</font><br>数据表的关联并不总是按照查询中指定顺序进行的。</li><li><font face="华文新魏" size="3">将外链接转化为内连接。</font><br>优化器可以根据某些因素(比如WHERE条件，库表结构等)，使得一个外连接等价于一个内连接。</li><li><p><font face="华文新魏" size="3">等价变换规则。</font><br>MySQL通过等价变换来简化并规范表达式。MySQL可以合并和减少比较。比如 (5=5 AND a&gt;5)会被改写为a&gt;5。(a &lt; b AND b=c) AND a=5会被改写为(b&gt;5 AND b=c AND a=5)</p></li><li><p><font face="华文新魏" size="3">优化</font> COUNT()、MIN()、MAX()。<br>查找某列最大/最小值，该列又有索引，查找最大值，则会直接找最后一行；最小值，则直接找第一行。因为索引已经排好序了。可以从EXPLAIN中看到：“Select tables optimized away”。这说明已经从执行计划中移除该表并用常数取代。</p></li><li><font face="华文新魏" size="3">预估并转化为常数表达式</font><br>如果一个表达式可以被简化为一个常量，那么这个表达式就会被转换。 在WHERE 、USING、ON这些连接条件强制值相等的条件中，常量具有传递性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">table_a.id,</span><br><span class="line">table_b.id</span><br><span class="line">FROM</span><br><span class="line">table_b</span><br><span class="line">INNER JOIN table_a ON table_a.tb_id = table_b.id</span><br><span class="line">WHERE</span><br><span class="line">table_b.id = 1</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqnue0bqrbj20r102ut8o.jpg" alt=""></p><ol start="6"><li><p><font face="华文新魏" size="3">覆盖索引</font><br>当索引包含查询需要的列时，MySql就可以使用索引来避免读取行数据。</p></li><li><p><font face="华文新魏" size="3">子查询优化</font><br>MySQL可以将某些类型的子查询转换成相等的效率更高的形式。</p></li><li><font face="华文新魏" size="3">提前终止查询</font>  </li></ol><ul><li>MySQL在发现已经满足查询需求时，会立刻终止查询。</li><li>MySQL检测一个不成立的条件也会立刻返回空结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_a WHERE id = - 1;</span><br></pre></td></tr></table></figure></li></ul><p><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqongff9j4j20sx01rjra.jpg" alt=""></p><ol start="9"><li><font face="华文新魏" size="3">等值传播</font><br>如果两个列的值通过等式关联，那么MySQL能把其中一个列的WHERE条件传递到另一个列。<br>比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_a.id, table_b.id FROM table_b INNER JOIN table_a ON table_a.tb_id = table_b.id WHERE table_b.id &lt; 100;</span><br></pre></td></tr></table></figure></li></ol><p>MySQL会判断把WHERE后面的关联作用于table_a表，等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT table_a.id, table_b.id FROM table_b INNER JOIN table_a ON table_a.tb_id = table_b.id WHERE table_b.id &lt; 100 AND table_a.tb_id &lt; 100;</span><br></pre></td></tr></table></figure></p><ol start="10"><li><font face="华文新魏" size="3">列表IN()的比较</font><br>MySql会对IN()里面的数据进行排序，然后用二分法查找某个值是否在列表中，这个算法的效率是O(Log n)。这其他数据库等价转换为多个OR条件连接的复杂度O(n)来说，IN()里大量取值时会更快。</li></ol><h2 id="MySQL如何关联查询"><a href="#MySQL如何关联查询" class="headerlink" title="MySQL如何关联查询"></a>MySQL如何关联查询</h2><p>MySQL关联查询策略:<br>其实就是嵌套循环查询。MySQL先从第一个表循环读，然后再嵌套循环到下一个表寻找匹配，如此反复，直到找到所有表的匹配的行为止。 </p><p>举个栗子：  </p><ul><li>内连接sql<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tbl_user.name, tbl_bankcard.bankcard </span><br><span class="line">FROM tbl_user INNER JOIN tbl_bankcard ON tbl_user.id = tbl_bankcard.user_id</span><br><span class="line">WHERE tbl_user.moblie in (&apos;18611112222&apos;,&apos;18611113333&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>MySQL在查询这条SQL时，用伪代码表示查询过程如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer_iter = iterator over tbl_user where moblie <span class="keyword">in</span> (<span class="string">'18611112222'</span>,<span class="string">'18611113333'</span>);</span><br><span class="line">outer_row = outer_iter.<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="symbol">outer_row:</span></span><br><span class="line">    inner_iter = iterator over tbl_bankcard where user_id = outer_row.id;</span><br><span class="line">    inner_row = inner_iter.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">while</span> <span class="symbol">inner_row:</span></span><br><span class="line">        output [outer_row.name, inner_row.bankcard]</span><br><span class="line">        inner_row = inner_iter.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    outer_row = outer_iter.<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><ul><li>再看这个SQL左外连接版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tbl_user.name, tbl_bankcard.bankcard </span><br><span class="line">FROM tbl_user LEFT JOIN tbl_bankcard ON tbl_user.id = tbl_bankcard.user_id</span><br><span class="line">WHERE tbl_user.moblie in (&apos;18611112222&apos;,&apos;18611113333&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>MySQL在查询这条SQL时，用伪代码表示查询过程如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">outer_iter = iterator over tbl_user where moblie <span class="keyword">in</span> (<span class="string">'18611112222'</span>,<span class="string">'18611113333'</span>);</span><br><span class="line">outer_row = outer_iter.<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">while</span> <span class="symbol">outer_row:</span></span><br><span class="line">    inner_iter = iterator over tbl_bankcard where user_id = outer_row.id;</span><br><span class="line">    inner_row = inner_iter.<span class="keyword">next</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="symbol">inner_row:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="symbol">inner_row:</span></span><br><span class="line">            output [outer_row.name, inner_row.bankcard]</span><br><span class="line">            inner_row = inner_iter.<span class="keyword">next</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        output [outer_row.name, NULL]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    outer_row = outer_iter.<span class="keyword">next</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p><p>基本上MySQL所有类型的查询都是这种方式运行。包括子查询，也是生成一张临时表，被当做普通表进行循环嵌套。以及右外链接也是会改写成等价的左外连接。</p><hr><p>多表关联的一种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    B(Join) --&gt; A[Join]</span><br><span class="line">    C(Join) --&gt; A</span><br><span class="line">    D(tbl1) --&gt; B</span><br><span class="line">    E(tbl2) --&gt; B</span><br><span class="line">    F(tbl3) --&gt; C</span><br><span class="line">    G(tbl4) --&gt; C</span><br></pre></td></tr></table></figure></p><p>但是MySQL是通过从一个表开始一直嵌套循环的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    B(Join) --&gt; A[Join]</span><br><span class="line">    C(tbl4) --&gt; A</span><br><span class="line">    D[Join] --&gt; B</span><br><span class="line">    E[tbl3] --&gt; B</span><br><span class="line">    F[tbl1] --&gt; D</span><br><span class="line">    G[tbl2] --&gt; D</span><br></pre></td></tr></table></figure></p><h2 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h2><ul><li>MySQL查询优化器中最重要的一部分。它决定了多表查询的顺序。它评估不同顺序的成本选择成本最小的一个。</li><li>有时优化器给出的并不是最优的关联顺序，可使用STRAIGHT_JOIN关键字替换JOIN关键字重写查询。还是那句，“不要试着比优化器更聪明”。</li><li>不过，如果有超过n个表的关联，那么需要检查n的阶乘种关联顺序。我们称之为所有可能的执行计划的“搜索空间”。实际上，当需要关联的表超过 optimizer_search_depth 的限制的时候，就会选择“贪婪”搜索模式。</li></ul><h2 id="查询优化器的提示-hint"><a href="#查询优化器的提示-hint" class="headerlink" title="查询优化器的提示(hint)"></a>查询优化器的提示(hint)</h2><p>用于控制查询执行计划。列举一些课使用的提示：</p><ol><li><p>HIGH_PRIORITY 和 LOW_PRIORITY <br><br>当多条语句同时访问数据库时，设置语句优先级。HIGH_PRIORITY会使语句放在表的队列的最前面，LOW_PRIORITY则相反。这两个提示只对使用表锁的存储引擎有效。</p></li><li><p>DELAYED <br><br>这个提示用于INSERT和REPLACE。使用该提示会将插入的行数据放入缓冲区，然后在表空闲时批量写入数据。适合于日志插入等场景。但并不是所有存储引擎都支持，还会导致函数 LAST_INSERT_ID()无法正常工作。</p></li><li><p>STRAIGHT_JOIN <br><br>这个提示可用于SELECT语句中SELECT关键字之后，也可放置于两个关联表之间。该提示作用一是让查询中的表按语句出现的顺序关联。作用二是固定前后两个表的关联顺序。</p></li><li><p>SQL_SMALL_RESULT 和 SQL_BIG_RESULT <br><br>这个提示只对SELECT有效。它告诉优化器对GROUP BY或者DISTINCT查询如果使用临时表和排序。SQL_SMALL_RESULT会让优化器认为结果集很小，将结果放在内存中的索引临时表中，避免排序。SQL_BIG_RESULT 则告诉优化器结果集很大，在磁盘临时表进行排序。</p></li><li><p>SQL_BUFFER_RESULT <br><br>这个提示告诉优化器将结果放在临时表中，并且尽快释放掉表锁。</p></li><li><p>SQL_CACHE 和 SQL_NO_CACHE <br><br>这个提示告诉MySQL是否将结果集放在查询缓存中。</p></li><li><p>USING INDEX、IGNORE INDEX 和 FORCE INDEX <br><br>这几个提示分别告诉优化器 使用或者不使用或者强制使用索引。</p></li></ol><h2 id="控制优化器的一些参数"><a href="#控制优化器的一些参数" class="headerlink" title="控制优化器的一些参数"></a>控制优化器的一些参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &quot;optimizer_%&quot;;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqr12aclarj20tb02q3yf.jpg" alt=""></p><ul><li>optimizer_search_depth<br>控制穷举执行计划的限度。</li><li>optimizer_prune_level<br>默认打开的，让优化器根据需要扫描的行数来决定是否跳过某些执行计划</li><li>optimizer_switch<br>此变量包含了一些开关优化器特性的标志位。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MySQL优化器做了很多工作把SQL语句变成更优的查询方式</li><li>使用 EXPLAIN EXTENDED … SHOW WARNINGS关键字查看优化后的指令</li><li>MySQL的关联查询是“嵌套循环”的</li><li>可使用查询优化提示控制查询执行计划，但是，“不要试着比优化器更聪明”。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;了解查询优化器的优化策略&lt;/li&gt;
&lt;li&gt;了解和查看查询优化器优化后的执行计划&lt;/li&gt;
&lt;li&gt;了解优化器是怎么优化的&lt;/li&gt;
&lt;li&gt;了解优化器在关联语句中的处理&lt;/li&gt;
&lt;li&gt;了解一些查询优化器的提示
    
    </summary>
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo暴露服务过程</title>
    <link href="http://www.chenruiwen.cn/2018/05/20/Dubbo%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E8%BF%87%E7%A8%8B/"/>
    <id>http://www.chenruiwen.cn/2018/05/20/Dubbo暴露服务过程/</id>
    <published>2018-05-20T07:11:24.000Z</published>
    <updated>2018-06-04T15:13:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>dubbo框架也用了有一年了，一直没有详细的研究过dubbo源码。所以趁有时间好好学习体会dubbo的博大精深。本人才疏学浅，如有不对，请大神指点。这里使用的dubbo版本是2.6.1。</p><p>如何看源码？跟着<a href="http://dubbo.apache.org/books/dubbo-dev-book/" target="_blank" rel="noopener">Dubbo开发手册(中文)</a>来喽。带着目的看源码，这次看dubbo是怎么暴露服务的。<br><a id="more"></a></p><h2 id="先瞜一眼启动日志"><a href="#先瞜一眼启动日志" class="headerlink" title="先瞜一眼启动日志"></a>先瞜一眼启动日志</h2><p>一般像这种大型的开源框架，都会有健全的启动日志，看看日志输出利于我们理解dubbo启动流程。<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqz30w0utyj21e70lftdv.jpg" alt=""><br>日志输出从上往下看，dubbo做了哪些事：</p><ol><li>暴露本地服务</li><li>暴露远程服务</li><li>启动Netty，绑定和暴露地址</li><li>连接zookeeper</li><li>zookeeper订阅服务</li><li>监听zookeeper</li></ol><h2 id="先瞜一眼官方手册"><a href="#先瞜一眼官方手册" class="headerlink" title="先瞜一眼官方手册"></a>先瞜一眼官方手册</h2><p>这段内容来自<a href="http://dubbo.apache.org/books/dubbo-dev-book/implementation.html" target="_blank" rel="noopener">dubbo开发手册之实现细节</a></p><p><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqz3wdhv82j20ns0n7q8q.jpg" alt=""></p><p>再来一段暴露服务时序图<br><img src="http://dubbo.apache.org/books/dubbo-dev-book/sources/images/dubbo-export.jpg" alt="image"></p><p>接下来，从官方文档开始，分析dubbo服务暴露过程。</p><h2 id="第一步，-ServiceConfig"><a href="#第一步，-ServiceConfig" class="headerlink" title="第一步， ServiceConfig"></a>第一步， ServiceConfig</h2><p>分析前，先利用IDE生成类图看看ServiceConfig的继承关系。<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fqzgb7myddj20tj0de754.jpg" alt=""></p><p><em>问题一：这么多的配置是啥？</em><br>凭借感觉像是和dubbo.xml里的配置属性有关系。先不管，留个坑。</p><p>根据时序图，我们先定位到 ServiceConfig 的 export()方法<br><strong>ServiceConfig#export</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 延迟暴露接口</span></span><br><span class="line">    <span class="keyword">if</span> (delay != <span class="keyword">null</span> &amp;&amp; delay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayExportExecutor.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                doExport();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doExport(); <span class="comment">// 此处调用开始暴露</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>暴露服务是调用 <strong>ServiceConfig#doExport</strong>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">protected synchronized void doExport() &#123;</span><br><span class="line">    if (unexported) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Already unexported!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (exported) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    exported = true;</span><br><span class="line">    if (interfaceName == null || interfaceName.length() == 0) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;&lt;dubbo:service interface=\&quot;\&quot; /&gt; interface not allow null!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    checkDefault();// 创建了 ProviderConfig 对象并赋值 setter is属性，提供者的缺省值设置</span><br><span class="line">    /**</span><br><span class="line">     * provider已经配置的情况下，application、module、registries、monitor、protocol中未配置的值均可以从provider获取</span><br><span class="line">     */</span><br><span class="line">    if (provider != null) &#123;</span><br><span class="line">        if (application == null) &#123;</span><br><span class="line">            application = provider.getApplication();</span><br><span class="line">        &#125;</span><br><span class="line">        if (module == null) &#123;</span><br><span class="line">            module = provider.getModule();</span><br><span class="line">        &#125;</span><br><span class="line">        if (registries == null) &#123;</span><br><span class="line">            registries = provider.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        if (monitor == null) &#123;</span><br><span class="line">            monitor = provider.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">        if (protocols == null) &#123;</span><br><span class="line">            protocols = provider.getProtocols();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (module != null) &#123;</span><br><span class="line">        if (registries == null) &#123;</span><br><span class="line">            registries = module.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        if (monitor == null) &#123;</span><br><span class="line">            monitor = module.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (application != null) &#123;</span><br><span class="line">        if (registries == null) &#123;</span><br><span class="line">            registries = application.getRegistries();</span><br><span class="line">        &#125;</span><br><span class="line">        if (monitor == null) &#123;</span><br><span class="line">            monitor = application.getMonitor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ref instanceof GenericService) &#123;</span><br><span class="line">        interfaceClass = GenericService.class;</span><br><span class="line">        if (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">            generic = Boolean.TRUE.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()</span><br><span class="line">                    .getContextClassLoader());</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        checkInterfaceAndMethods(interfaceClass, methods); // 检查配置中的 interface 属性 和 methods属性</span><br><span class="line">        checkRef();  // 检查 ref 属性</span><br><span class="line">        generic = Boolean.FALSE.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果配置 local 属性， 是否服务接口客户端本地代理</span><br><span class="line">    if (local != null) &#123;</span><br><span class="line">        if (&quot;true&quot;.equals(local)) &#123;</span><br><span class="line">            local = interfaceName + &quot;Local&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; localClass;</span><br><span class="line">        try &#123;</span><br><span class="line">            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The local implementation class &quot; + localClass.getName() + &quot; not implement interface &quot; + interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果配置 stub 属性， 是否本地存根 </span><br><span class="line">    if (stub != null) &#123;</span><br><span class="line">        if (&quot;true&quot;.equals(stub)) &#123;</span><br><span class="line">            stub = interfaceName + &quot;Stub&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; stubClass;</span><br><span class="line">        try &#123;</span><br><span class="line">            stubClass = ClassHelper.forNameWithThreadContextClassLoader(stub);</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!interfaceClass.isAssignableFrom(stubClass)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The stub implementation class &quot; + stubClass.getName() + &quot; not implement interface &quot; + interfaceName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkApplication(); // 检查 application 属性</span><br><span class="line">    checkRegistry(); // 检查 registry 属性</span><br><span class="line">    checkProtocol(); // 检查 protocol 属性</span><br><span class="line">    appendProperties(this); // 赋值 ServiceConfig setter is 属性</span><br><span class="line">    checkStubAndMock(interfaceClass); // 检查是否 使用 local,stub,mock 代理</span><br><span class="line">    if (path == null || path.length() == 0) &#123;</span><br><span class="line">        path = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    doExportUrls(); // 开始暴露远程服务了</span><br><span class="line">    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);</span><br><span class="line">    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ServiceConfig#doExportUrls</strong>暴露多个远程地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrls() &#123;</span><br><span class="line">    // dubbo支持多注册中心，所以这一步把 registry 配置信息封装为多个url,比如 registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider...</span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(true);</span><br><span class="line">    // dubbo是支持多协议的，将所有注册的url上对应的协议暴露出来</span><br><span class="line">    for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ServiceConfig#doExportUrlsFor1Protocol</strong>暴露单个地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;</span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    if (name == null || name.length() == 0) &#123;</span><br><span class="line">        name = &quot;dubbo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // map存放所有配置参数，下面生成url用</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">    map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">    if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">    &#125;</span><br><span class="line">    appendParameters(map, application);</span><br><span class="line">    appendParameters(map, module);</span><br><span class="line">    appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">    appendParameters(map, protocolConfig);</span><br><span class="line">    appendParameters(map, this);</span><br><span class="line">    // method子标签配置规则解析，暂时不管</span><br><span class="line">    if (methods != null &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">        for (MethodConfig method : methods) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; // end of methods for</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取所有方法添加到map中，体现在url里</span><br><span class="line">    if (ProtocolUtils.isGeneric(generic)) &#123; // 如果是泛化实现，generic属性为true，method=*表示任意方法</span><br><span class="line">        map.put(&quot;generic&quot;, generic);</span><br><span class="line">        map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">            map.put(&quot;revision&quot;, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        if (methods.length == 0) &#123;</span><br><span class="line">            logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">            map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果配置了token属性，如果配为default则随机UUID，否则使用配置中的token，作令牌验证用</span><br><span class="line">    if (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        if (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(&quot;token&quot;, UUID.randomUUID().toString());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            map.put(&quot;token&quot;, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果协议是 injvm，就不注册服务， notify设置为false</span><br><span class="line">    if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123;</span><br><span class="line">        protocolConfig.setRegister(false);</span><br><span class="line">        map.put(&quot;notify&quot;, &quot;false&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // export service</span><br><span class="line">    String contextPath = protocolConfig.getContextpath();</span><br><span class="line">    // 如果 protocol配置没有配置contextPath属性，就从provider配置中取</span><br><span class="line">    if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123;</span><br><span class="line">        contextPath = provider.getContextpath();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = this.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    // 根据上面的参数创建url对象</span><br><span class="line">    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);</span><br><span class="line">    // 如果url使用的协议存在扩展，调用对应的扩展来修改原url。</span><br><span class="line">    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">        // 如果scope属性没有配置为 none</span><br><span class="line">        if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            // 如果scope属性没有配置为 remote， 暴露本地服务</span><br><span class="line">            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line">            // // 如果scope属性没有配置为 local， 暴露远程服务</span><br><span class="line">            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);</span><br><span class="line">                &#125;</span><br><span class="line">                if (registryURLs != null &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                        if (monitorUrl != null) &#123; // 如果有monitor信息，则在url上增加monitor配置</span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 重要的第二步了，创建 invoker 对象（这里暴露远程协议里，在远程协议里增加了属性 export=url,url默认dubbo协议暴露地址）</span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line">                        // 第三步，官方文档加重点的一步，invoker转化为 exporter</span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.urls.add(url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="第二步，ProxyFactory-getInvoker"><a href="#第二步，ProxyFactory-getInvoker" class="headerlink" title="第二步，ProxyFactory.getInvoker"></a>第二步，ProxyFactory.getInvoker</h2><p>在<strong>ServiceConfig#doExportUrlsFor1Protocol</strong>暴露单个地址中的调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br></pre></td></tr></table></figure></p><p>接下来看看这一行代码里做了什么。<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr2vg3gsllj20rw02n0t2.jpg" alt=""></p><p><em>问题二：这个 ProxyFactory$Adaptive是什么东东？</em><br>看看 proxyFactory 是怎么来的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure></p><p>看来是和这个 ExtensionLoader 有关。看看接口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;javassist&quot;)</span><br><span class="line">public interface ProxyFactory &#123;</span><br><span class="line">    @Adaptive(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@SPI 看起来和java SPI机制有关哦。先留个坑，回头再解决。</p><p>但是通过我们debug发现，默认情况下 ProxyFactory的实现是 JavassistProxyFactory。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper cannot handle this scenario correctly: the classname contains &apos;$&apos;</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>正如官方文档所说:</p><blockquote><p>首先 ServiceConfig 类拿到对外提供服务的实际类 ref(如：HelloWorldImpl),然后通过 ProxyFactory 类的 getInvoker 方法使用 ref 生成一个 AbstractProxyInvoker 实例，到这一步就完成具体服务到 Invoker 的转化。</p></blockquote><p>JavassistProxyFactory的getInvoker实现是先创建一个包装类Wrapper ，包装类来实现远程调用。简单看下这个包装类是什么吧，Wapper.makeWrapper(Class&lt;?&gt; c):<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr3r8635d5j20tq0gojtu.jpg" alt=""><br>结果大致如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper1 extends Wrapper &#123;</span><br><span class="line">    public static String[] pns;</span><br><span class="line">    public static Map pts;</span><br><span class="line">    public static String[] mns; // all method name array.</span><br><span class="line">    public static String[] dmns;</span><br><span class="line">    public static Class[] mts0;</span><br><span class="line"></span><br><span class="line">    public String[] getPropertyNames() &#123;</span><br><span class="line">        return pns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasProperty(String n) &#123;</span><br><span class="line">        return pts.containsKey($1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class getPropertyType(String n) &#123;</span><br><span class="line">        return (Class) pts.get($1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getMethodNames() &#123;</span><br><span class="line">        return mns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getDeclaredMethodNames() &#123;</span><br><span class="line">        return dmns;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPropertyValue(Object o, String n, Object v) &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getPropertyValue(Object o, String n) &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException(&quot;Not found property \&quot;&quot; + $2 + &quot;\&quot; filed or setter method in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException &#123;</span><br><span class="line">        dubbo.provider.hello.service.impl.HelloServiceImpl w;</span><br><span class="line">        try &#123;</span><br><span class="line">            w = ((dubbo.provider.hello.service.impl.HelloServiceImpl) $1);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (&quot;sayHello&quot;.equals($2) &amp;&amp; $3.length == 0) &#123;</span><br><span class="line">                w.sayHello();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot; + $2 + &quot;\&quot; in class dubbo.provider.hello.service.impl.HelloServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="第三步，invoker转化为-exporter"><a href="#第三步，invoker转化为-exporter" class="headerlink" title="第三步，invoker转化为 exporter"></a>第三步，invoker转化为 exporter</h2><p>在<strong>ServiceConfig#doExportUrlsFor1Protocol</strong>暴露单个地址中的调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br></pre></td></tr></table></figure></p><p>由代码可知，这里的 protocol 和第二步里的proxyFactory 一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure></p><p>我们再看看 Protocol接口，也是SPI机制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;dubbo&quot;)</span><br><span class="line">public interface Protocol &#123;</span><br><span class="line"></span><br><span class="line">    int getDefaultPort();</span><br><span class="line">    </span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line">    </span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">    void destroy();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>凭感觉会使用dubbo协议调用到DubboProtocol。先debug,果不其然。看一眼调用栈：<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr56why7woj20ic0awmyn.jpg" alt=""></p><p>从ServiceConfig之后，有两次协议调用，先是调用RegistryProtocol，然后RegistryProtocol里调用了DubboProtocol。<br>两次暴露协议前，都会调用到 ProtocolListenerWrapper 和 ProtocolFilterWrapper，看看这两个地方。<br><strong>ProtocolListenerWrapper#export</strong>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    // registry类型的Invoker，直接暴露</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    // 非Registry类型的Invoker，需要被监听器包装</span><br><span class="line">    // 这里的protocol是ProtocolFilterWrapper</span><br><span class="line">    return new ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),</span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>ProtocolFilterWrapper#export</strong>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    // registry类型的Invoker，直接暴露</span><br><span class="line">    if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    //非Registry类型的Invoker需要先构建调用链，然后再暴露</span><br><span class="line">    return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里构建调用链，控制invoker调用执行顺序，默认的filters如下图：<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr5791ve67j208j05v74f.jpg" alt=""><br>暂且不谈Filter接口相关。</p><p>按照调用顺序，先调用 <strong>RegistryProtocol#export</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;</span><br><span class="line">    //export invoker</span><br><span class="line">    final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker); // 本地暴露</span><br><span class="line"></span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker); // 获取注册地址，默认是dubbo，我这里使用zookeeper</span><br><span class="line"></span><br><span class="line">    //registry provider</span><br><span class="line">    final Registry registry = getRegistry(originInvoker); // 获取注册中心， 我这里的是ZookeeperRegistry对象</span><br><span class="line">    final URL registedProviderUrl = getRegistedProviderUrl(originInvoker);// 获取注册的提供者地址</span><br><span class="line"></span><br><span class="line">    //to judge to delay publish whether or not</span><br><span class="line">    boolean register = registedProviderUrl.getParameter(&quot;register&quot;, true);</span><br><span class="line"></span><br><span class="line">    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);// 注册提供者消费者。</span><br><span class="line"></span><br><span class="line">    if (register) &#123;</span><br><span class="line">        register(registryUrl, registedProviderUrl); // 注册服务</span><br><span class="line">        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true); // 标记为已注册</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Subscribe the override data</span><br><span class="line">    // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span><br><span class="line">    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);</span><br><span class="line">    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">    //保证每次暴露服务返回一个新的exporter</span><br><span class="line">    return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，上面的本地暴露 <strong>doLocalExport(originInvoker)</strong> 实际上是暴露的dubbo协议，看下DubboProtocol：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    // export service.</span><br><span class="line">    String key = serviceKey(url); // 获取dubbo协议服务key，serviceGroup/serviceName:serviceVersion:port</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    //export an stub service for dispatching event</span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);  // 是否是stub事件？ dubbo.stub.event属性</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false); // 是否回调服务？ is_callback_service属性</span><br><span class="line">    if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123; // TODO 这里暂时不分析，此处demo场景为false</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openServer(url); // 开启服务(这里默认使用netty方式)</span><br><span class="line">    optimizeSerialization(url);// 优化序列化</span><br><span class="line">    return exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此返回 exporter 之后，就完成了 invoker到exporter的转化。返回到ServiceConfig后服务发布过程到此结束。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="先看看之前遗留的两个问题："><a href="#先看看之前遗留的两个问题：" class="headerlink" title="先看看之前遗留的两个问题："></a>先看看之前遗留的两个问题：</h4><p><em>问题一：AbstractConfig 衍生的子类(ServiceConfig,ProviderConfig,RegistryConfig等) ，这么多的配置类是啥？</em> </p><p><em>问题二：这个 ProxyFactory$Adaptive是什么东东？ 看看 proxyFactory 是怎么来的。</em></p><h4 id="回答问题一："><a href="#回答问题一：" class="headerlink" title="回答问题一："></a>回答问题一：</h4><p>在dubbo-config模块中，代码里的解释已经很清楚了。这里简单介绍几个抽象配置:</p><ul><li>AbstractConfig：配置模板，配置解析的工具方法、公共方法，提供几个主要的方法（appendAnnotation，appendProperties，appendParameters，appendAttributes等）。 </li><li>AbstractMethodConfig：封装了一些方法级别的相关属性 </li><li>AbstractInterfaceConfig：封装了接口需要的属性 </li><li>AbstractReferenceConfig：主要是引用实例的配置</li></ul><p>再看一下dubbo-config-spring模块，与spring如何整合的：<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr5fm6vuzfj20i40dwwfj.jpg" alt=""><br>spring.handlers文件里如是写道：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure></p><p>dubbo的schema标签的定义就在DubboNamespaceHandler类中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));</span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，一目了然。</p><h4 id="回答问题二："><a href="#回答问题二：" class="headerlink" title="回答问题二："></a>回答问题二：</h4><p>这确实和dubbo插件机制有关，后面再单独写一篇文章分析。</p><h4 id="提出问题三-dubbo怎么启动的？"><a href="#提出问题三-dubbo怎么启动的？" class="headerlink" title="提出问题三:dubbo怎么启动的？"></a>提出问题三:dubbo怎么启动的？</h4><p>本文的分析是直接从dubbo文档和启动日志起手的，那么dubbo是怎么从加载spring容器到ServiceConfig暴露服务的呢？</p><p>再回顾看下dubbo暴露服务调用栈：<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fr5gaayhnwj20y20lcq8q.jpg" alt=""><br>还记得上面的 AbstractConfig家族的类图吗。ServiceBean继承自ServiceConfig。<br>ServiceBean实现了pplicationListener<contextrefreshedevent>接口，实现方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void onApplicationEvent(ContextRefreshedEvent event) &#123;</span><br><span class="line">    if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());</span><br><span class="line">        &#125;</span><br><span class="line">        export(); // 调用父类ServiceConfig的export()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></contextrefreshedevent></p><p>可见，在spring容器实例化bean完成后，发布ContextRefreshedEvent事件时调用ServiceConfig的export()方法。看看日志是不是有“The service ready on spring started. service:xxx”且在服务暴露日志前呢~</p><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>至此，初步完成了dubbo服务暴露过程的解析（ServiceConfig-&gt; Invoker-&gt;Exporter），但是上面服务暴露过程有些内容并没有详细分析，比如</p><ul><li>本地暴露与远程暴露的细枝末节</li><li>dubbo的扩展机制</li><li>获取注册中心注册服务（zookeeper）的过程</li><li>开启服务过程(Netty服务)<br>… </li></ul><p>这些后面一点点剖析。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>dubbo暴露服务过程总体分为三步：ServiceConfig-&gt; Invoker-&gt;Exporter.</li><li>AbstractConfig家族是spring与dubbo整合的核心配置</li><li>ServiceBean中开启spring容器加载完成后的暴露服务过程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;dubbo框架也用了有一年了，一直没有详细的研究过dubbo源码。所以趁有时间好好学习体会dubbo的博大精深。本人才疏学浅，如有不对，请大神指点。这里使用的dubbo版本是2.6.1。&lt;/p&gt;
&lt;p&gt;如何看源码？跟着&lt;a href=&quot;http://dubbo.apache.org/books/dubbo-dev-book/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo开发手册(中文)&lt;/a&gt;来喽。带着目的看源码，这次看dubbo是怎么暴露服务的。&lt;br&gt;
    
    </summary>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/categories/dubbo/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
      <category term="dubbo" scheme="http://www.chenruiwen.cn/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>使用 Bean Validation 解决业务中参数校验</title>
    <link href="http://www.chenruiwen.cn/2018/05/10/%E4%BD%BF%E7%94%A8%20Bean%20Validation%20%E8%A7%A3%E5%86%B3%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <id>http://www.chenruiwen.cn/2018/05/10/使用 Bean Validation 解决业务中参数校验/</id>
    <published>2018-05-10T12:26:24.000Z</published>
    <updated>2018-06-05T13:48:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>精简业务中的代码校验。<br><a id="more"></a></p><h1 id="痛点及现状"><a href="#痛点及现状" class="headerlink" title="痛点及现状"></a>痛点及现状</h1><p>代码中常常见到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Objects.equal(0L ,repertory))&#123;</span><br><span class="line">    return ApiResultMap.errorResult(-1 ,&quot;操作数量不可为0&quot;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种参数校验写在模块里有如下缺点：</p><ul><li>代码冗余</li><li>影响代码可读性</li><li>需要通过注释来知道每个入参的约束是什么。</li><li>每个程序员做参数验证的方式不一样，参数验证不通过抛出的异常也不一样。</li></ul><p><strong>抛出问题</strong>：那么有没有一种方式可以简化代码呢？</p><h1 id="JSR-303-Bean-Validation"><a href="#JSR-303-Bean-Validation" class="headerlink" title="JSR 303 - Bean Validation"></a>JSR 303 - Bean Validation</h1><p>Bean Validation是一个通过配置注解来验证参数的框架，它包含两部分Bean Validation API和Hibernate Validator。</p><ul><li>Bean Validation API是Java定义的一个验证参数的规范。</li><li>Hibernate Validator是Bean Validation API的一个实现。</li></ul><h1 id="QUICK-START"><a href="#QUICK-START" class="headerlink" title="QUICK START"></a>QUICK START</h1><ol><li><p>引入pom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.1.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>dto入参对象属性加入注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class ValidDemo &#123;</span><br><span class="line">    @Size(min = 3, max = 12, message = &quot;用户名必须的长度必须是3到12个字母之间&quot;)</span><br><span class="line">    @Pattern(regexp = &quot;^[a-z]+$&quot;, message = &quot;用户名必须是a-z小字母&quot;)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Size(min = 6, max = 6, message = &quot;密码必须是6位数字&quot;)</span><br><span class="line">    @Pattern(regexp = &quot;^[0-9]+$&quot;, message = &quot;密码必须是6位数字&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Range(min = 1, max = 9, message = &quot;范围只能1到9&quot;)</span><br><span class="line">    private Integer range;</span><br><span class="line"></span><br><span class="line">    @NotNull(message = &quot;邮箱不能为Null&quot;)</span><br><span class="line">    @Email(regexp = &quot;(?:[a-z0-9!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[a-z0-9!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*|\&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])&quot;,</span><br><span class="line">            message = &quot;邮箱格式有误&quot;)</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>controller方法入参加入校验(@Valid)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/validdemo&quot;)</span><br><span class="line">public Map&lt;String,Object&gt; demo(@Valid ValidDemo validDemo)&#123;</span><br><span class="line">return ApiResultMap.successResult(validDemo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>精简出参，加入全局异常处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(value = &#123; BindException.class &#125;)</span><br><span class="line">public Map&lt;String, Object&gt; validationException(BindException ex) &#123;</span><br><span class="line">    log.error(ex.getBindingResult().getFieldError().getDefaultMessage());</span><br><span class="line">    return ApiResultMap.errorResult(ex.getBindingResult().getFieldError().getDefaultMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$curl http://localhost:8080/validdemo?email=xxxxx</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;message&quot;: &#123;</span><br><span class="line">        &quot;code&quot;: -1,</span><br><span class="line">        &quot;message&quot;: &quot;邮箱格式有误&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>另一种方式，使用 spring 的 @Validated 注解:</strong></p><ol><li><p>配置 MethodValidationPostProcessor</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MethodValidationPostProcessor methodValidationPostProcessor() &#123;</span><br><span class="line">    return new MethodValidationPostProcessor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Validated注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Validated</span><br><span class="line">@RestController</span><br><span class="line">public class DemoController &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法上加上校验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/validdemo3&quot;)</span><br><span class="line">public Map&lt;String,Object&gt; demo3(@NotNull String str, @NotNull @Range(min = 0, max = 10) Integer a)&#123;</span><br><span class="line">return ApiResultMap.successResult(str + a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试 </p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$curl http://localhost:8080/validdemo?str=1&amp;a=15</span><br><span class="line">&#123;</span><br><span class="line">    &quot;message&quot;: &#123;</span><br><span class="line">        &quot;code&quot;: 202,</span><br><span class="line">        &quot;message&quot;: &quot;需要在0和10之间&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>java程序员张三和ios程序员李四开发某一需求，明天就要demo了，今天得抓紧联调。<br>李四:三哥，地址发下，调试绑卡。<br>张三启动服务…<br>李四：三哥，帮忙看下，这个接口报错 -1，看下上面错误呗。<br>张三打开控制台，看了一下日志与排查，数据库报错，身份证字段没传导致插入身份证为空报错。<br>张三：李四你身份证没传。…张三一边埋怨着一边加入一行if else，同时在思考别的接口是不是也有这种情况，也给加上if else.<br>没过一会儿，李四：三哥，帮我看下有报错-1了。<br>张三又去查看，同样的，这次是银行卡号没传。张三重复着以上操作可没过一会儿李四又….<br>就这样一天过去，伴随着晚霞下班的张三，心情却没那么高兴…</p><p><strong>抛出问题</strong>：是什么导致张三忙碌一天却觉得碌碌无为？是道德的沦丧还是人性的丧失？  </p><p>如果张三整合Bean Validation的话，可能就没有那么不愉快了。他只需要一次在入参model里加入校验，之后在控制器的通过轻松的 @Valid 注解，就可以省去李四重复的提问，也省去的检查其他接口是否也需要添加代码校验，代码又可以少些几行了，何乐而不为。</p><h1 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h1><p>Bean Validation 中内置的 constraint：  </p><ul><li>@Null    被注释的元素必须为 null</li><li>@NotNull    被注释的元素必须不为 null</li><li>@AssertTrue    被注释的元素必须为 true</li><li>@AssertFalse    被注释的元素必须为 false</li><li>@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li>@Size(max, min)    被注释的元素的大小必须在指定的范围内</li><li>@Digits (integer, fraction)    被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li>@Past    被注释的元素必须是一个过去的日期</li><li>@Future    被注释的元素必须是一个将来的日期</li><li>@Pattern(value)    被注释的元素必须符合指定的正则表达式</li></ul><p>Hibernate Validator 附加的 constraint：  </p><ul><li>@Email    被注释的元素必须是电子邮箱地址</li><li>@Length    被注释的字符串的大小必须在指定的范围内</li><li>@NotEmpty    被注释的字符串的必须非空</li><li>@Range    被注释的元素必须在合适的范围内</li></ul><h1 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h1><ul><li>代码整洁</li><li>代码可读性强</li><li>解决不同开发者的不同的校验方式</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>推荐使用 Bean Validation 的方式解决业务中参数校验；<br>这里只给出了一些基本的参数校验constraint，在实际业务中可根据业务情形自定义业务constraint。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;精简业务中的代码校验。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.chenruiwen.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu自定义安装Mysql全记录</title>
    <link href="http://www.chenruiwen.cn/2018/04/22/ubuntu%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85Mysql%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.chenruiwen.cn/2018/04/22/ubuntu自定义安装Mysql全记录/</id>
    <published>2018-04-22T12:18:49.000Z</published>
    <updated>2018-04-29T14:58:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下MySQL 5.7版本的安装过程。<br><a id="more"></a></p><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><ol start="0"><li><p>参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/binary-installation.html" target="_blank" rel="noopener">官方文档</a></p></li><li><p>下载mysql二进制文件，进入页面：    <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a><br>Select Operating System: Linux-Generic<br>并下载</p></li><li><p>切换到root用户创建group和user</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql# groupadd mysql</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql# useradd -r -g mysql dba -s /bin/false mysql</span><br></pre></td></tr></table></figure></li><li><p>解压下载的Mysql,重命名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql# tar -xf mysql-5.7.21-linux-glibc2.12-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql# mv mysql-5.7.21-linux-glibc2.12-x86_64 mysql-5.7.21</span><br></pre></td></tr></table></figure></li><li><p>赋予mysql操作权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# chown -R dba /data/mysql/mysql-5.7.21</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# chgrp -R mysql /data/mysql/mysql-5.7.21</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# mkdir mysql-files</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# chown dba:mysql mysql-files/</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# chmod 750 mysql-files</span><br></pre></td></tr></table></figure></li><li><p>初始化Mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysqld --initialize --user=dba</span><br><span class="line">mysqld: Can&apos;t create directory &apos;/usr/local/mysql/data/&apos; (Errcode: 2 - No such file or directory)</span><br><span class="line">2018-04-08T15:25:22.856110Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).</span><br><span class="line">2018-04-08T15:25:22.856195Z 0 [ERROR] Can&apos;t find error-message file &apos;/usr/local/mysql/share/errmsg.sys&apos;. Check error-message file location and &apos;lc-messages-dir&apos; configuration directive.</span><br><span class="line">2018-04-08T15:25:22.856935Z 0 [ERROR] Aborting</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21#</span><br></pre></td></tr></table></figure></li></ol><p>提示目录不存在，因为我的mysql目录是在/data/mysql/mysql-5.7.21</p><p>所以，要指定数据目录和basedir并初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# mkdir data</span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysqld --user=dba --basedir=/data/mysql/mysql-5.7.21 --datadir=/data/mysql/mysql-5.7.21/data/  --initialize-insecure</span><br><span class="line"></span><br><span class="line">2018-04-28T03:12:52.827802Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use --explicit_defaults_for_timestamp server option (see documentation for more details).</span><br><span class="line">2018-04-28T03:12:53.883717Z 0 [Warning] InnoDB: New log files created, LSN=45790</span><br><span class="line">2018-04-28T03:12:54.084754Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.</span><br><span class="line">2018-04-28T03:12:54.150087Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 0aca257d-4a92-11e8-af3b-00163e089ff5.</span><br><span class="line">2018-04-28T03:12:54.153185Z 0 [Warning] Gtid table is not ready to be used. Table &apos;mysql.gtid_executed&apos; cannot be opened.</span><br><span class="line">2018-04-28T03:12:54.153653Z 1 [Warning] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.</span><br></pre></td></tr></table></figure></p><p>这里我使用了 <strong>–initialize-insecure</strong> 参数，不设置root密码。<br>如果是 <strong>–initialize</strong> ，会随机生成一个密码。</p><ol start="6"><li>开启SSL，生成密钥文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysql_ssl_rsa_setup</span><br><span class="line">2018-04-28 11:21:57 [ERROR]   Failed to access directory pointed by --datadir. Please make sure that directory exists and is accessible by mysql_ssl_rsa_setup. Supplied value : /usr/local/mysql/data</span><br></pre></td></tr></table></figure></li></ol><p>报错,需要修改配置文件。修改 /etc/my.cnf –datadir 属性,创建 my.cnf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# vi /etc/my.cnf</span><br></pre></td></tr></table></figure></p><p>MySQL配置文件简单版：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># GENERAL</span><br><span class="line">character-set-server=utf8</span><br><span class="line">symbolic-links=0</span><br><span class="line">basedir=/data/mysql/mysql-5.7.21</span><br><span class="line">datadir=/data/mysql/mysql-5.7.21/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">user=dba</span><br><span class="line">port=3306</span><br><span class="line">pid-file=/data/mysql/mysql-5.7.21/data/mysql.pid</span><br><span class="line">default_storage_engine=InnoDB</span><br><span class="line"></span><br><span class="line">#LOGGING</span><br><span class="line">log_error=/data/mysql/mysql-5.7.21/log/mysql-error.log</span><br><span class="line"></span><br><span class="line">#OTHER</span><br><span class="line">open_files_limit=65535</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">port=3306</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/data/mysql/mysql-5.7.21/log/mysql-error.log</span><br><span class="line">pid-file=/data/mysql/mysql-5.7.21/data/mysql.pid</span><br></pre></td></tr></table></figure></p><p>定义的日志目录和文件手工创建一下，然后重新运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysql_ssl_rsa_setup</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">............................................+++</span><br><span class="line">........................+++</span><br><span class="line">writing new private key to &apos;ca-key.pem&apos;</span><br><span class="line">-----</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">....................................+++</span><br><span class="line">.................+++</span><br><span class="line">writing new private key to &apos;server-key.pem&apos;</span><br><span class="line">-----</span><br><span class="line">Generating a 2048 bit RSA private key</span><br><span class="line">..............................................................................+++</span><br><span class="line">..........................................+++</span><br><span class="line">writing new private key to &apos;client-key.pem&apos;</span><br><span class="line">-----</span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21#</span><br></pre></td></tr></table></figure></p><p>更多开启SSL相关请参考官方文档:<a href="https://dev.mysql.com/doc/refman/5.7/en/creating-ssl-rsa-files.html" target="_blank" rel="noopener"><br>Creating SSL and RSA Certificates and Keys</a></p><ol start="7"><li>安全启动MySQL服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# bin/mysqld_safe --user=dba &amp;</span><br></pre></td></tr></table></figure></li></ol><p>查看MySQL服务进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# ps -ef|grep mysql</span><br><span class="line">root     14899 11849  0 15:20 pts/0    00:00:00 /bin/sh bin/mysqld_safe --user=dba</span><br><span class="line">dba      15135 14899  0 15:20 pts/0    00:00:00 /data/mysql/mysql-5.7.21/bin/mysqld --basedir=/data/mysql/mysql-5.7.21 --datadir=/data/mysql/mysql-5.7.21/data --plugin-dir=/data/mysql/mysql-5.7.21/lib/plugin --user=dba --log-error=/data/mysql/mysql-5.7.21/log/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql-5.7.21/data/mysql.pid --socket=/tmp/mysql.sock --port=3306</span><br><span class="line">root     15201 11849  0 15:27 pts/0    00:00:00 grep --color=auto mysql</span><br></pre></td></tr></table></figure></p><p>启动成功。</p><ol start="8"><li>(可选项)加到系统服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# cp support-files/mysql.server /etc/init.d/mysql.server</span><br></pre></td></tr></table></figure></li></ol><p>修改 mysqld 文件里的 basedir，datadir， mysqld_pid_file_path属性</p><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# mysql -uroot -p</span><br><span class="line">The program &apos;mysql&apos; can be found in the following packages:</span><br><span class="line"> * mysql-client-core-5.7</span><br><span class="line"> * mariadb-client-core-10.0</span><br><span class="line">Try: apt install &lt;selected package&gt;</span><br></pre></td></tr></table></figure><p>安装客户端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# apt-get update</span><br><span class="line">root@chenruiwen:/data/mysql/mysql-5.7.21# apt-get install mysql-client-core-5.7</span><br></pre></td></tr></table></figure></p><p>安装完成后重新连接MySQL，输入密码时直接回车，登录成功。</p><p>修改 root 密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; update user set authentication_string = password(&apos;123456&apos;), password_expired = &apos;N&apos;, password_last_changed = now() where user = &apos;root&apos;;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 1</span><br></pre></td></tr></table></figure></p><p>退出，重启即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记录一下MySQL 5.7版本的安装过程。&lt;br&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://www.chenruiwen.cn/tags/mysql/"/>
    
      <category term="运维" scheme="http://www.chenruiwen.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>java8实战学习总结</title>
    <link href="http://www.chenruiwen.cn/2018/04/21/java8%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://www.chenruiwen.cn/2018/04/21/java8实战学习总结/</id>
    <published>2018-04-21T15:38:49.000Z</published>
    <updated>2018-06-05T13:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java8作为一次大的升级，语法层面上有很大的改变，于是，来尝尝Java8的鲜。(ps: 哈哈，java10都出了，java8还不熟咋办呢~ 学学吧~)</p><a id="more"></a><h2 id="为什么要用Java8"><a href="#为什么要用Java8" class="headerlink" title="为什么要用Java8"></a>为什么要用Java8</h2><ul><li><strong>elasticsearch:</strong> Elasticsearch requires Java 8 or later. Use the official Oracle distribution or an open-source distribution such as OpenJDK.</li><li><strong>dubbo:</strong> Requires JDK1.8+, if you use lower version, see 1.6+, use 2.5.5</li><li><strong>spring:</strong> JDK 8+ for Spring Framework 5.x<br>……</li></ul><p>很多主流框架已经使用java8进行升级开发，java8是趋势，是时候一起拥抱java8了.</p><h2 id="java8语言新特性"><a href="#java8语言新特性" class="headerlink" title="java8语言新特性"></a>java8语言新特性</h2><ul><li>函数式编程</li><li>Lambda表达式</li><li>接口的默认方法和静态方法</li><li>stream API</li><li>新的类库：Optional,Streams,Date/Time API (JSR 310)…</li><li>JVM新特性</li></ul><h3 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h3><p>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据。</p><h4 id="1-1-lambda的基本语法是："><a href="#1-1-lambda的基本语法是：" class="headerlink" title="1.1 lambda的基本语法是："></a>1.1 lambda的基本语法是：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure></p><p>eg:java8中有效的lambda表达式：</p><ol><li><p>一个String类型的参数并返回一个int。Lambda中没有return语句，因为已经隐含了return。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String s) -&gt; s.length()</span><br></pre></td></tr></table></figure></li><li><p>两个int类型的参数而没有返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(int x, int y) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;Result:&quot;);</span><br><span class="line">    System.out.println(x+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有参数，返回一个int</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; 1</span><br></pre></td></tr></table></figure></li></ol><h4 id="1-2-函数式接口"><a href="#1-2-函数式接口" class="headerlink" title="1.2 函数式接口"></a>1.2 函数式接口</h4><ul><li>函数式接口(函数式接口就是只定义一个抽象方法的接口)</li><li>函数描述符(函数式接口的抽象方法的签名 就是 lambda表达式的签名)</li></ul><p>java8中接口的变化:<br>Java 8用<strong>默认方法</strong>与<strong>静态方法</strong>这两个新概念来扩展接口的声明。<br>此功能是为了向后兼容性增加，使旧接口可用于利用JAVA8，lambda表达式的能力<br>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。</p><p>在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。</p><p>目前已存在的函数式接口有：Comparable、Runnable和Callable等。<br>java8在java.util.function中有引入了很多个新的函数式接口:</p><ul><li>Predicate<t>  输入参数为类型T， 输出为类型boolean， 记作 T -&gt; boolean</t></li><li>Consumer<t>  输入参数为类型T， 输出为void， 记作 T -&gt; void</t></li><li>Function&lt;T,R&gt;   输入参数为类型T， 输出为类型R， 记作 T -&gt; R </li><li>Supplier<t>   没有输入参数， 输出为类型T， 记作 void -&gt; T<br>…</t></li></ul><h4 id="1-3方法引用"><a href="#1-3方法引用" class="headerlink" title="1.3方法引用"></a>1.3方法引用</h4><p>方法引用让你可以重复使用现有的方法定义，并像Lambda一样传递它们。<br>当你需要使用方法引用时，目标引用放在分隔符::前，方法的名称放在后面。</p><p><strong>三种方法引用：</strong> </p><ol><li>指向静态方法的方法引用。<br>lambda表达式:   (args) -&gt; ClassName.staticMethod(args)<br>方法引用:       ClassName::staticMethod</li></ol><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s -&gt; Integer.valueOf(s) 等价于 Integer::valueOf</span><br></pre></td></tr></table></figure></p><ol start="2"><li>指向任意类型实例方法的方法引用。<br>lambda表达式:   (arg0, rest) -&gt; arg0.instanceMethod(rest)<br>方法引用:       ClassName::instanceMethod<br>(上面args0是ClassName类型的)</li></ol><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(str, integer) -&gt; str.substring(integer) 等价于 String::substring</span><br></pre></td></tr></table></figure></p><ol start="3"><li>指向现有对象的实例方法的方法引用。<br>lambda表达式:   (args) -&gt; expr.instanceMethod(args)<br>方法引用:       expr::instanceMethod</li></ol><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Apple arg) -&gt; appleExpr.compareAppleWight(arg) 等价于 appleExpr::compareAppleWight</span><br></pre></td></tr></table></figure></p><ul><li>构造函数的方法引用。<br>对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用：<br>ClassName::new。它的功能与指向静态方法的引用类似。</li></ul><p>比如创建一个Apple对象。<br>空参构造器Apple()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 = Apple::new;</span><br><span class="line">Apple a1 = c1.get();</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">Supplier&lt;Apple&gt; c1 = () -&gt; new Apple();</span><br><span class="line">Apple a1 = c1.get();</span><br></pre></td></tr></table></figure></p><p>两个参数的构造函数Apple(String color, Integer weight)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BiFunction&lt;Integer, String, Apple&gt; biFunction = Apple::new;</span><br><span class="line">Apple apple2 = biFunction.apply(155, &quot;green&quot;);</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line">BiFunction&lt;Integer, String, Apple&gt; biFunction = (weight, color) -&gt; new Apple(weight, color);</span><br><span class="line">Apple apple2 = biFunction.apply(155, &quot;green&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="1-4-复合lambda表达式"><a href="#1-4-复合lambda表达式" class="headerlink" title="1.4 复合lambda表达式"></a>1.4 复合lambda表达式</h4><ol><li>比较器(Comparator<t>)复合(reversed(),thenComparing())</t></li><li>谓词(Predicate<t>)复合(negate(),and(),or())</t></li><li>函数(Function&lt;T, V&gt;)复合(compose(),andThen(),identity())</li></ol><h3 id="2-Stream-API"><a href="#2-Stream-API" class="headerlink" title="2.Stream API"></a>2.Stream API</h3><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。</p><p>Stream API(java.util.stream.*)可以让你的代码具备：</p><ul><li>声明性：更简洁，更易读</li><li>可复合：更灵活</li><li>可并行：性能更好</li></ul><h4 id="2-1-什么是流"><a href="#2-1-什么是流" class="headerlink" title="2.1 什么是流"></a>2.1 什么是流</h4><p>流不是一种数据结构，而是处理集合元素的相关计算，更像一个高级的 Iterator。单向，不可往复，数据只能遍历一次。</p><p><strong>如何使用流？</strong>  </p><ol><li>一个数据源（如集合）来执行一个查询；</li><li>一个中间操作链，形成一条流的流水线；</li><li>一个终端操作，执行流水线，并能生成结果。</li></ol><h4 id="2-2-使用流"><a href="#2-2-使用流" class="headerlink" title="2.2 使用流"></a>2.2 使用流</h4><ul><li>筛选、切片和匹配</li><li>查找、匹配和归约</li><li>使用数值范围等数值流</li><li>从多个源创建流</li><li>无限流</li></ul><h5 id="2-2-1-筛选，切片"><a href="#2-2-1-筛选，切片" class="headerlink" title="2.2.1 筛选，切片"></a>2.2.1 筛选，切片</h5><ul><li>filter  (筛选过滤)</li><li>distinct (去重)</li><li>limit (截取)</li><li>skip  (跳过)</li></ul><h5 id="2-2-2-映射"><a href="#2-2-2-映射" class="headerlink" title="2.2.2 映射"></a>2.2.2 映射</h5><ul><li>map (映射:接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素)</li><li>flatMap (flatmap方法让你把一个流中的每个值都换成另一个流，然后把所有的流连接起来成为一个流。)</li></ul><h5 id="2-2-3-查找和匹配"><a href="#2-2-3-查找和匹配" class="headerlink" title="2.2.3 查找和匹配"></a>2.2.3 查找和匹配</h5><ul><li>anyMatch (检查谓词是否至少匹配一个元素)</li><li>allMatch (检查谓词是否匹配所有元素)</li><li>noneMatch (检查是否没有任何元素与给定的谓词匹配)</li><li>findAny (返回当前流中的任意元素Optional<t>。它可以与其他流操作结合使用。)</t></li><li>findFirst (返回流中第一个元素Optional<t>)</t></li></ul><h5 id="2-2-4-reduce"><a href="#2-2-4-reduce" class="headerlink" title="2.2.4 reduce"></a>2.2.4 reduce</h5><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。</p><ul><li>Optional<t> reduce(BinaryOperator<t> accumulator);</t></t></li><li>T reduce(T identity, BinaryOperator<t> accumulator);</t></li><li>U reduce(U identity,BiFunction&lt;U, ? super T, U&gt;      accumulator,BinaryOperator&lt; U &gt; combiner);</li></ul><h5 id="2-2-5-数值流"><a href="#2-2-5-数值流" class="headerlink" title="2.2.5 数值流"></a>2.2.5 数值流</h5><ul><li>IntStream</li><li>DoubleStream</li><li>LongStream</li></ul><h5 id="2-2-6-创建流"><a href="#2-2-6-创建流" class="headerlink" title="2.2.6 创建流"></a>2.2.6 创建流</h5><ul><li>由值创建流(Stream.of)</li><li>由数组创建流(Arrays.stream(array))</li><li>由文件生成流(java.nio.file.Files)</li><li>由函数生成流：创建无限流(Stream.iterate和Stream.generate) </li></ul><h5 id="2-3-收集器"><a href="#2-3-收集器" class="headerlink" title="2.3 收集器"></a>2.3 收集器</h5><ul><li>用Collectors类创建和使用收集器</li><li>将数据流归约为一个值</li><li>汇总：归约的特殊情况</li><li>数据分组和分区</li><li>自定义收集器</li></ul><h6 id="2-3-1-归约和汇总"><a href="#2-3-1-归约和汇总" class="headerlink" title="2.3.1 归约和汇总"></a>2.3.1 归约和汇总</h6><p>Stream.reduce 与 Stream.collect的区别：<br>Stream.reduce，常用的方法有average, sum, min, max, and count，返回单个的结果值，并且reduce操作每处理一个元素总是创建一个新值。<br>Stream.collect修改现存的值，而不是每处理一个元素，创建一个新值。</p><h6 id="2-3-2-数据分组"><a href="#2-3-2-数据分组" class="headerlink" title="2.3.2 数据分组"></a>2.3.2 数据分组</h6><ul><li><p>一级分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; groupByType = menuList.stream().collect(groupingBy(Dish::getType));</span><br></pre></td></tr></table></figure></li><li><p>多级分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; groupByTypeAndCalories = menuList.stream().collect(</span><br><span class="line">            groupingBy(Dish::getType,</span><br><span class="line">                    groupingBy(dish -&gt; &#123;</span><br><span class="line">                        if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;</span><br><span class="line">                        else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;</span><br><span class="line">                        else return CaloricLevel.FAT;</span><br><span class="line">                    &#125;))</span><br><span class="line">    );</span><br></pre></td></tr></table></figure></li><li><p>按子组收集数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Long&gt; groupByTypeToCount = menuList.stream().collect(groupingBy(Dish::getType, counting()));</span><br></pre></td></tr></table></figure></li><li><p>分区(分区是一种特殊的分组，结果map至少包含两个不同的分组——一个true，一个false。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionByVegeterian =</span><br><span class="line">                menuList.stream().collect(partitioningBy(Dish::isVegetarian));</span><br></pre></td></tr></table></figure></li></ul><h6 id="2-3-3-Collector接口"><a href="#2-3-3-Collector接口" class="headerlink" title="2.3.3 Collector接口"></a>2.3.3 Collector接口</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Collector&lt;T, A, R&gt; &#123;</span><br><span class="line">    Supplier&lt;A&gt; supplier()</span><br><span class="line">    BiConsumer&lt;A, T&gt; accumulator()</span><br><span class="line">    Function&lt;A, R&gt; finisher()</span><br><span class="line">    BinaryOperator&lt;A&gt; combiner()</span><br><span class="line">    Set&lt;Characteristics&gt; characteristics()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collector接口的三个泛型：</p><ul><li>T：stream在调用collect方法收集前的数据类型</li><li>A：A是T的累加器，遍历T的时候，会把T按照一定的方式添加到A中，换句话说就是把一些T通过一种方式变成A</li><li>R：R可以看成是A的累加器，是最终的结果，是把A汇聚之后的数据类型，换句话说就是把一些A通过一种方式变成R</li></ul><p>通过自定义ToList收集器理解接口方法：</p><ul><li><p>Supplier<a> supplier()<br>怎么创建一个累加器（这里对应的是如何创建一个List）</a></p></li><li><p>BiConsumer&lt;A, T&gt; accumulator()<br>怎么把一个对象添加到累加器中（这里对应的是如何在List里添加一个对象，当然是调用add方法）</p></li><li><p>Function&lt;A, R&gt; finisher()<br>其实就是怎么把A转化为R，由于是toList，所以A和R是一样的类型，这里其实用就是Function.identity</p></li><li><p>BinaryOperator<a> combiner()<br>它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并（这里对应的是如何把List和List合并起来，当然是调用addAll，这里由于最终要返回List，所以A和R是一个类型，都是List所以才调用addAll）</a></p></li><li><p>Set<characteristics> characteristics()<br>会返回一个不可变的Characteristics集合，它定义<br>了收集器的行为——尤其是关于流是否可以并行归约，以及可以使用哪些优化的提示，toList这里只用了Characteristics.IDENTITY_FINISH</characteristics></p></li></ul><h5 id="2-4-并行数据处理"><a href="#2-4-并行数据处理" class="headerlink" title="2.4 并行数据处理"></a>2.4 并行数据处理</h5><p><strong>并行流：</strong><br>可以通过对收集源调用parallelStream方法来把集合转换为并行流。并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p><p><strong>问题:并行流用的线程是从哪儿来的？有多少个？怎么自定义这个过程呢？</strong><br>并行流内部使用了默认的ForkJoinPool，它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available-Processors()得到的。<br>但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common.parallelism 来改变线程池大小，如下所示：<br>System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”);<br>这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值，除非你有很好的理由，否则我们强烈建议你不要修改它。</p><p><strong>使用并行流：</strong><br>本地测试的过程中，并行流比顺序流效果差。原因可能与机器，处理的数据量，使用并行流的方式等有关系。  </p><p>是否使用并行流需考虑如下几种情况：</p><ol><li>留意装箱。(使用（IntStream、LongStream、DoubleStream来避免装箱拆箱)</li><li>有些操作本身在并行流上的性能就比顺序流差。(limit,findFirst等依赖于元素顺序的操作)</li><li>考虑流的操作流水线的总计算成本。设N是要处理的元素的总数，Q是一个元素通过流水线的大致处理成本，则N*Q就是这个对成本的一个粗略的定性估计。Q值较高就意味着使用并行流时性能好的可能性比较大。</li><li>数据量较小的情况不适合并行流。</li><li>考虑流背后的数据结构是否易于分解。</li><li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能。</li><li>考虑终端操作中合并步骤的代价是大是小（例如Collector中的combiner方法）。</li></ol><p>流的数据源<br>源 | 可分解性<br>—|—<br>ArrayList | 极佳<br>LinkedList | 差<br>IntStream.range | 极佳<br>Stream.iterate | 差<br>HashSet | 好<br>TreeSet | 好</p><h3 id="3-Optional使用"><a href="#3-Optional使用" class="headerlink" title="3.Optional使用"></a>3.Optional使用</h3><ul><li>使用Optional避免null引用</li><li>整洁代码中对null的检查</li><li>Optional的使用</li></ul><p>java中的null带来了种种问题：典型常见，使代码膨胀，自身无意义等等等。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>empty</td><td>返回一个空的Optional 实例</td></tr><tr><td>filter</td><td>如果值存在并且满足提供的谓词，就返回包含该值的Optional 对象；否则返回一个空的Optional 对象</td></tr><tr><td>flatMap</td><td>如果值存在，就对该值执行提供的mapping函数调用，返回一个Optional 类型的值，否则就返回一个空的Optional 对象</td></tr><tr><td>get</td><td>如果该值存在，将该值用Optional封装返回，否则抛出一个NoSuchElementException 异常</td></tr><tr><td>ifPresent</td><td>如果值存在，就执行使用该值的方法调用，否则什么也不做</td></tr><tr><td>isPresent</td><td>如果值存在就返回true，否则返回false</td></tr><tr><td>map</td><td>如果值存在，就对该值执行提供的mapping 函数调用</td></tr><tr><td>of</td><td>将指定值用Optional封装之后返回，如果该值为null，则抛出一个NullPointerException异常</td></tr><tr><td>ofNullable</td><td>将指定值用Optional封装之后返回，如果该值为null，则返回一个空的Optional 对象</td></tr><tr><td>orElse</td><td>如果有值则将其返回，否则返回一个默认值</td></tr><tr><td>orElseGet</td><td>如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr><tr><td>orElseThrow</td><td>如果有值则将其返回，否则抛出一个由指定的Supplier接口生成的异常</td></tr></tbody></table><p>注意：Optional 无法序列化</p><h3 id="4-新的日期和时间API"><a href="#4-新的日期和时间API" class="headerlink" title="4.新的日期和时间API"></a>4.新的日期和时间API</h3><p>新的 java.time 中包含了所有关于：<br>时钟（Clock）、本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。  </p><p>历史悠久的 Date 类新增了 toInstant() 方法，用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简化了了日期时间和本地化的管理。<br>目前Java8新增了java.time包定义的类表示日期-时间概念的规则，很方便使用；最重要的一点是<strong>值不可变，且线程安全</strong>。</p><p>本地日期时间API:</p><ul><li>LocalDate(年月日)</li><li>LocalTime(时分秒)</li><li>localDateTime(年月日时分秒)</li></ul><p>时区API：</p><ul><li>ZonedDateTime</li></ul><p>时钟API：</p><ul><li>Clock</li></ul><p>计算日期时间差API：</p><ul><li>Period(处理有关基于时间的日期数量。)</li><li>Duration(处理有关基于时间的时间量。)</li></ul><p>时间格式化API</p><ul><li>DateTimeFormatter(DateTimeFormatter实例都是线程安全<br>的)</li></ul><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><ol><li><p>java类库标准base64编码使用方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final String text = &quot;测试Abc123!!￥￥&quot;;</span><br><span class="line">final String encoded = Base64.getEncoder().encodeToString(text.getBytes(StandardCharsets.UTF_8)); </span><br><span class="line">System.out.println(encoded); // 5rWL6K+VQWJjMTIzISHvv6Xvv6U=</span><br><span class="line">final String decoded = new String(Base64.getDecoder().decode(encoded), StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(decoded); // 测试Abc123!!￥￥</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// url encode</span><br><span class="line">final String url = &quot;http://www.jinhui365.com/abc?foo=中文&amp;￥%&amp;bar=hello123&amp;baz=http://abc/def123&quot;;</span><br><span class="line">final String encoded2 = Base64.getUrlEncoder().encodeToString(url.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">System.out.println(encoded2); // aHR0cDovL3d3dy5qaW5odWkzNjUuY29tL2FiYz9mb2895Lit5paHJu-_pSUmYmFyPWhlbGxvMTIzJmJhej1odHRwOi8vYWJjL2RlZjEyMw==</span><br><span class="line">final String decoded2 = new String(Base64.getUrlDecoder().decode(encoded2), StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(decoded2); // http://www.jinhui365.com/abc?foo=中文&amp;￥%&amp;bar=hello123&amp;baz=http://abc/def123</span><br></pre></td></tr></table></figure></li><li><p>jvm的变化:<br>PermGen空间被移除了，取而代之的是Metaspace（JEP 122）。  JVM选项    -XX:PermSize与-XX:MaxPermSize分别被<br>-XX:MetaSpaceSize与-XX:MaxMetaspaceSize所代替。</p></li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Java8 作为 Java 语言的一次重大发布，包含语法上的更改、新的方法与数据类型，以及一些能默默提升应用性能的隐性改善。而且java8有利于提高开发生产力，对于开发者来说是好事，也是趋势。但是生产中使用java8可能存在风险，在正式使用Java8之前，不妨先体验一下java8的神奇。</p><p>附《java8 in action》源码:<a href="https://github.com/java8/Java8InAction.git" target="_blank" rel="noopener">https://github.com/java8/Java8InAction.git</a>   </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;java8作为一次大的升级，语法层面上有很大的改变，于是，来尝尝Java8的鲜。(ps: 哈哈，java10都出了，java8还不熟咋办呢~ 学学吧~)&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.chenruiwen.cn/categories/java/"/>
    
    
      <category term="java" scheme="http://www.chenruiwen.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>微博图床插件打包</title>
    <link href="http://www.chenruiwen.cn/2018/04/20/%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A%E6%8F%92%E4%BB%B6%E6%89%93%E5%8C%85/"/>
    <id>http://www.chenruiwen.cn/2018/04/20/微博图床插件打包/</id>
    <published>2018-04-20T06:31:43.000Z</published>
    <updated>2018-04-30T10:14:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寻找一个免费的图床软件，微博图床真的是太好不过了~~（手动感谢微博图床！）。之前安装微博图床的chrome插件，本人手贱删了，现在暂时也没翻到墙外，一时间需要重新安装微博图床的chrome插件，甚是着急。网上提供的一些插件也都没用，只能另求他路。<br><a id="more"></a></p><h1 id="通过自己打包安装微博图床插件"><a href="#通过自己打包安装微博图床插件" class="headerlink" title="通过自己打包安装微博图床插件"></a>通过自己打包安装微博图床插件</h1><ol><li><p>链接到微博图床github地址并下载。url如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/suxiaogang/WeiboPicBed</span><br></pre></td></tr></table></figure></li><li><p>打开chrome扩展程序<br>打开chrome浏览器，输入如下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrome://extensions/</span><br></pre></td></tr></table></figure></li><li><p>打开开发者模式，点击 打包扩展程序<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fq68oqn95lj20mn09ygmb.jpg" alt=""></p></li><li><p>打包扩展程序， 扩展程序目录选择 github上 clone下来的目录，点击打包即可。<br>会在同级目录下生成 .crx 和 .pem结尾文件，其中 .crx结尾文件即是扩展程序<br><img src="http://ww1.sinaimg.cn/large/87faef88ly1fq68qz213aj20fj04wmxd.jpg" alt=""></p></li></ol><h1 id="安装微博图床插件"><a href="#安装微博图床插件" class="headerlink" title="安装微博图床插件"></a>安装微博图床插件</h1><p>直接拖动微博图床插件(WeiboPicBed.crx)至chrome扩展程序即可。然后你就可以肆意上传图片了~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;寻找一个免费的图床软件，微博图床真的是太好不过了~~（手动感谢微博图床！）。之前安装微博图床的chrome插件，本人手贱删了，现在暂时也没翻到墙外，一时间需要重新安装微博图床的chrome插件，甚是着急。网上提供的一些插件也都没用，只能另求他路。&lt;br&gt;
    
    </summary>
    
      <category term="tips" scheme="http://www.chenruiwen.cn/categories/tips/"/>
    
    
      <category term="tool" scheme="http://www.chenruiwen.cn/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>基于hexo+nginx快速建站</title>
    <link href="http://www.chenruiwen.cn/2018/04/18/%E5%9F%BA%E4%BA%8Ehexo+nginx%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99/"/>
    <id>http://www.chenruiwen.cn/2018/04/18/基于hexo+nginx快速建站/</id>
    <published>2018-04-18T15:10:32.000Z</published>
    <updated>2018-06-01T15:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跟公司大神学习技术知识，发现大神们都有自己的技术博客，拥有个人网站，感觉很酷。所以趁着一波阿里云打折，开启自己个人网站之路。准备着手从个人博客网站开始，无奈自己是一个小小后端程序猿，前端技术了解不多，难道要开始先积累前端技术栈再建站吗？orz。当然不，网上有大量博客框架和教程可以快速建站，比如Hexo,Wordpress等。本人博客 1.0版本就准备用hexo开始。<br>本文并非部署到github上，想要部署到github另行参考。<br><a id="more"></a></p><h2 id="Hexo特点"><a href="#Hexo特点" class="headerlink" title="Hexo特点"></a>Hexo特点</h2><p>不妨登录<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a>瞧一瞧。</p><ul><li>Blazing Fast</li><li>Markdown Support</li><li>One-Command Deployment</li><li>Various Plugins</li></ul><p>总之就是很快，支持markdown，简单到一键部署，拥有多样性插件。</p><h2 id="快速搭建博客"><a href="#快速搭建博客" class="headerlink" title="快速搭建博客"></a>快速搭建博客</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>一台阿里云ECS，环境安装有:</p><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>, </li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="https://nginx.org/" target="_blank" rel="noopener">Nginx</a></li></ul><p>Ubuntu安装Node.js<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖包python-software-properties</span></span><br><span class="line">apt-get install python-software-properties</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">apt-get install nodejs</span><br></pre></td></tr></table></figure></p><p>Ubuntu安装Git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository ppa:git-core/ppa</span><br><span class="line">apt update</span><br><span class="line">apt install git</span><br></pre></td></tr></table></figure></p><p>Ubuntu安装Nginx（略）</p><p>安装 Hexo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>创建博客需要文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /data</span><br><span class="line">midir hexo-blog</span><br><span class="line">cd hexo-blog</span><br><span class="line">hexo init</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><h3 id="配置网站信息"><a href="#配置网站信息" class="headerlink" title="配置网站信息"></a>配置网站信息</h3><p>修改 _config.yml 文件, 仅修改了站点信息和地址信息, 更多的配置信息参考官网<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 陈瑞文的个人网站</span><br><span class="line">subtitle:</span><br><span class="line">description: 你好，旅行者</span><br><span class="line">keywords:</span><br><span class="line">author: 陈瑞文</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://www.chenruiwen.cn</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></p><p>顺便下载了github上比较高排名的hexo主题：Next.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next</span><br></pre></td></tr></table></figure></p><p>将文件夹拷贝到Hexo博客目录的themes文件夹下，并修改站点主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><p>剩下的个性化配置参考：<br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a><br>进行配置。此外，参考了大佬们的文章：</p><ul><li><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html" target="_blank" rel="noopener">打造个性超赞博客Hexo+NexT+GithubPages的超深度优化</a></li><li><a href="http://cherryblog.site/Hexo-high-level-tutorialcloudmusic,bg-customthemes-statistical.html" target="_blank" rel="noopener">hexo高阶教程next主题优化</a></li><li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></li><li><a href="http://www.dingxuewen.com/categories/Site/" target="_blank" rel="noopener">Hexo搭建博客的个性化设置</a></li></ul><h3 id="通过Nginx发布"><a href="#通过Nginx发布" class="headerlink" title="通过Nginx发布"></a>通过Nginx发布</h3><h4 id="Nginx下载安装"><a href="#Nginx下载安装" class="headerlink" title="Nginx下载安装"></a>Nginx下载安装</h4><p>略。  </p><h4 id="部署静态站点"><a href="#部署静态站点" class="headerlink" title="部署静态站点"></a>部署静态站点</h4><p>生成静态文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  hexo-blog hexo g</span><br><span class="line">➜  hexo-blog ls</span><br><span class="line">_config.yml       node_modules      public            themes</span><br><span class="line">db.json           package-lock.json scaffolds</span><br><span class="line">debug.log         package.json      source</span><br></pre></td></tr></table></figure></p><p>生成好的静态文件在public 文件夹内。</p><h4 id="修改nginx配置文件"><a href="#修改nginx配置文件" class="headerlink" title="修改nginx配置文件"></a>修改nginx配置文件</h4><p>修改nginx配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p><p>仅需修改http模块的server配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  www.chenruiwen.cn;</span><br><span class="line">        charset utf-8;</span><br><span class="line">        </span><br><span class="line">        root   /data/hexo-blog/public;# 这里是静态文件地址</span><br><span class="line">        location / &#123;</span><br><span class="line">            index  index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新加载nginx：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></p><p>至此，网站已初步建成。</p><h3 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h3><h5 id="通过git部署"><a href="#通过git部署" class="headerlink" title="通过git部署"></a>通过git部署</h5><ul><li>创建GitHub Repository(略)</li><li><p>修改配置文件_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/crrrrrw/hexo_static_page.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>安装hexo git插件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ul><p>这样，所有文件就都提交到github库上了。</p><p>服务器上，克隆静态文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data</span><br><span class="line">git clone https://github.com/crrrrrw/hexo_static_page.git</span><br><span class="line">git pull origin master</span><br></pre></td></tr></table></figure></p><p>即可实现静态文件的更新。然后nginx重新指向这个静态文件目录即可。</p><h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>思路a:<br>脚本定时更新github地址。</p><p>思路b:<br>基于git hooks实现push后的自动化部署。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，搭建博客环境很简单，不过还有很多的工作要做，比如优化自己博客的样式，增加一些有意思的功能等，以后会慢慢优化的。当然，最重要的是写出好的有用的博文分享出去。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;跟公司大神学习技术知识，发现大神们都有自己的技术博客，拥有个人网站，感觉很酷。所以趁着一波阿里云打折，开启自己个人网站之路。准备着手从个人博客网站开始，无奈自己是一个小小后端程序猿，前端技术了解不多，难道要开始先积累前端技术栈再建站吗？orz。当然不，网上有大量博客框架和教程可以快速建站，比如Hexo,Wordpress等。本人博客 1.0版本就准备用hexo开始。&lt;br&gt;本文并非部署到github上，想要部署到github另行参考。&lt;br&gt;
    
    </summary>
    
      <category term="blog" scheme="http://www.chenruiwen.cn/categories/blog/"/>
    
    
      <category term="blog" scheme="http://www.chenruiwen.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu安装Nginx全记录</title>
    <link href="http://www.chenruiwen.cn/2018/04/16/ubuntu%E5%AE%89%E8%A3%85Nginx%E5%85%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://www.chenruiwen.cn/2018/04/16/ubuntu安装Nginx全记录/</id>
    <published>2018-04-16T05:01:24.000Z</published>
    <updated>2018-04-30T10:12:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录下nginx安装过程。本文只演示源码包编译安装。个人比较喜欢自定义安装，灵活。<br><a id="more"></a></p><h2 id="nginx下载相关"><a href="#nginx下载相关" class="headerlink" title="nginx下载相关"></a>nginx下载相关</h2><p>官方下载页面：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a>  </p><p>configure配置文件详解：<a href="http://nginx.org/en/docs/configure.html" target="_blank" rel="noopener">http://nginx.org/en/docs/configure.html</a></p><h2 id="安装编译工具及库文件"><a href="#安装编译工具及库文件" class="headerlink" title="安装编译工具及库文件"></a>安装编译工具及库文件</h2><p>安装gcc g++的依赖库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:~# apt-get install build-essential</span><br><span class="line"></span><br><span class="line">root@chenruiwen:~# apt-get install libtool</span><br></pre></td></tr></table></figure></p><p>安装pcre依赖库（<a href="http://www.pcre.org/）" target="_blank" rel="noopener">http://www.pcre.org/）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:~# apt-get update</span><br><span class="line"></span><br><span class="line">root@chenruiwen:~# apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure></p><p>安装zlib依赖库（<a href="http://www.zlib.net）" target="_blank" rel="noopener">http://www.zlib.net）</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:~# apt-get install zlib1g-dev</span><br></pre></td></tr></table></figure></p><p>安装SSL依赖库（16.04默认已经安装了）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:~# apt-get install openssl</span><br></pre></td></tr></table></figure></p><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><p>下载nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx# wget http://nginx.org/download/nginx-1.6.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx# tar xf nginx-1.6.2.tar.gz</span><br></pre></td></tr></table></figure></p><p>进入解压目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx# cd nginx-1.6.2/</span><br></pre></td></tr></table></figure></p><p>配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx/nginx-1.6.2# ./configure --prefix=/usr/local/nginx</span><br></pre></td></tr></table></figure></p><p>编译,安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx/nginx-1.6.2# make</span><br><span class="line"></span><br><span class="line">root@chenruiwen:/data/nginx/nginx-1.6.2# make install</span><br></pre></td></tr></table></figure></p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx/nginx-1.6.2# /usr/local/nginx/sbin/nginx -v</span><br><span class="line">nginx version: nginx/1.6.2</span><br></pre></td></tr></table></figure></p><p>nginx安装完成</p><p>配置软链接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx/nginx-1.6.2# ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure></p><p>现在就可以不用路径直接输入nginx启动。</p><p>启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@chenruiwen:/data/nginx/nginx-1.6.2# nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></p><h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>跳转<a href="http://www.chenruiwen.cn/2018/04/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">Nginx配置文件详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记录下nginx安装过程。本文只演示源码包编译安装。个人比较喜欢自定义安装，灵活。&lt;br&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.chenruiwen.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.chenruiwen.cn/tags/nginx/"/>
    
      <category term="运维" scheme="http://www.chenruiwen.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置文件详解</title>
    <link href="http://www.chenruiwen.cn/2018/04/16/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.chenruiwen.cn/2018/04/16/Nginx配置文件详解/</id>
    <published>2018-04-16T03:02:02.000Z</published>
    <updated>2018-04-30T10:04:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考了网上一些博文和文档，总结了一下，方便日后查阅。<br><a id="more"></a></p><p>参考文献:  </p><ul><li><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a>  </li><li><a href="https://docs.nginx.com/" target="_blank" rel="noopener">https://docs.nginx.com/</a></li><li><a href="https://blog.csdn.net/hzsunshine/article/details/63687054" target="_blank" rel="noopener">https://blog.csdn.net/hzsunshine/article/details/63687054</a></li><li><a href="https://blog.csdn.net/field_yang/article/details/52278390" target="_blank" rel="noopener">https://blog.csdn.net/field_yang/article/details/52278390</a></li></ul><h2 id="Nginx-工作原理"><a href="#Nginx-工作原理" class="headerlink" title="Nginx 工作原理"></a>Nginx 工作原理</h2><p>Nginx由<strong>内核</strong>和<strong>模块</strong>组成，完成工作是通过查找配置文件将客户端请求映射到一个location block(location是用于URL匹配的命令)，location配置的命令会启动不同模块完成工作。</p><p>Nginx模块分为核心模块，基础模块和第三方模块。</p><ul><li>核心模块：HTTP模块、EVENT模块(事件)、MAIL模块。</li><li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块、HTTP Rewrite模块。</li><li>第三方模块：HTTP Upstream Request Hash模块、Notice模块、HTTP Access Key模块。</li></ul><h2 id="Nginx-配置文件结构"><a href="#Nginx-配置文件结构" class="headerlink" title="Nginx 配置文件结构"></a>Nginx 配置文件结构</h2><p>配置文件主要由四部分组成：main(全区设置)，server(主机配置)，upstream(负载均衡服务器设置)，和location(URL匹配特定位置设置).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">    events &#123;</span><br><span class="line">      ....</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    http &#123;</span><br><span class="line">        server &#123;</span><br><span class="line">            location &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            location &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        server &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        upstream A &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        upstream B &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Nignx配置文件详解"><a href="#Nignx配置文件详解" class="headerlink" title="Nignx配置文件详解"></a>Nignx配置文件详解</h2><ol><li>全局变量<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Nginx的worker进程运行用户以及用户组，默认为nobody账号</span></span><br><span class="line">user  nobody nobody;</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nginx开启的进程数，每个nginx平均耗内存10~12MB，一般指定一个进程就足够了，建议指定和CPU数目相同的进程数即可。</span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"><span class="comment">#worker_processes auto;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以下参数指定了哪个cpu分配给哪个进程，一般来说不用特殊指定。如果一定要设的话，用0和1指定分配方式.</span></span><br><span class="line"><span class="comment">#这样设就是给1-4个进程分配单独的核来运行，出现第5个进程是就是随机分配了。eg:</span></span><br><span class="line"><span class="comment">#worker_processes 4     #4核CPU </span></span><br><span class="line"><span class="comment">#worker_cpu_affinity 0001 0010 0100 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义全局错误日志定义类型，[debug|info|notice|warn|crit]</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定进程ID存储文件位置</span></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n的值保持一致。worker_rlimit_nofile用于绑定worker进程和CPU，Linux内核2.4以上使用</span></span><br><span class="line">worker_rlimit_nofile <span class="number">65535</span>;</span><br></pre></td></tr></table></figure></li></ol><ul><li>修改ulimit -n 值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#vim /etc/security/limits.conf</span><br><span class="line">#  *                soft    nproc          65535</span><br><span class="line">#  *                hard    nproc          65535</span><br><span class="line">#  *                soft    nofile         65535</span><br><span class="line">#  *                hard    nofile         65535</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>事件配置<br>event指令用来设置nginx的工作模式及连接数上限。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; </span></span><br><span class="line"><span class="comment">#use是个事件模块指令，用于指定工作模式，nginx支持的工作模式有select、poll、kqueue、epoll、rtsig、和/dev/poll，其中select和poll都是标准的工作模式。kqueue和epoll是高效的工作模式，其中kqueue用于BSD系统，而epoll用于Linux系统，对于Linux系统，epoll是首选。</span></span><br><span class="line">use epoll;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># worker_connections时间模块指令，用于定义进程的最大连接数，默认为1024,。</span></span><br><span class="line"><span class="comment">#最大客户连接数由worker_connections和worker_processes决定，即max_client=worker_processes*worker_connections,在作为反向代理时变为：max_client= worker_processes*worker_connections/4。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit –n 65536”后worker_connections的设置才生效。</span></span><br><span class="line">worker_connections  <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#worker工作方式：串行（一定程度降低负载，但服务器吞吐量大时，关闭使用并行方式）</span></span><br><span class="line"><span class="comment">#multi_accept on;</span></span><br></pre></td></tr></table></figure></li><li><p>http参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    #文件扩展名与文件类型映射表,可以减少主配置文件的复杂度。</span><br><span class="line">    include       mime.types;</span><br><span class="line">    #默认文件类型,默认为二进制流</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    </span><br><span class="line">    #nginx的httplog模块指令，用于指定nginx的日志输出格式，main为此日志输出格式的名称，可以在下面access_log指令中使用。</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">                      </span><br><span class="line">    #连接日志的路径，指定的日志格式放在最后。</span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    </span><br><span class="line">    #只记录更为严重的错误日志，减少IO压力</span><br><span class="line">    error_log logs/error.log crit;</span><br><span class="line">    </span><br><span class="line">    #默认编码</span><br><span class="line">    #charset utf-8;</span><br><span class="line">    </span><br><span class="line">    #服务器名字的hash表大小</span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line">    </span><br><span class="line">    #客户端请求单个文件的最大字节数</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line">    </span><br><span class="line">    #指定来自客户端请求头的hearerbuffer大小</span><br><span class="line">    client_header_buffer_size 32k;</span><br><span class="line">    </span><br><span class="line">    #指定客户端请求中较大的消息头的缓存最大数量和大小。</span><br><span class="line">    large_client_header_buffers 4 64k;</span><br><span class="line">    </span><br><span class="line">    #开启高效传输模式。</span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    #防止网络阻塞</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    </span><br><span class="line">    #设置客户端连续保持活动的超时时间。</span><br><span class="line">     keepalive_timeout  65;</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    </span><br><span class="line">    #设置客户端请求头读取超时时间，超过该时间客户端还没发送任何数据，nginx将返回“request time out（408）”错误。</span><br><span class="line">    client_header_timeout 10;</span><br><span class="line">    </span><br><span class="line">    #设置客户端请求主体读取超时时间，默认时间为602s，超过该时间客户端还没发送任何数据，nginx将返回“request timeout（408）”错误。</span><br><span class="line">    client_body_timeout   10;</span><br><span class="line">    </span><br><span class="line">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。</span><br><span class="line">    fastcgi_connect_timeout 300;</span><br><span class="line">    fastcgi_send_timeout 300;</span><br><span class="line">    fastcgi_read_timeout 300;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line">    </span><br><span class="line">#gzip模块设置</span><br><span class="line">    #开启gzip压缩输出</span><br><span class="line">    gzip on; </span><br><span class="line">    </span><br><span class="line">    #最小压缩文件大小</span><br><span class="line">    gzip_min_length 1k; </span><br><span class="line">    </span><br><span class="line">    #压缩缓冲区</span><br><span class="line">    gzip_buffers 4 16k;</span><br><span class="line">    </span><br><span class="line">    #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    </span><br><span class="line">    #压缩等级 1-9 等级越高，压缩效果越好，节约宽带，但CPU消耗大</span><br><span class="line">    gzip_comp_level 2;</span><br><span class="line">    </span><br><span class="line">    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    </span><br><span class="line">    #前端缓存服务器缓存经过压缩的页面</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虚拟主机基本设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    <span class="comment">#监听端口</span></span><br><span class="line">    listen       <span class="number">80</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#访问域名,多个域名之间用空格隔开</span></span><br><span class="line">    server_name  www.example.com;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#编码格式，若网页格式与此不同，将被自动转码</span></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#虚拟主机访问日志定义</span></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#对URL进行匹配</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        <span class="comment">#访问路径，可相对也可绝对路径</span></span><br><span class="line">        root   html;</span><br><span class="line">        <span class="comment">#首页文件。以下按顺序匹配</span></span><br><span class="line">        index  index.html index.htm index.jsp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#错误信息返回页面</span></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">    location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">#php脚本请求全部转发给FastCGI处理</span></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#禁止访问.ht页面 （需ngx_http_access_module模块）</span></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#HTTPS虚拟主机定义</span></span><br><span class="line"><span class="comment"># HTTPS server</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#server &#123;</span></span><br><span class="line"><span class="comment">#    listen       443 ssl;</span></span><br><span class="line"><span class="comment">#    server_name  localhost;</span></span><br><span class="line"><span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line"><span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"><span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line"><span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"><span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line"><span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"><span class="comment">#    location / &#123;</span></span><br><span class="line"><span class="comment">#        root   html;</span></span><br><span class="line"><span class="comment">#        index  index.html index.htm;</span></span><br><span class="line"><span class="comment">#    &#125;</span></span><br><span class="line"><span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>反向代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#以下配置追加在HTTP的全局变量中</span><br><span class="line"></span><br><span class="line">#该部分亦可以使用写进proxy.conf文件中，再使用include指令包含进来，从而使配置显得更简练</span><br><span class="line">#用法：include    /opt/nginx/conf/proxy.conf</span><br><span class="line"></span><br><span class="line">#client_body_buffer_size：用于指定客户端请求主体缓冲区大小，意思就是先保存到本地再传给用户。</span><br><span class="line">client_max_body_size   10m;</span><br><span class="line">client_body_buffer_size   128k;</span><br><span class="line"></span><br><span class="line">#nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">proxy_connect_timeout      5;</span><br><span class="line"></span><br><span class="line">#后端服务器数据回传时间(代理发送超时)</span><br><span class="line">proxy_send_timeout         5;</span><br><span class="line"></span><br><span class="line">#连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">proxy_read_timeout         60;</span><br><span class="line"></span><br><span class="line">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">proxy_buffer_size          16k;</span><br><span class="line"></span><br><span class="line">#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span><br><span class="line">proxy_buffers              4 32k;</span><br><span class="line"></span><br><span class="line">#高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">proxy_busy_buffers_size    64k;</span><br><span class="line"></span><br><span class="line">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">proxy_temp_file_write_size 64k;</span><br><span class="line"></span><br><span class="line">#反向代理缓存目录</span><br><span class="line">proxy_cache_path /data/proxy/cache levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=1g;</span><br><span class="line">#levels=1:2 设置目录深度，第一层目录是1个字符，第2层是2个字符</span><br><span class="line">#keys_zone:设置web缓存名称和内存缓存空间大小</span><br><span class="line">#inactive:自动清除缓存文件时间。</span><br><span class="line">#max_size:硬盘空间最大可使用值。</span><br><span class="line"></span><br><span class="line">#指定临时缓存文件的存储路径(路径需和上面路径在同一分区)</span><br><span class="line">proxy_temp_path  /data/proxy/temp</span><br><span class="line"></span><br><span class="line">#服务配置</span><br><span class="line">server &#123;</span><br><span class="line">    #侦听的80端口</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        #反向代理缓存设置命令(proxy_cache zone|off,默认关闭所以要设置)</span><br><span class="line">        proxy_cache cache_one;</span><br><span class="line">        #对不同的状态码缓存不同时间</span><br><span class="line">        proxy_cache_valid 200 304 12h;</span><br><span class="line">        #设置以什么样参数获取缓存文件名</span><br><span class="line">        proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">        #后7端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr; </span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; </span><br><span class="line">  </span><br><span class="line">        #代理设置</span><br><span class="line">        proxy_pass   http://IP; </span><br><span class="line">        #文件过期时间控制</span><br><span class="line">        expires    1d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #配置手动清楚缓存(实现此功能需第三方模块 ngx_cache_purge)</span><br><span class="line">    #http://www.123.com/2017/0316/17.html访问</span><br><span class="line">    #http://www.123.com/purge/2017/0316/17.html清楚URL缓存</span><br><span class="line">    location ~ /purge(/.*) &#123;</span><br><span class="line">        allow    127.0.0.1;</span><br><span class="line">        deny    all;</span><br><span class="line">        proxy_cache_purge    cache_one    $host$1$is_args$args;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    #设置扩展名以.jsp、.php、.jspx结尾的动态应用程序不做缓存</span><br><span class="line">    location ~.*\.(jsp|php|jspx)?$ &#123; </span><br><span class="line">        proxy_set_header Host $host; </span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr; </span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; </span><br><span class="line">  </span><br><span class="line">        proxy_pass http://http://IP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>负载均衡<br>upstream是nginx的http upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#设置负载均衡器。任意名称命名，使用时调用即可。</span><br><span class="line">upstream my_server_pool &#123;</span><br><span class="line">    #调度算法</span><br><span class="line">    #1.轮循（默认）（weight轮循权值）</span><br><span class="line">    #2.ip_hash：根据每个请求访问IP的hash结果分配。（会话保持）</span><br><span class="line">    #3.fair:根据后端服务器响应时间最短请求。（upstream_fair模块）</span><br><span class="line">    #4.url_hash:根据访问的url的hash结果分配。（需hash软件包）</span><br><span class="line">    #参数：</span><br><span class="line">    #down：表示不参与负载均衡</span><br><span class="line">    #backup:备份服务器</span><br><span class="line">    #max_fails:允许最大请求错误次数</span><br><span class="line">    #fail_timeout:请求失败后暂停服务时间。</span><br><span class="line">    server 192.168.1.109:80 weight=1 max_fails=2 fail_timeout=30;</span><br><span class="line">    server 192.168.1.108:80 weight=2 max_fails=2 fail_timeout=30;</span><br><span class="line">&#125;</span><br><span class="line">#负载均衡调用</span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_pass http://my_server_pool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>URL配置与重写<br>location支持正则表达式和条件判断匹配，可以通过location指令实现nginx对动静态网页的过滤处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL配置</span></span><br><span class="line">    <span class="comment">#所有扩展名为gif|jpg|jpeg|bmp|png|ico|txt|js|css的静态文件都交给nginx处理</span></span><br><span class="line">    location ~ * \.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$  </span><br><span class="line">    &#123;  </span><br><span class="line">        root   /web/wwwroot/html;</span><br><span class="line">        <span class="comment">#expires指定静态文件的过期时间</span></span><br><span class="line">        expires      <span class="number">30</span>d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将upload和html下的所有文件都交给nginx来处理，当然upload和html目录包含在/web/wwwroot/html目录中</span></span><br><span class="line">    location ~^/(upload|html)/   </span><br><span class="line">    &#123;</span><br><span class="line">        root   /web/wwwroot/html;</span><br><span class="line">        expires      <span class="number">30</span>d;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#location对此虚拟机下动态网页的过滤处理，也就是将所有.jsp为后缀的文件都交给本机8080端口处理。</span></span><br><span class="line">    location  ~ .*.jsp$  &#123;</span><br><span class="line">        index       index.jsp;</span><br><span class="line">        proxy_pass     http://localhost:<span class="number">8080</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL重写</span></span><br><span class="line">    <span class="comment">#根据不同的浏览器URL重写</span></span><br><span class="line">    <span class="keyword">if</span>($http_user_agent ~ Firefox)&#123;</span><br><span class="line">        rewrite ^(.*)$  /firefox/$<span class="number">1</span> <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>($http_user_agent ~ MSIE)&#123;</span><br><span class="line">        rewrite ^(.*)$  /msie/$<span class="number">1</span> <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#实现域名跳转</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        rewrite ^/(.*)$ https://web8.example.com$<span class="number">1</span> permanent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>IP限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#限制IP访问</span></span><br><span class="line">location / &#123;</span><br><span class="line">    deny <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>；</span><br><span class="line">    allow <span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span>;</span><br><span class="line">    allow <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span>;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Nignx状态监控</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Nginx运行状态，StubStatus模块获取Nginx自启动的工作状态（编译时要开启对应功能）</span></span><br><span class="line">    <span class="comment">#location /NginxStatus &#123;</span></span><br><span class="line">    <span class="comment">#    #启用StubStatus的工作访问状态    </span></span><br><span class="line">    <span class="comment">#    stub_status    on;</span></span><br><span class="line">    <span class="comment">#    #指定StubStaus模块的访问日志文件</span></span><br><span class="line">    <span class="comment">#    access_log    logs/Nginxstatus.log;</span></span><br><span class="line">    <span class="comment">#    #Nginx认证机制（需Apache的htpasswd命令生成）</span></span><br><span class="line">    <span class="comment">#    #auth_basic    "NginxStatus";</span></span><br><span class="line">    <span class="comment">#    #用来认证的密码文件</span></span><br><span class="line">    <span class="comment">#    #auth_basic_user_file    ../htpasswd;    </span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"><span class="comment">#nginx的auth_basic采用的是与Apache兼容的密码文件，所以需要采用Apache的htpasswd命令来生成密码文件</span></span><br><span class="line"><span class="comment">#如添加一个fieldyang 用户可以用该方式生成密码文件:/usr/local/apache/bin/htpasswd  –c /opt/nginx/conf/htpasswd fieldyang  </span></span><br><span class="line"><span class="comment">#访问：http://IP/NginxStatus(测试就不加密码验证相关)</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;参考了网上一些博文和文档，总结了一下，方便日后查阅。&lt;br&gt;
    
    </summary>
    
      <category term="nginx" scheme="http://www.chenruiwen.cn/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://www.chenruiwen.cn/tags/nginx/"/>
    
      <category term="运维" scheme="http://www.chenruiwen.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>开篇</title>
    <link href="http://www.chenruiwen.cn/2018/04/15/%E5%BC%80%E7%AF%87/"/>
    <id>http://www.chenruiwen.cn/2018/04/15/开篇/</id>
    <published>2018-04-15T02:24:03.000Z</published>
    <updated>2018-04-29T15:21:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>2018年，总感觉是个挺有好感的年份，今年也要经历人生的一件大事了，嘿嘿。</p><p>过去的一年收获很多，在新公司认识了很多让我敬佩的大牛和可爱的小伙伴们，遇到了让我有些敬畏的领导，严格的要求又让我体验到曾经上学时的感觉。</p><p>为什么要建立个人网站？因为coooooooool!</p><p>在工作和学习中经常要查询文档和资料，就经常看到某些大牛们的个人网站，博文的质量很高，网站简介又好看，记录下自己走过的坎和分享技术，让我萌生了做个人网站的想法。终于赶上了一次阿里云特价(错过了腾讯云的特价~~)。所以这篇文章就作为我个人网站的开篇了~</p><p>hey,hello,world. hello, 2018.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年，总感觉是个挺有好感的年份，今年也要经历人生的一件大事了，嘿嘿。&lt;/p&gt;
&lt;p&gt;过去的一年收获很多，在新公司认识了很多让我敬佩的大牛和可爱的小伙伴们，遇到了让我有些敬畏的领导，严格的要求又让我体验到曾经上学时的感觉。&lt;/p&gt;
&lt;p&gt;为什么要建立个人网站？因为coo
      
    
    </summary>
    
      <category term="杂" scheme="http://www.chenruiwen.cn/categories/%E6%9D%82/"/>
    
    
      <category term="杂" scheme="http://www.chenruiwen.cn/tags/%E6%9D%82/"/>
    
  </entry>
  
</feed>
